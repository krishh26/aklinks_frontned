{"ast":null,"code":"/**\r\n * @license Angular v19.2.15\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ɵisPromise as _isPromise, ɵRuntimeError as _RuntimeError, Injectable, ɵisNgModule as _isNgModule, isStandalone, createEnvironmentInjector, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Output, Input, Directive, reflectComponentType, Component, ɵisInjectable as _isInjectable, runInInjectionContext, NgModuleFactory, Compiler, NgZone, afterNextRender, EnvironmentInjector, DestroyRef, ɵConsole as _Console, ɵPendingTasksInternal as _PendingTasksInternal } from '@angular/core';\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, concat, defer, pipe, throwError, EMPTY, ConnectableObservable, Subject, Subscription } from 'rxjs';\nimport { map, switchMap, take, startWith, filter, mergeMap, first, concatMap, tap, catchError, scan, defaultIfEmpty, last as last$1, takeLast, finalize, refCount, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\n\n/**\r\n * The primary routing outlet.\r\n *\r\n * @publicApi\r\n */\nconst PRIMARY_OUTLET = 'primary';\n/**\r\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\r\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\r\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\r\n */\nconst RouteTitleKey = /* @__PURE__ */Symbol('RouteTitle');\nclass ParamsAsMap {\n  params;\n  constructor(params) {\n    this.params = params || {};\n  }\n  has(name) {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n  get(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n    return null;\n  }\n  getAll(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n    return [];\n  }\n  get keys() {\n    return Object.keys(this.params);\n  }\n}\n/**\r\n * Converts a `Params` instance to a `ParamMap`.\r\n * @param params The instance to convert.\r\n * @returns The new map instance.\r\n *\r\n * @publicApi\r\n */\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\n/**\r\n * Matches the route configuration (`route`) against the actual URL (`segments`).\r\n *\r\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\r\n *\r\n * @param segments The remaining unmatched segments in the current navigation\r\n * @param segmentGroup The current segment group being matched\r\n * @param route The `Route` to match against.\r\n *\r\n * @see {@link UrlMatchResult}\r\n * @see {@link Route}\r\n *\r\n * @returns The resulting match information or `null` if the `route` should not match.\r\n * @publicApi\r\n */\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  const parts = route.path.split('/');\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n  const posParams = {};\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams\n  };\n}\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction shallowEqual(a, b) {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\r\n * Gets the keys of an object, including `symbol` keys.\r\n */\nfunction getDataKeys(obj) {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n/**\r\n * Test equality for arrays of strings or a string.\r\n */\nfunction equalArraysOrString(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n/**\r\n * Return the last element of an array.\r\n */\nfunction last(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n  if (_isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n  return of(value);\n}\nconst pathCompareMap = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup\n};\nconst paramCompareMap = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true\n};\nfunction containsTree(container, containee, options) {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\nfunction equalParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;\n  }\n  return true;\n}\nfunction containsParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL.\r\n *\r\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\r\n * serialized tree.\r\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree =\r\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\r\n *     const f = tree.fragment; // return 'fragment'\r\n *     const q = tree.queryParams; // returns {debug: 'true'}\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\r\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\r\n *     g.children['support'].segments; // return 1 segment 'help'\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\nclass UrlTree {\n  root;\n  queryParams;\n  fragment;\n  /** @internal */\n  _queryParamMap;\n  constructor(/** The root segment group of the URL tree */\n  root = new UrlSegmentGroup([], {}), /** The query params of the URL */\n  queryParams = {}, /** The fragment of the URL */\n  fragment = null) {\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new _RuntimeError(4015 /* RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT */, 'The root `UrlSegmentGroup` should not contain `segments`. ' + 'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n      }\n    }\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL segment group.\r\n *\r\n * See `UrlTree` for more information.\r\n *\r\n * @publicApi\r\n */\nclass UrlSegmentGroup {\n  segments;\n  children;\n  /** The parent node in the url tree */\n  parent = null;\n  constructor(/** The URL segments of this group. See `UrlSegment` for more information */\n  segments, /** The list of children of this group */\n  children) {\n    this.segments = segments;\n    this.children = children;\n    Object.values(children).forEach(v => v.parent = this);\n  }\n  /** Whether the segment has child segments */\n  hasChildren() {\n    return this.numberOfChildren > 0;\n  }\n  /** Number of child segments */\n  get numberOfChildren() {\n    return Object.keys(this.children).length;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return serializePaths(this);\n  }\n}\n/**\r\n * @description\r\n *\r\n * Represents a single URL segment.\r\n *\r\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\r\n * parameters associated with the segment.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments;\r\n *     s[0].path; // returns 'team'\r\n *     s[0].parameters; // returns {id: 33}\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\nclass UrlSegment {\n  path;\n  parameters;\n  /** @internal */\n  _parameterMap;\n  constructor(/** The path part of a URL segment */\n  path, /** The matrix parameters associated with a segment */\n  parameters) {\n    this.path = path;\n    this.parameters = parameters;\n  }\n  get parameterMap() {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return serializePath(this);\n  }\n}\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n  let res = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n/**\r\n * @description\r\n *\r\n * Serializes and deserializes a URL string into a URL tree.\r\n *\r\n * The url serialization strategy is customizable. You can\r\n * make all URLs case insensitive by providing a custom UrlSerializer.\r\n *\r\n * See `DefaultUrlSerializer` for an example of a URL serializer.\r\n *\r\n * @publicApi\r\n */\nclass UrlSerializer {\n  static ɵfac = function UrlSerializer_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || UrlSerializer)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlSerializer,\n    factory: () => (() => new DefaultUrlSerializer())(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlSerializer, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => new DefaultUrlSerializer()\n    }]\n  }], null, null);\n})();\n/**\r\n * @description\r\n *\r\n * A default implementation of the `UrlSerializer`.\r\n *\r\n * Example URLs:\r\n *\r\n * ```\r\n * /inbox/33(popup:compose)\r\n * /inbox/33;open=true/messages/44\r\n * ```\r\n *\r\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\r\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\r\n * specify route specific parameters.\r\n *\r\n * @publicApi\r\n */\nclass DefaultUrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url) {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n  /** Converts a `UrlTree` into a url */\n  serialize(tree) {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n    return `${segment}${query}${fragment}`;\n  }\n}\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    const children = [];\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v, k) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n    // use no parenthesis if the only child is a primary outlet route\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n/**\r\n * Encodes a URI string with the default encoding. This function will only ever be called from\r\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\r\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\r\n * have to be encoded per https://url.spec.whatwg.org.\r\n */\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\n/**\r\n * This function should be used to encode both keys and values in a query string key/value. In\r\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\r\n * This function should be used to encode a URL fragment. In the following URL, you need to call\r\n * encodeUriFragment on \"f\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\n/**\r\n * This function should be run on any URI segment as well as the key and value in a key/value\r\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\r\n * \"mk\", and \"mv\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\nfunction serializePath(path) {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join('');\n}\nfunction serializeQueryParams(params) {\n  const strParams = Object.entries(params).map(([name, value]) => {\n    return Array.isArray(value) ? value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n  }).filter(s => s);\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str) {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str) {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\nclass UrlParser {\n  url;\n  remaining;\n  constructor(url) {\n    this.url = url;\n    this.remaining = url;\n  }\n  parseRootSegment() {\n    this.consumeOptional('/');\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n  parseQueryParams() {\n    const params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n  parseFragment() {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n  parseChildren() {\n    if (this.remaining === '') {\n      return {};\n    }\n    this.consumeOptional('/');\n    const segments = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n    let children = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n    let res = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n    return res;\n  }\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  parseSegment() {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new _RuntimeError(4009 /* RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n  parseMatrixParams() {\n    const params = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n  parseParam(params) {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    params[decode(key)] = decode(value);\n  }\n  // Parse a single query parameter `name[=value]`\n  parseQueryParam(params) {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n  // parse `(a/b//outlet_name:c/d)`\n  parseParens(allowPrimary) {\n    const segments = {};\n    this.capture('(');\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n      const next = this.remaining[path.length];\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new _RuntimeError(4010 /* RuntimeErrorCode.UNPARSABLE_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n      }\n      let outletName = undefined;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n      const children = this.parseChildren();\n      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n    return segments;\n  }\n  peekStartsWith(str) {\n    return this.remaining.startsWith(str);\n  }\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  consumeOptional(str) {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n  capture(str) {\n    if (!this.consumeOptional(str)) {\n      throw new _RuntimeError(4011 /* RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n    }\n  }\n}\nfunction createRoot(rootCandidate) {\n  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {\n    [PRIMARY_OUTLET]: rootCandidate\n  }) : rootCandidate;\n}\n/**\r\n * Recursively\r\n * - merges primary segment children into their parents\r\n * - drops empty children (those which have no segments and no children themselves). This latter\r\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\r\n * segment.\r\n * - merges named outlets without a primary segment sibling into the children. This prevents\r\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\r\n * root but the `a` route lives under an empty path primary route.\r\n */\nfunction squashSegmentGroup(segmentGroup) {\n  const newChildren = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    // moves named children in an empty path primary child into this group\n    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } // don't add empty children\n    else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\n/**\r\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\r\n *\r\n * When a segment group has only one child which is a primary outlet, merges that child into the\r\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\r\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\r\n * group into the parent.\r\n */\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n  return s;\n}\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\n\n/**\r\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\r\n *\r\n * @publicApi\r\n *\r\n *\r\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\r\n * @param commands An array of URL fragments with which to construct the new URL tree.\r\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n * segments, followed by the parameters for each segment.\r\n * The fragments are applied to the one provided in the `relativeTo` parameter.\r\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\r\n *     any query parameters.\r\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * // create /team/33/user/11\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\r\n *\r\n * // create /team/33;expand=true/user/11\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\r\n *\r\n * // you can collapse static segments like this (this works only with the first passed-in value):\r\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\r\n *\r\n * // If the first segment can contain slashes, and you do not want the router to split it,\r\n * // you can do the following:\r\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\r\n *\r\n * // create /team/33/(user/11//right:chat)\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\r\n * 'chat'}}], null, null);\r\n *\r\n * // remove the right secondary node\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\r\n *\r\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\r\n * `ActivatedRouteSnapshot` points to `user/11`:\r\n *\r\n * // navigate to /team/33/user/11/details\r\n * createUrlTreeFromSnapshot(snapshot, ['details']);\r\n *\r\n * // navigate to /team/33/user/22\r\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\r\n *\r\n * // navigate to /team/44/user/22\r\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\r\n * ```\r\n */\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\nfunction createSegmentGroupFromRoute(route) {\n  let targetGroup;\n  function createSegmentGroupFromRouteRecursive(currentRoute) {\n    const childOutlets = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n  return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  // There are no commands so the `UrlTree` goes to the same path as the one created from the\n  // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n  // applying any other logic.\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n  const nav = computeNavigation(commands);\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\r\n * Determines if a given command has an `outlets` map. When we encounter a command\r\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\r\n */\nfunction isCommandWithOutlets(command) {\n  return typeof command === 'object' && command != null && command.outlets;\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\n  let qp = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map(v => `${v}`) : `${value}`;\n    });\n  }\n  let rootCandidate;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\n/**\r\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\r\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\r\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\r\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\r\n * value.\r\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n  const children = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\nclass Navigation {\n  isAbsolute;\n  numberOfDoubleDots;\n  commands;\n  constructor(isAbsolute, numberOfDoubleDots, commands) {\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new _RuntimeError(4003 /* RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Root segment cannot have matrix parameters');\n    }\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new _RuntimeError(4004 /* RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) && '{outlets:{}} has to be the last command');\n    }\n  }\n  toRoot() {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n  const res = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {\n          outlets\n        }];\n      }\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') ;else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n    return [...res, cmd];\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nclass Position {\n  segmentGroup;\n  processChildren;\n  index;\n  constructor(segmentGroup, processChildren, index) {\n    this.segmentGroup = segmentGroup;\n    this.processChildren = processChildren;\n    this.index = index;\n  }\n}\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n  if (!target) {\n    // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n    // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n    // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n    // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent;\n    if (!g) {\n      throw new _RuntimeError(4005 /* RuntimeErrorCode.INVALID_DOUBLE_DOTS */, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n  return {\n    [PRIMARY_OUTLET]: commands\n  };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children = {};\n    // If the set of commands applies to anything other than the primary outlet and the child\n    // segment is an empty path primary segment on its own, we want to apply the commands to the\n    // empty child path rather than here. The outcome is that the empty primary child is effectively\n    // removed from the final output UrlTree. Imagine the following config:\n    //\n    // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n    //\n    // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n    // navigation with commands\n    // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n    // root segment because that would result in\n    // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n    // the `ActivatedRoute` rather than updating the existing one.\n    //\n    // Because empty paths do not appear in the URL segments and the fact that the segments used in\n    // the output `UrlTree` are squashed to eliminate these empty paths where possible\n    // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n    // it can be hard to determine what is the right thing to do when applying commands to a\n    // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n    // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n    // the same level of the tree.\n    if (Object.keys(outlets).some(o => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n  const noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    // Do not try to consume command as part of the prefixing if it has outlets because it can\n    // contain outlets other than the one being processed. Consuming the outlets command would\n    // result in other outlets being ignored.\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n  const children = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\nfunction stringify(params) {\n  const res = {};\n  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);\n  return res;\n}\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\nconst IMPERATIVE_NAVIGATION = 'imperative';\n/**\r\n * Identifies the type of a router event.\r\n *\r\n * @publicApi\r\n */\nvar EventType;\n(function (EventType) {\n  EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\n  EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n  EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n  EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\n  EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n  EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\n  EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n  EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n  EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n  EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n  EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n  EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n  EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n  EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\n  EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n  EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\n  EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n})(EventType || (EventType = {}));\n/**\r\n * Base for events the router goes through, as opposed to events tied to a specific\r\n * route. Fired one time for any given navigation.\r\n *\r\n * The following code shows how a class subscribes to router events.\r\n *\r\n * ```ts\r\n * import {Event, RouterEvent, Router} from '@angular/router';\r\n *\r\n * class MyService {\r\n *   constructor(public router: Router) {\r\n *     router.events.pipe(\r\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\r\n *     ).subscribe((e: RouterEvent) => {\r\n *       // Do something\r\n *     });\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see {@link Event}\r\n * @see [Router events summary](guide/routing/router-reference#router-events)\r\n * @publicApi\r\n */\nclass RouterEvent {\n  id;\n  url;\n  constructor(/** A unique ID that the router assigns to every router navigation. */\n  id, /** The URL that is the destination for this navigation. */\n  url) {\n    this.id = id;\n    this.url = url;\n  }\n}\n/**\r\n * An event triggered when a navigation starts.\r\n *\r\n * @publicApi\r\n */\nclass NavigationStart extends RouterEvent {\n  type = EventType.NavigationStart;\n  /**\r\n   * Identifies the call or event that triggered the navigation.\r\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\r\n   *\r\n   * @see {@link NavigationEnd}\r\n   * @see {@link NavigationCancel}\r\n   * @see {@link NavigationError}\r\n   */\n  navigationTrigger;\n  /**\r\n   * The navigation state that was previously supplied to the `pushState` call,\r\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\r\n   *\r\n   * The state object is defined by `NavigationExtras`, and contains any\r\n   * developer-defined state value, as well as a unique ID that\r\n   * the router assigns to every router transition/navigation.\r\n   *\r\n   * From the perspective of the router, the router never \"goes back\".\r\n   * When the user clicks on the back button in the browser,\r\n   * a new navigation ID is created.\r\n   *\r\n   * Use the ID in this previous-state object to differentiate between a newly created\r\n   * state and one returned to by a `popstate` event, so that you can restore some\r\n   * remembered state, such as scroll position.\r\n   *\r\n   */\n  restoredState;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  navigationTrigger = 'imperative', /** @docsNotRequired */\n  restoredState = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n/**\r\n * An event triggered when a navigation ends successfully.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationCancel}\r\n * @see {@link NavigationError}\r\n *\r\n * @publicApi\r\n */\nclass NavigationEnd extends RouterEvent {\n  urlAfterRedirects;\n  type = EventType.NavigationEnd;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n/**\r\n * A code for the `NavigationCancel` event of the `Router` to indicate the\r\n * reason a navigation failed.\r\n *\r\n * @publicApi\r\n */\nvar NavigationCancellationCode;\n(function (NavigationCancellationCode) {\n  /**\r\n   * A navigation failed because a guard returned a `UrlTree` to redirect.\r\n   */\n  NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\n  /**\r\n   * A navigation failed because a more recent navigation started.\r\n   */\n  NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n  /**\r\n   * A navigation failed because one of the resolvers completed without emitting a value.\r\n   */\n  NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n  /**\r\n   * A navigation failed because a guard returned `false`.\r\n   */\n  NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\n})(NavigationCancellationCode || (NavigationCancellationCode = {}));\n/**\r\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\r\n * reason a navigation was skipped.\r\n *\r\n * @publicApi\r\n */\nvar NavigationSkippedCode;\n(function (NavigationSkippedCode) {\n  /**\r\n   * A navigation was skipped because the navigation URL was the same as the current Router URL.\r\n   */\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n  /**\r\n   * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\r\n   * the current Router URL and the target of the navigation.\r\n   *\r\n   * @see {@link UrlHandlingStrategy}\r\n   */\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n})(NavigationSkippedCode || (NavigationSkippedCode = {}));\n/**\r\n * An event triggered when a navigation is canceled, directly or indirectly.\r\n * This can happen for several reasons including when a route guard\r\n * returns `false` or initiates a redirect by returning a `UrlTree`.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationEnd}\r\n * @see {@link NavigationError}\r\n *\r\n * @publicApi\r\n */\nclass NavigationCancel extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationCancel;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url,\n  /**\r\n   * A description of why the navigation was cancelled. For debug purposes only. Use `code`\r\n   * instead for a stable cancellation reason that can be used in production.\r\n   */\n  reason,\n  /**\r\n   * A code to indicate why the navigation was canceled. This cancellation code is stable for\r\n   * the reason and can be relied on whereas the `reason` string could change and should not be\r\n   * used in production.\r\n   */\n  code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n/**\r\n * An event triggered when a navigation is skipped.\r\n * This can happen for a couple reasons including onSameUrlHandling\r\n * is set to `ignore` and the navigation URL is not different than the\r\n * current state.\r\n *\r\n * @publicApi\r\n */\nclass NavigationSkipped extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationSkipped;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url,\n  /**\r\n   * A description of why the navigation was skipped. For debug purposes only. Use `code`\r\n   * instead for a stable skipped reason that can be used in production.\r\n   */\n  reason,\n  /**\r\n   * A code to indicate why the navigation was skipped. This code is stable for\r\n   * the reason and can be relied on whereas the `reason` string could change and should not be\r\n   * used in production.\r\n   */\n  code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n}\n/**\r\n * An event triggered when a navigation fails due to an unexpected error.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationEnd}\r\n * @see {@link NavigationCancel}\r\n *\r\n * @publicApi\r\n */\nclass NavigationError extends RouterEvent {\n  error;\n  target;\n  type = EventType.NavigationError;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  error,\n  /**\r\n   * The target of the navigation when the error occurred.\r\n   *\r\n   * Note that this can be `undefined` because an error could have occurred before the\r\n   * `RouterStateSnapshot` was created for the navigation.\r\n   */\n  target) {\n    super(id, url);\n    this.error = error;\n    this.target = target;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n/**\r\n * An event triggered when routes are recognized.\r\n *\r\n * @publicApi\r\n */\nclass RoutesRecognized extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.RoutesRecognized;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects, /** @docsNotRequired */\n  state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n/**\r\n * An event triggered at the start of the Guard phase of routing.\r\n *\r\n * @see {@link GuardsCheckEnd}\r\n *\r\n * @publicApi\r\n */\nclass GuardsCheckStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.GuardsCheckStart;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects, /** @docsNotRequired */\n  state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n/**\r\n * An event triggered at the end of the Guard phase of routing.\r\n *\r\n * @see {@link GuardsCheckStart}\r\n *\r\n * @publicApi\r\n */\nclass GuardsCheckEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  shouldActivate;\n  type = EventType.GuardsCheckEnd;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects, /** @docsNotRequired */\n  state, /** @docsNotRequired */\n  shouldActivate) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n    this.shouldActivate = shouldActivate;\n  }\n  toString() {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n/**\r\n * An event triggered at the start of the Resolve phase of routing.\r\n *\r\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\r\n * In future, may change to only run when there are things to be resolved.\r\n *\r\n * @see {@link ResolveEnd}\r\n *\r\n * @publicApi\r\n */\nclass ResolveStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveStart;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects, /** @docsNotRequired */\n  state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n/**\r\n * An event triggered at the end of the Resolve phase of routing.\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\nclass ResolveEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveEnd;\n  constructor(/** @docsNotRequired */\n  id, /** @docsNotRequired */\n  url, /** @docsNotRequired */\n  urlAfterRedirects, /** @docsNotRequired */\n  state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n/**\r\n * An event triggered before lazy loading a route configuration.\r\n *\r\n * @see {@link RouteConfigLoadEnd}\r\n *\r\n * @publicApi\r\n */\nclass RouteConfigLoadStart {\n  route;\n  type = EventType.RouteConfigLoadStart;\n  constructor(/** @docsNotRequired */\n  route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n/**\r\n * An event triggered when a route has been lazy loaded.\r\n *\r\n * @see {@link RouteConfigLoadStart}\r\n *\r\n * @publicApi\r\n */\nclass RouteConfigLoadEnd {\n  route;\n  type = EventType.RouteConfigLoadEnd;\n  constructor(/** @docsNotRequired */\n  route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n/**\r\n * An event triggered at the start of the child-activation\r\n * part of the Resolve phase of routing.\r\n * @see {@link ChildActivationEnd}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\nclass ChildActivationStart {\n  snapshot;\n  type = EventType.ChildActivationStart;\n  constructor(/** @docsNotRequired */\n  snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n/**\r\n * An event triggered at the end of the child-activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ChildActivationStart}\r\n * @see {@link ResolveStart}\r\n * @publicApi\r\n */\nclass ChildActivationEnd {\n  snapshot;\n  type = EventType.ChildActivationEnd;\n  constructor(/** @docsNotRequired */\n  snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n/**\r\n * An event triggered at the start of the activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ActivationEnd}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\nclass ActivationStart {\n  snapshot;\n  type = EventType.ActivationStart;\n  constructor(/** @docsNotRequired */\n  snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n/**\r\n * An event triggered at the end of the activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ActivationStart}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\nclass ActivationEnd {\n  snapshot;\n  type = EventType.ActivationEnd;\n  constructor(/** @docsNotRequired */\n  snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n/**\r\n * An event triggered by scrolling.\r\n *\r\n * @publicApi\r\n */\nclass Scroll {\n  routerEvent;\n  position;\n  anchor;\n  type = EventType.Scroll;\n  constructor(/** @docsNotRequired */\n  routerEvent, /** @docsNotRequired */\n  position, /** @docsNotRequired */\n  anchor) {\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n  }\n  toString() {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\nclass BeforeActivateRoutes {}\nclass RedirectRequest {\n  url;\n  navigationBehaviorOptions;\n  constructor(url, navigationBehaviorOptions) {\n    this.url = url;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nfunction stringifyEvent(routerEvent) {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\n\n/**\r\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\r\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\r\n * `currentInjector`.\r\n *\r\n * @param route The route that might have providers\r\n * @param currentInjector The parent injector of the `Route`\r\n */\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route = config[i];\n    const fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\nfunction assertStandalone(fullPath, component) {\n  if (component && _isNgModule(component)) {\n    throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` + `but it must be used with standalone components. Use 'loadChildren' instead.`);\n  } else if (component && !isStandalone(component)) {\n    throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` + `so canActivate will never be executed.`);\n    }\n    if (route.path && route.matcher) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\r\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\r\n * The order of the configs is otherwise preserved.\r\n */\nfunction sortByMatchingOutlets(routes, outletName) {\n  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\n/**\r\n * Gets the first injector in the snapshot's parent tree.\r\n *\r\n * If the `Route` has a static list of providers, the returned injector will be the one created from\r\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\r\n * loaded config or their static providers.\r\n *\r\n * Returns `null` if there is neither this nor any parents have a stored injector.\r\n *\r\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\r\n * also used for getting the correct injector to use for creating components.\r\n */\nfunction getClosestRouteInjector(snapshot) {\n  if (!snapshot) return null;\n  // If the current route has its own injector, which is created from the static providers on the\n  // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n  // include the lazy loaded injector from this route.\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    // Note that the order here is important. `_loadedInjector` stored on the route with\n    // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n    // is created from the static providers on that parent route, so it applies to the children as\n    // well, but only if there is no lazy loaded NgModuleRef injector.\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n  return null;\n}\n\n/**\r\n * Store contextual information about a `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\nclass OutletContext {\n  rootInjector;\n  outlet = null;\n  route = null;\n  children;\n  attachRef = null;\n  get injector() {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\n/**\r\n * Store contextual information about the children (= nested) `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\nclass ChildrenOutletContexts {\n  rootInjector;\n  // contexts for child outlets, by name.\n  contexts = new Map();\n  /** @docs-private */\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n  }\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName, outlet) {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n  /**\r\n   * Called when a `RouterOutlet` directive is destroyed.\r\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\r\n   * re-created later.\r\n   */\n  onChildOutletDestroyed(childName) {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n      context.attachRef = null;\n    }\n  }\n  /**\r\n   * Called when the corresponding route is deactivated during navigation.\r\n   * Because the component get destroyed, all children outlet are destroyed.\r\n   */\n  onOutletDeactivated() {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n  onOutletReAttached(contexts) {\n    this.contexts = contexts;\n  }\n  getOrCreateContext(childName) {\n    let context = this.getContext(childName);\n    if (!context) {\n      context = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context);\n    }\n    return context;\n  }\n  getContext(childName) {\n    return this.contexts.get(childName) || null;\n  }\n  static ɵfac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ChildrenOutletContexts)(i0.ɵɵinject(i0.EnvironmentInjector));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ChildrenOutletContexts,\n    factory: ChildrenOutletContexts.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ChildrenOutletContexts, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i0.EnvironmentInjector\n  }], null);\n})();\nclass Tree {\n  /** @internal */\n  _root;\n  constructor(root) {\n    this._root = root;\n  }\n  get root() {\n    return this._root.value;\n  }\n  /**\r\n   * @internal\r\n   */\n  parent(t) {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n  /**\r\n   * @internal\r\n   */\n  children(t) {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n  /**\r\n   * @internal\r\n   */\n  firstChild(t) {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n  /**\r\n   * @internal\r\n   */\n  siblings(t) {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n  /**\r\n   * @internal\r\n   */\n  pathFromRoot(t) {\n    return findPath(t, this._root).map(s => s.value);\n  }\n}\n// DFS for the node matching the value\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n  return null;\n}\n// Return the path to the node with the given value using DFS\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n  return [];\n}\nclass TreeNode {\n  value;\n  children;\n  constructor(value, children) {\n    this.value = value;\n    this.children = children;\n  }\n  toString() {\n    return `TreeNode(${this.value})`;\n  }\n}\n// Return the list of T indexed by outlet name\nfunction nodeChildrenAsMap(node) {\n  const map = {};\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n  return map;\n}\n\n/**\r\n * Represents the state of the router as a tree of activated routes.\r\n *\r\n * @usageNotes\r\n *\r\n * Every node in the route tree is an `ActivatedRoute` instance\r\n * that knows about the \"consumed\" URL segments, the extracted parameters,\r\n * and the resolved data.\r\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\r\n *\r\n * The following fragment shows how a component gets the root node\r\n * of the current state to establish its own route tree:\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const root: ActivatedRoute = state.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see {@link ActivatedRoute}\r\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\r\n *\r\n * @publicApi\r\n */\nclass RouterState extends Tree {\n  snapshot;\n  /** @internal */\n  constructor(root, /** The current snapshot of the router state */\n  snapshot) {\n    super(root);\n    this.snapshot = snapshot;\n    setRouterState(this, root);\n  }\n  toString() {\n    return this.snapshot.toString();\n  }\n}\nfunction createEmptyState(rootComponent) {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject('');\n  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent) {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\r\n * Provides access to information about a route associated with a component\r\n * that is loaded in an outlet.\r\n * Use to traverse the `RouterState` tree and extract information from nodes.\r\n *\r\n * The following example shows how to construct a component using information from a\r\n * currently activated route.\r\n *\r\n * Note: the observables in this class only emit when the current and previous values differ based\r\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\r\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\r\n *\r\n * {@example router/activated-route/module.ts region=\"activated-route\"\r\n *     header=\"activated-route.component.ts\"}\r\n *\r\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\r\n *\r\n * @publicApi\r\n */\nclass ActivatedRoute {\n  urlSubject;\n  paramsSubject;\n  queryParamsSubject;\n  fragmentSubject;\n  dataSubject;\n  outlet;\n  component;\n  /** The current snapshot of this route */\n  snapshot;\n  /** @internal */\n  _futureSnapshot;\n  /** @internal */\n  _routerState;\n  /** @internal */\n  _paramMap;\n  /** @internal */\n  _queryParamMap;\n  /** An Observable of the resolved route title */\n  title;\n  /** An observable of the URL segments matched by this route. */\n  url;\n  /** An observable of the matrix parameters scoped to this route. */\n  params;\n  /** An observable of the query parameters shared by all the routes. */\n  queryParams;\n  /** An observable of the URL fragment shared by all the routes. */\n  fragment;\n  /** An observable of the static and resolved data of this route. */\n  data;\n  /** @internal */\n  constructor(/** @internal */\n  urlSubject, /** @internal */\n  paramsSubject, /** @internal */\n  queryParamsSubject, /** @internal */\n  fragmentSubject, /** @internal */\n  dataSubject, /** The outlet name of the route, a constant. */\n  outlet, /** The component of the route, a constant. */\n  component, futureSnapshot) {\n    this.urlSubject = urlSubject;\n    this.paramsSubject = paramsSubject;\n    this.queryParamsSubject = queryParamsSubject;\n    this.fragmentSubject = fragmentSubject;\n    this.dataSubject = dataSubject;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map(d => d[RouteTitleKey])) ?? of(undefined);\n    // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n  /** The configuration used to match this route. */\n  get routeConfig() {\n    return this._futureSnapshot.routeConfig;\n  }\n  /** The root of the router state. */\n  get root() {\n    return this._routerState.root;\n  }\n  /** The parent of this route in the router state tree. */\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  /** The first child of this route in the router state tree. */\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  /** The children of this route in the router state tree. */\n  get children() {\n    return this._routerState.children(this);\n  }\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  /**\r\n   * An Observable that contains a map of the required and optional parameters\r\n   * specific to the route.\r\n   * The map supports retrieving single and multiple values from the same parameter.\r\n   */\n  get paramMap() {\n    this._paramMap ??= this.params.pipe(map(p => convertToParamMap(p)));\n    return this._paramMap;\n  }\n  /**\r\n   * An Observable that contains a map of the query parameters available to all routes.\r\n   * The map supports retrieving single and multiple values from the query parameter.\r\n   */\n  get queryParamMap() {\n    this._queryParamMap ??= this.queryParams.pipe(map(p => convertToParamMap(p)));\n    return this._queryParamMap;\n  }\n  toString() {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n/**\r\n * Returns the inherited params, data, and resolve for a given route.\r\n *\r\n * By default, we do not inherit parent data unless the current route is path-less or the parent\r\n * route is component-less.\r\n */\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\n  let inherited;\n  const {\n    routeConfig\n  } = route;\n  if (parent !== null && (paramsInheritanceStrategy === 'always' ||\n  // inherit parent data if route is empty path\n  routeConfig?.path === '' ||\n  // inherit parent data if parent was componentless\n  !parent.component && !parent.routeConfig?.loadComponent)) {\n    inherited = {\n      params: {\n        ...parent.params,\n        ...route.params\n      },\n      data: {\n        ...parent.data,\n        ...route.data\n      },\n      resolve: {\n        // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n        // change data because it's not frozen...\n        // This first line could be deleted chose to break/disallow mutating the `data` object in\n        // guards.\n        // Note that data from parents still override this mutated data so anyone relying on this\n        // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n        ...route.data,\n        // Ensure inherited resolved data overrides inherited static data\n        ...parent.data,\n        // static data from the current route overrides any inherited data\n        ...routeConfig?.data,\n        // resolved data from current route overrides everything\n        ...route._resolvedData\n      }\n    };\n  } else {\n    inherited = {\n      params: {\n        ...route.params\n      },\n      data: {\n        ...route.data\n      },\n      resolve: {\n        ...route.data,\n        ...(route._resolvedData ?? {})\n      }\n    };\n  }\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\n/**\r\n * @description\r\n *\r\n * Contains the information about a route associated with a component loaded in an\r\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\r\n * traverse the router state tree.\r\n *\r\n * The following example initializes a component with route information extracted\r\n * from the snapshot of the root node at the time of creation.\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'./my-component.html'})\r\n * class MyComponent {\r\n *   constructor(route: ActivatedRoute) {\r\n *     const id: string = route.snapshot.params.id;\r\n *     const url: string = route.snapshot.url.join('');\r\n *     const user = route.snapshot.data.user;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\nclass ActivatedRouteSnapshot {\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  outlet;\n  component;\n  /** The configuration used to match this route **/\n  routeConfig;\n  /** @internal */\n  _resolve;\n  /** @internal */\n  _resolvedData;\n  /** @internal */\n  _routerState;\n  /** @internal */\n  _paramMap;\n  /** @internal */\n  _queryParamMap;\n  /** The resolved route title */\n  get title() {\n    // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n    // available at the time of class instantiation.\n    return this.data?.[RouteTitleKey];\n  }\n  /** @internal */\n  constructor(/** The URL segments matched by this route */\n  url,\n  /**\r\n   *  The matrix parameters scoped to this route.\r\n   *\r\n   *  You can compute all params (or data) in the router state or to get params outside\r\n   *  of an activated component by traversing the `RouterState` tree as in the following\r\n   *  example:\r\n   *  ```ts\r\n   *  collectRouteParams(router: Router) {\r\n   *    let params = {};\r\n   *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\r\n   *    while (stack.length > 0) {\r\n   *      const route = stack.pop()!;\r\n   *      params = {...params, ...route.params};\r\n   *      stack.push(...route.children);\r\n   *    }\r\n   *    return params;\r\n   *  }\r\n   *  ```\r\n   */\n  params, /** The query parameters shared by all the routes */\n  queryParams, /** The URL fragment shared by all the routes */\n  fragment, /** The static and resolved data of this route */\n  data, /** The outlet name of the route */\n  outlet, /** The component of the route */\n  component, routeConfig, resolve) {\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n  /** The root of the router state */\n  get root() {\n    return this._routerState.root;\n  }\n  /** The parent of this route in the router state tree */\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  /** The first child of this route in the router state tree */\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  /** The children of this route in the router state tree */\n  get children() {\n    return this._routerState.children(this);\n  }\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n/**\r\n * @description\r\n *\r\n * Represents the state of the router at a moment in time.\r\n *\r\n * This is a tree of activated route snapshots. Every node in this tree knows about\r\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\r\n *\r\n * The following example shows how a component is initialized with information\r\n * from the snapshot of the root node's state at the time of creation.\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const snapshot: RouterStateSnapshot = state.snapshot;\r\n *     const root: ActivatedRouteSnapshot = snapshot.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\nclass RouterStateSnapshot extends Tree {\n  url;\n  /** @internal */\n  constructor(/** The url from which this snapshot was created */\n  url, root) {\n    super(root);\n    this.url = url;\n    setRouterState(this, root);\n  }\n  toString() {\n    return serializeNode(this._root);\n  }\n}\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n/**\r\n * The expectation is that the activate route is created with the right set of parameters.\r\n * So we push new values into the observables only when they are not the initial values.\r\n * And we detect that by checking if the snapshot field is set.\r\n */\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n    // this is for resolved data\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\n}\nfunction hasStaticTitle(config) {\n  return typeof config.title === 'string' || config.title === null;\n}\n\n/**\r\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\r\n * input.\r\n *\r\n * When unset, this value is `null` by default.\r\n *\r\n * @usageNotes\r\n *\r\n * To set the data from the template of the component with `router-outlet`:\r\n * ```html\r\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\r\n * ```\r\n *\r\n * To read the data in the routed component:\r\n * ```ts\r\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\r\n * ```\r\n *\r\n * @publicApi\r\n */\nconst ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? 'RouterOutlet data' : '');\n/**\r\n * @description\r\n *\r\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\r\n *\r\n * Each outlet can have a unique name, determined by the optional `name` attribute.\r\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\r\n *\r\n * ```html\r\n * <router-outlet></router-outlet>\r\n * <router-outlet name='left'></router-outlet>\r\n * <router-outlet name='right'></router-outlet>\r\n * ```\r\n *\r\n * Named outlets can be the targets of secondary routes.\r\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\r\n *\r\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\r\n *\r\n * Using named outlets and secondary routes, you can target multiple outlets in\r\n * the same `RouterLink` directive.\r\n *\r\n * The router keeps track of separate branches in a navigation tree for each named outlet and\r\n * generates a representation of that tree in the URL.\r\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\r\n * routes at the same time:\r\n *\r\n * `http://base-path/primary-route-path(outlet-name:route-path)`\r\n *\r\n * A router outlet emits an activate event when a new component is instantiated,\r\n * deactivate event when a component is destroyed.\r\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\r\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\r\n * detach the subtree.\r\n *\r\n * ```html\r\n * <router-outlet\r\n *   (activate)='onActivate($event)'\r\n *   (deactivate)='onDeactivate($event)'\r\n *   (attach)='onAttach($event)'\r\n *   (detach)='onDetach($event)'></router-outlet>\r\n * ```\r\n *\r\n * @see {@link RouterLink}\r\n * @see {@link Route}\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\nclass RouterOutlet {\n  activated = null;\n  /** @internal */\n  get activatedComponentRef() {\n    return this.activated;\n  }\n  _activatedRoute = null;\n  /**\r\n   * The name of the outlet\r\n   *\r\n   */\n  name = PRIMARY_OUTLET;\n  activateEvents = new EventEmitter();\n  deactivateEvents = new EventEmitter();\n  /**\r\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\r\n   * previously detached subtree.\r\n   **/\n  attachEvents = new EventEmitter();\n  /**\r\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\r\n   * subtree.\r\n   */\n  detachEvents = new EventEmitter();\n  /**\r\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\r\n   *\r\n   * When unset, the value of the token is `undefined` by default.\r\n   */\n  routerOutletData = input(undefined);\n  parentContexts = inject(ChildrenOutletContexts);\n  location = inject(ViewContainerRef);\n  changeDetector = inject(ChangeDetectorRef);\n  inputBinder = inject(INPUT_BINDER, {\n    optional: true\n  });\n  /** @docs-private */\n  supportsBindingToComponentInputs = true;\n  /** @docs-private */\n  ngOnChanges(changes) {\n    if (changes['name']) {\n      const {\n        firstChange,\n        previousValue\n      } = changes['name'];\n      if (firstChange) {\n        // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n        // input is set at all, we need to centrally handle the first change there.\n        return;\n      }\n      // unregister with the old name\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      // register the new name\n      this.initializeOutletWithName();\n    }\n  }\n  /** @docs-private */\n  ngOnDestroy() {\n    // Ensure that the registered outlet is this one before removing it on the context.\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n  isTrackedInParentContexts(outletName) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n  /** @docs-private */\n  ngOnInit() {\n    this.initializeOutletWithName();\n  }\n  initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n    // If the outlet was not instantiated at the time the route got activated we need to populate\n    // the outlet when it is initialized (ie inside a NgIf)\n    const context = this.parentContexts.getContext(this.name);\n    if (context?.route) {\n      if (context.attachRef) {\n        // `attachRef` is populated when there is an existing component to mount\n        this.attach(context.attachRef, context.route);\n      } else {\n        // otherwise the component defined in the configuration is created\n        this.activateWith(context.route, context.injector);\n      }\n    }\n  }\n  get isActivated() {\n    return !!this.activated;\n  }\n  /**\r\n   * @returns The currently activated component instance.\r\n   * @throws An error if the outlet is not activated.\r\n   */\n  get component() {\n    if (!this.activated) throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    return this.activated.instance;\n  }\n  get activatedRoute() {\n    if (!this.activated) throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    return this._activatedRoute;\n  }\n  get activatedRouteData() {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n  /**\r\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n   */\n  detach() {\n    if (!this.activated) throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n  /**\r\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n   */\n  attach(ref, activatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n  deactivate() {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n  activateWith(activatedRoute, environmentInjector) {\n    if (this.isActivated) {\n      throw new _RuntimeError(4013 /* RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    const location = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\n    this.activated = location.createComponent(component, {\n      index: location.length,\n      injector,\n      environmentInjector: environmentInjector\n    });\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n  static ɵfac = function RouterOutlet_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || RouterOutlet)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RouterOutlet,\n    selectors: [[\"router-outlet\"]],\n    inputs: {\n      name: \"name\",\n      routerOutletData: [1, \"routerOutletData\"]\n    },\n    outputs: {\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\",\n      attachEvents: \"attach\",\n      detachEvents: \"detach\"\n    },\n    exportAs: [\"outlet\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouterOutlet, [{\n    type: Directive,\n    args: [{\n      selector: 'router-outlet',\n      exportAs: 'outlet'\n    }]\n  }], null, {\n    name: [{\n      type: Input\n    }],\n    activateEvents: [{\n      type: Output,\n      args: ['activate']\n    }],\n    deactivateEvents: [{\n      type: Output,\n      args: ['deactivate']\n    }],\n    attachEvents: [{\n      type: Output,\n      args: ['attach']\n    }],\n    detachEvents: [{\n      type: Output,\n      args: ['detach']\n    }]\n  });\n})();\nclass OutletInjector {\n  route;\n  childContexts;\n  parent;\n  outletData;\n  constructor(route, childContexts, parent, outletData) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n    this.outletData = outletData;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n}\nconst INPUT_BINDER = new InjectionToken('');\n/**\r\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\r\n * inputs.\r\n *\r\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\r\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\r\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\r\n * Importantly, when an input does not have an item in the route data with a matching key, this\r\n * input is set to `undefined`. If it were not done this way, the previous information would be\r\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\r\n *\r\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\r\n * the subscriptions are cleaned up.\r\n */\nclass RoutedComponentInputBinder {\n  outletDataSubscriptions = new Map();\n  bindActivatedRouteToOutletComponent(outlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n  unsubscribeFromRouteData(outlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n  subscribeToRouteData(outlet) {\n    const {\n      activatedRoute\n    } = outlet;\n    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n      data = {\n        ...queryParams,\n        ...params,\n        ...data\n      };\n      // Get the first result from the data subscription synchronously so it's available to\n      // the component as soon as possible (and doesn't require a second change detection).\n      if (index === 0) {\n        return of(data);\n      }\n      // Promise.resolve is used to avoid synchronously writing the wrong data when\n      // two of the Observables in the `combineLatest` stream emit one after\n      // another.\n      return Promise.resolve(data);\n    })).subscribe(data => {\n      // Outlet may have been deactivated or changed names to be associated with a different\n      // route\n      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      const mirror = reflectComponentType(activatedRoute.component);\n      if (!mirror) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      for (const {\n        templateName\n      } of mirror.inputs) {\n        outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n      }\n    });\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n  static ɵfac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || RoutedComponentInputBinder)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutedComponentInputBinder,\n    factory: RoutedComponentInputBinder.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RoutedComponentInputBinder, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\r\n * This component is used internally within the router to be a placeholder when an empty\r\n * router-outlet is needed. For example, with a config such as:\r\n *\r\n * `{path: 'parent', outlet: 'nav', children: [...]}`\r\n *\r\n * In order to render, there needs to be a component on this config, which will default\r\n * to this `EmptyOutletComponent`.\r\n */\nclass ɵEmptyOutletComponent {\n  static ɵfac = function ɵEmptyOutletComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵEmptyOutletComponent)();\n  };\n  static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ɵEmptyOutletComponent,\n    selectors: [[\"ng-component\"]],\n    exportAs: [\"emptyRouterOutlet\"],\n    decls: 1,\n    vars: 0,\n    template: function _EmptyOutletComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"router-outlet\");\n      }\n    },\n    dependencies: [RouterOutlet],\n    encapsulation: 2\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵEmptyOutletComponent, [{\n    type: Component,\n    args: [{\n      template: `<router-outlet/>`,\n      imports: [RouterOutlet],\n      // Used to avoid component ID collisions with user code.\n      exportAs: 'emptyRouterOutlet'\n    }]\n  }], null, null);\n})();\n/**\r\n * Makes a copy of the config and adds any default required properties.\r\n */\nfunction standardizeConfig(r) {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {\n    ...r,\n    children\n  } : {\n    ...r\n  };\n  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = ɵEmptyOutletComponent;\n  }\n  return c;\n}\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      // retrieve an activated route that is used to be displayed, but is not currently displayed\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = detachedRouteHandle.route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n    return new TreeNode(value, children);\n  }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n\n/**\r\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\r\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\r\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\r\n * about _how_ to perform the navigation.\r\n *\r\n * ```ts\r\n * const route: Route = {\r\n *   path: \"user/:userId\",\r\n *   component: User,\r\n *   canActivate: [\r\n *     () => {\r\n *       const router = inject(Router);\r\n *       const authService = inject(AuthenticationService);\r\n *\r\n *       if (!authService.isLoggedIn()) {\r\n *         const loginPath = router.parseUrl(\"/login\");\r\n *         return new RedirectCommand(loginPath, {\r\n *           skipLocationChange: \"true\",\r\n *         });\r\n *       }\r\n *\r\n *       return true;\r\n *     },\r\n *   ],\r\n * };\r\n * ```\r\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\r\n *\r\n * @publicApi\r\n */\nclass RedirectCommand {\n  redirectTo;\n  navigationBehaviorOptions;\n  constructor(redirectTo, navigationBehaviorOptions) {\n    this.redirectTo = redirectTo;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\nfunction redirectingNavigationError(urlSerializer, redirect) {\n  const {\n    redirectTo,\n    navigationBehaviorOptions\n  } = isUrlTree(redirect) ? {\n    redirectTo: redirect,\n    navigationBehaviorOptions: undefined\n  } : redirect;\n  const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\nfunction navigationCancelingError(message, code) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`);\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n  return isNavigationCancelingError(error) && isUrlTree(error.url);\n}\nfunction isNavigationCancelingError(error) {\n  return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\nlet warnedAboutUnsupportedInputBinding = false;\nconst activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map(t => {\n  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\n  return t;\n});\nclass ActivateRoutes {\n  routeReuseStrategy;\n  futureState;\n  currState;\n  forwardEvent;\n  inputBindingEnabled;\n  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n    this.inputBindingEnabled = inputBindingEnabled;\n  }\n  activate(parentContexts) {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n  // De-activate the child route that are not re-used for the future state\n  deactivateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n    // De-activate the routes that will not be re-used\n    Object.values(children).forEach(v => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n  deactivateRoutes(futureNode, currNode, parentContext) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n  deactivateRouteAndItsChildren(route, parentContexts) {\n    // If there is no component, the Route is never attached to an outlet (because there is no\n    // component to attach).\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n  detachAndStoreRouteSubtree(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {\n        componentRef,\n        route,\n        contexts\n      });\n    }\n  }\n  deactivateRouteAndOutlet(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    // The context could be `null` if we are on a componentless route but there may still be\n    // children that need deactivating.\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context) {\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n      // Clear the information about the attached component on the context but keep the reference to\n      // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n      // info\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n  activateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n  activateRoutes(futureNode, currNode, parentContexts) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    advanceActivatedRoute(future);\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = this.routeReuseStrategy.retrieve(future.snapshot);\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, context.injector);\n          }\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {\n        console.warn(`'withComponentInputBinding' feature is enabled but ` + `this application is using an outlet that may not support binding to component inputs.`);\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\nclass CanActivate {\n  path;\n  route;\n  constructor(path) {\n    this.path = path;\n    this.route = this.path[this.path.length - 1];\n  }\n}\nclass CanDeactivate {\n  component;\n  route;\n  constructor(component, route) {\n    this.component = component;\n    this.route = route;\n  }\n}\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n  const NOT_FOUND = Symbol();\n  const result = injector.get(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\n      // We think the token is just a function so return it as-is\n      return tokenOrFunction;\n    } else {\n      // This will throw the not found error\n      return injector.get(tokenOrFunction);\n    }\n  }\n  return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const prevChildren = nodeChildrenAsMap(currNode);\n  // Process the children of the future route\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n  // Process any children left from the current route (not active for the future route)\n  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n  return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n  return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'always':\n      return true;\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n\n/**\r\n * Simple function check, but generic so type inference will flow. Example:\r\n *\r\n * function product(a: number, b: number) {\r\n *   return a * b;\r\n * }\r\n *\r\n * if (isFunction<product>(fn)) {\r\n *   return fn(1, 2);\r\n * } else {\r\n *   throw \"Must provide the `product` function\";\r\n * }\r\n */\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\nfunction isBoolean(v) {\n  return typeof v === 'boolean';\n}\nfunction isCanLoad(guard) {\n  return guard && isFunction(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n  return guard && isFunction(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n  return guard && isFunction(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n  return guard && isFunction(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n  return guard && isFunction(guard.canMatch);\n}\nfunction isEmptyError(e) {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\nconst INITIAL_VALUE = /* @__PURE__ */Symbol('INITIAL_VALUE');\nfunction prioritizedGuardValue() {\n  return switchMap(obs => {\n    return combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map(results => {\n      for (const result of results) {\n        if (result === true) {\n          // If result is true, check the next one\n          continue;\n        } else if (result === INITIAL_VALUE) {\n          // If guard has not finished, we need to stop processing.\n          return INITIAL_VALUE;\n        } else if (result === false || isRedirect(result)) {\n          // Result finished and was not true. Return the result.\n          // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n          // ignored.\n          return result;\n        }\n      }\n      // Everything resolved to true. Return true.\n      return true;\n    }), filter(item => item !== INITIAL_VALUE), take(1));\n  });\n}\nfunction isRedirect(val) {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\nfunction checkGuards(injector, forwardEvent) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {\n        canActivateChecks,\n        canDeactivateChecks\n      }\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({\n        ...t,\n        guardsResult: true\n      });\n    }\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap(canDeactivate => {\n      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);\n    }), map(guardsResult => ({\n      ...t,\n      guardsResult\n    })));\n  });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n  return from(checks).pipe(mergeMap(check => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first(result => {\n    return result !== true;\n  }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n  return from(checks).pipe(concatMap(check => {\n    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n  }), first(result => {\n    return result !== true;\n  }, true));\n}\n/**\r\n * This should fire off `ActivationStart` events for each route being activated at this\r\n * level.\r\n * In other words, if you're activating `a` and `b` below, `path` will contain the\r\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\r\n * return\r\n * `true` so checks continue to run.\r\n */\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\n/**\r\n * This should fire off `ChildActivationStart` events for each route being activated at this\r\n * level.\r\n * In other words, if you're activating `a` and `b` below, `path` will contain the\r\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\r\n * return\r\n * `true` so checks continue to run.\r\n */\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS, injector) {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  const canActivateObservables = canActivate.map(canActivate => {\n    return defer(() => {\n      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n      const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path, injector) {\n  const futureARS = path[path.length - 1];\n  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(p => getCanActivateChild(p)).filter(_ => _ !== null);\n  const canActivateChildGuardsMapped = canActivateChildGuards.map(d => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(canActivateChild => {\n        const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map(c => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity(c, closestInjector);\n    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n  const canLoadObservables = canLoad.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n  return pipe(tap(result => {\n    if (typeof result === 'boolean') return;\n    throw redirectingNavigationError(urlSerializer, result);\n  }), map(result => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n  const canMatchObservables = canMatch.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nclass NoMatch {\n  segmentGroup;\n  constructor(segmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\nclass AbsoluteRedirect extends Error {\n  urlTree;\n  constructor(urlTree) {\n    super();\n    this.urlTree = urlTree;\n  }\n}\nfunction noMatch$1(segmentGroup) {\n  return throwError(new NoMatch(segmentGroup));\n}\nfunction namedOutletsRedirect(redirectTo) {\n  return throwError(new _RuntimeError(4000 /* RuntimeErrorCode.NAMED_OUTLET_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\nfunction canLoadFails(route) {\n  return throwError(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\n}\nclass ApplyRedirects {\n  urlSerializer;\n  urlTree;\n  constructor(urlSerializer, urlTree) {\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n  }\n  lineralizeSegments(route, urlTree) {\n    let res = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo}`);\n      }\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n    if (typeof redirectTo !== 'string') {\n      const redirectToFn = redirectTo;\n      const {\n        queryParams,\n        fragment,\n        routeConfig,\n        url,\n        outlet,\n        params,\n        data,\n        title\n      } = currentSnapshot;\n      const newRedirect = runInInjectionContext(injector, () => redirectToFn({\n        params,\n        data,\n        queryParams,\n        fragment,\n        routeConfig,\n        url,\n        outlet,\n        title\n      }));\n      if (newRedirect instanceof UrlTree) {\n        throw new AbsoluteRedirect(newRedirect);\n      }\n      redirectTo = newRedirect;\n    }\n    const newTree = this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    if (redirectTo[0] === '/') {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n  }\n  createQueryParams(redirectToParams, actualParams) {\n    const res = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n  createSegmentGroup(redirectTo, group, segments, posParams) {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n    let children = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));\n  }\n  findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos) throw new _RuntimeError(4001 /* RuntimeErrorCode.MISSING_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n  findOrReturn(redirectToUrlSegment, actualSegments) {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\nconst noMatch = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n  // Only create the Route's `EnvironmentInjector` if it matches the attempted\n  // navigation\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map(v => v === true ? result : {\n    ...noMatch\n  }));\n}\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '**') {\n    return createWildcardMatchResult(segments);\n  }\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        ...noMatch\n      };\n    }\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {\n    ...noMatch\n  };\n  const posParams = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ? {\n    ...posParams,\n    ...res.consumed[res.consumed.length - 1].parameters\n  } : posParams;\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\nfunction createWildcardMatchResult(segments) {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last(segments).parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {}\n  };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: s,\n      slicedSegments: []\n    };\n  }\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n    return {\n      segmentGroup: s,\n      slicedSegments\n    };\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {\n    segmentGroup: s,\n    slicedSegments\n  };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  const res = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {\n    ...children,\n    ...res\n  };\n}\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\n  const res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n  return r.path === '';\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\n\n/**\r\n * Class used to indicate there were no additional route config matches but that all segments of\r\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\r\n * try to match child configs in case there are empty path children.\r\n */\nclass NoLeftoversInUrl {}\nfunction recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly') {\n  return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\n}\nconst MAX_ALLOWED_REDIRECTS = 31;\nclass Recognizer {\n  injector;\n  configLoader;\n  rootComponentType;\n  config;\n  urlTree;\n  paramsInheritanceStrategy;\n  urlSerializer;\n  applyRedirects;\n  absoluteRedirectCount = 0;\n  allowRedirects = true;\n  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.urlSerializer = urlSerializer;\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n  noMatchError(e) {\n    return new _RuntimeError(4002 /* RuntimeErrorCode.NO_MATCH */, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);\n  }\n  recognize() {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n    return this.match(rootSegmentGroup).pipe(map(({\n      children,\n      rootSnapshot\n    }) => {\n      const rootNode = new TreeNode(rootSnapshot, children);\n      const routeState = new RouterStateSnapshot('', rootNode);\n      const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n      // https://github.com/angular/angular/issues/47307\n      // Creating the tree stringifies the query params\n      // We don't want to do this here so reassign them to the original.\n      tree.queryParams = this.urlTree.queryParams;\n      routeState.url = this.urlSerializer.serialize(tree);\n      return {\n        state: routeState,\n        tree\n      };\n    }));\n  }\n  match(rootSegmentGroup) {\n    // Use Object.freeze to prevent readers of the Router state from modifying it outside\n    // of a navigation, resulting in the router being out of sync with the browser.\n    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\n    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map(children => {\n      return {\n        children,\n        rootSnapshot\n      };\n    }), catchError(e => {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n      throw e;\n    }));\n  }\n  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map(child => child instanceof TreeNode ? [child] : []));\n  }\n  /**\r\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\r\n   * we cannot find a match for _any_ of the children.\r\n   *\r\n   * @param config - The `Routes` to match against\r\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\r\n   *     config.\r\n   */\n  processChildren(injector, config, segmentGroup, parentRoute) {\n    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n    // because an absolute redirect from the primary outlet takes precedence.\n    const childOutlets = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(concatMap(childOutlet => {\n      const child = segmentGroup.children[childOutlet];\n      // Sort the config so that routes with outlets that match the one being activated\n      // appear first, followed by routes for other outlets, which might match if they have\n      // an empty path.\n      const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n    }), scan((children, outletChildren) => {\n      children.push(...outletChildren);\n      return children;\n    }), defaultIfEmpty(null), last$1(), mergeMap(children => {\n      if (children === null) return noMatch$1(segmentGroup);\n      // Because we may have matched two outlets to the same empty path segment, we can have\n      // multiple activated results for the same outlet. We should merge the children of\n      // these results so the final return value is only one `TreeNode` per outlet.\n      const mergedChildren = mergeEmptyPathMatches(children);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // This should really never happen - we are only taking the first match for each\n        // outlet and merge the empty path matches.\n        checkOutletNameUniqueness(mergedChildren);\n      }\n      sortActivatedRouteSnapshots(mergedChildren);\n      return of(mergedChildren);\n    }));\n  }\n  processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n    return from(routes).pipe(concatMap(r => {\n      return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError(e => {\n        if (e instanceof NoMatch) {\n          return of(null);\n        }\n        throw e;\n      }));\n    }), first(x => !!x), catchError(e => {\n      if (isEmptyError(e)) {\n        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n          return of(new NoLeftoversInUrl());\n        }\n        return noMatch$1(segmentGroup);\n      }\n      throw e;\n    }));\n  }\n  processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n    // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n    // a config like\n    // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n    // or even\n    // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n    //\n    // The exception here is when the segment outlet is for the primary outlet. This would\n    // result in a match inside the named outlet because all children there are written as primary\n    // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n    // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n    // This should only match if the url is `/(x:b)`.\n    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n      return noMatch$1(rawSegment);\n    }\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n    }\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n    }\n    return noMatch$1(rawSegment);\n  }\n  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n    const {\n      matched,\n      parameters,\n      consumedSegments,\n      positionalParamSegments,\n      remainingSegments\n    } = match(segmentGroup, route, segments);\n    if (!matched) return noMatch$1(segmentGroup);\n    // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n    // size exceeded in production\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new _RuntimeError(4016 /* RuntimeErrorCode.INFINITE_REDIRECT */, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(mergeMap(newSegments => {\n      return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n    }));\n  }\n  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n      // We should investigate a better strategy for any existing children. Otherwise, these\n      // child segments are silently dropped from the navigation.\n      // https://github.com/angular/angular/issues/40089\n      rawSegment.children = {};\n    }\n    return matchResult.pipe(switchMap(result => {\n      if (!result.matched) {\n        return noMatch$1(rawSegment);\n      }\n      // If the route has an injector created from providers, we should start using that.\n      injector = route._injector ?? injector;\n      return this.getChildConfig(injector, route, segments).pipe(switchMap(({\n        routes: childConfig\n      }) => {\n        const childInjector = route._loadedInjector ?? injector;\n        const {\n          parameters,\n          consumedSegments,\n          remainingSegments\n        } = result;\n        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({\n          ...this.urlTree.queryParams\n        }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n        snapshot.params = Object.freeze(inherited.params);\n        snapshot.data = Object.freeze(inherited.data);\n        const {\n          segmentGroup,\n          slicedSegments\n        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map(children => {\n            return new TreeNode(snapshot, children);\n          }));\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new TreeNode(snapshot, []));\n        }\n        const matchedOnOutlet = getOutlet(route) === outlet;\n        // If we matched a config due to empty path match on a different outlet, we need to\n        // continue passing the current outlet for the segment rather than switch to PRIMARY.\n        // Note that we switch to primary when we have a match because outlet configs look like\n        // this: {path: 'a', outlet: 'a', children: [\n        //  {path: 'b', component: B},\n        //  {path: 'c', component: C},\n        // ]}\n        // Notice that the children of the named outlet are configured with the primary outlet\n        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map(child => {\n          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n        }));\n      }));\n    }));\n  }\n  getChildConfig(injector, route, segments) {\n    if (route.children) {\n      // The children belong to the same module\n      return of({\n        routes: route.children,\n        injector\n      });\n    }\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedRoutes !== undefined) {\n        return of({\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        });\n      }\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap(shouldLoadResult => {\n        if (shouldLoadResult) {\n          return this.configLoader.loadChildren(injector, route).pipe(tap(cfg => {\n            route._loadedRoutes = cfg.routes;\n            route._loadedInjector = cfg.injector;\n          }));\n        }\n        return canLoadFails(route);\n      }));\n    }\n    return of({\n      routes: [],\n      injector\n    });\n  }\n}\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\nfunction hasEmptyPathConfig(node) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\n/**\r\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\r\n * the children from each duplicate. This is necessary because different outlets can match a\r\n * single empty path route config and the results need to then be merged.\r\n */\nfunction mergeEmptyPathMatches(nodes) {\n  const result = [];\n  // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n  const mergedNodes = new Set();\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n  // by also merging those children. This is necessary when there are multiple empty path configs\n  // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n  // if any of those children can be combined into a single node as well.\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n  const names = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new _RuntimeError(4006 /* RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\nfunction getData(route) {\n  return route.data || {};\n}\nfunction getResolve(route) {\n  return route.resolve || {};\n}\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy) {\n  return mergeMap(t => recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({\n    state: targetSnapshot,\n    tree: urlAfterRedirects\n  }) => {\n    return {\n      ...t,\n      targetSnapshot,\n      urlAfterRedirects\n    };\n  })));\n}\nfunction resolveData(paramsInheritanceStrategy, injector) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      guards: {\n        canActivateChecks\n      }\n    } = t;\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n    // preserve the correct order that the resolvers should run in.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n    const routesWithResolversToRun = new Set(canActivateChecks.map(check => check.route));\n    const routesNeedingDataUpdates = new Set();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      // All children under the route with a resolver to run need to recompute inherited data.\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(concatMap(route => {\n      if (routesWithResolversToRun.has(route)) {\n        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\n      } else {\n        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n        return of(void 0);\n      }\n    }), tap(() => routesProcessed++), takeLast(1), mergeMap(_ => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));\n  });\n}\n/**\r\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\r\n */\nfunction flattenRouteTree(route) {\n  const descendants = route.children.map(child => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map(resolvedData => {\n    futureARS._resolvedData = resolvedData;\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return null;\n  }));\n}\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data = {};\n  return from(keys).pipe(mergeMap(key => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap(value => {\n    if (value instanceof RedirectCommand) {\n      throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n    }\n    data[key] = value;\n  }))), takeLast(1), map(() => data), catchError(e => isEmptyError(e) ? EMPTY : throwError(e)));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\n\n/**\r\n * Perform a side effect through a switchMap for every emission on the source Observable,\r\n * but return an Observable that is identical to the source. It's essentially the same as\r\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\r\n * it will wait before continuing with the original value.\r\n */\nfunction switchTap(next) {\n  return switchMap(v => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\n\n/**\r\n * Provides a strategy for setting the page title after a router navigation.\r\n *\r\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\r\n * outlet with `title` property. Given the `Routes` below, navigating to\r\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\r\n * ```ts\r\n * [\r\n *   {path: 'base', title: 'base', children: [\r\n *     {path: 'child', title: 'child'},\r\n *   ],\r\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\r\n * ]\r\n * ```\r\n *\r\n * This class can be used as a base class for custom title strategies. That is, you can create your\r\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\r\n * from the named outlet is never used. However, a custom strategy might be implemented to\r\n * incorporate titles in named outlets.\r\n *\r\n * @publicApi\r\n * @see [Page title guide](guide/routing/common-router-tasks#setting-the-page-title)\r\n */\nclass TitleStrategy {\n  /**\r\n   * @returns The `title` of the deepest primary route.\r\n   */\n  buildTitle(snapshot) {\n    let pageTitle;\n    let route = snapshot.root;\n    while (route !== undefined) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find(child => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n  /**\r\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\r\n   * `Route.title` property, which can either be a static string or a resolved value.\r\n   */\n  getResolvedTitleForRoute(snapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n  static ɵfac = function TitleStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TitleStrategy)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TitleStrategy,\n    factory: () => (() => inject(DefaultTitleStrategy))(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TitleStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => inject(DefaultTitleStrategy)\n    }]\n  }], null, null);\n})();\n/**\r\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\r\n */\nclass DefaultTitleStrategy extends TitleStrategy {\n  title;\n  constructor(title) {\n    super();\n    this.title = title;\n  }\n  /**\r\n   * Sets the title of the browser to the given value.\r\n   *\r\n   * @param title The `pageTitle` from the deepest primary route.\r\n   */\n  updateTitle(snapshot) {\n    const title = this.buildTitle(snapshot);\n    if (title !== undefined) {\n      this.title.setTitle(title);\n    }\n  }\n  static ɵfac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || DefaultTitleStrategy)(i0.ɵɵinject(i1.Title));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultTitleStrategy,\n    factory: DefaultTitleStrategy.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultTitleStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i1.Title\n  }], null);\n})();\n\n/**\r\n * A DI token for the router service.\r\n *\r\n * @publicApi\r\n */\nconst ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\n  providedIn: 'root',\n  factory: () => ({})\n});\n\n/**\r\n * The DI token for a router configuration.\r\n *\r\n * `ROUTES` is a low level API for router configuration via dependency injection.\r\n *\r\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\r\n * `provideRouter`, or `Router.resetConfig()`.\r\n *\r\n * @publicApi\r\n */\nconst ROUTES = new InjectionToken(ngDevMode ? 'ROUTES' : '');\nclass RouterConfigLoader {\n  componentLoaders = new WeakMap();\n  childrenLoaders = new WeakMap();\n  onLoadStartListener;\n  onLoadEndListener;\n  compiler = inject(Compiler);\n  loadComponent(route) {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route);\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(map(maybeUnwrapDefaultExport), tap(component => {\n      if (this.onLoadEndListener) {\n        this.onLoadEndListener(route);\n      }\n      (typeof ngDevMode === 'undefined' || ngDevMode) && assertStandalone(route.path ?? '', component);\n      route._loadedComponent = component;\n    }), finalize(() => {\n      this.componentLoaders.delete(route);\n    }));\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n  loadChildren(parentInjector, route) {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route);\n    } else if (route._loadedRoutes) {\n      return of({\n        routes: route._loadedRoutes,\n        injector: route._loadedInjector\n      });\n    }\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n    const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {\n      this.childrenLoaders.delete(route);\n    }));\n    // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n  static ɵfac = function RouterConfigLoader_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || RouterConfigLoader)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterConfigLoader,\n    factory: RouterConfigLoader.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouterConfigLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\r\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\r\n * an injector if that callback returned a module.\r\n *\r\n * This function is used for the route discovery during prerendering\r\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\r\n * an update to the extractor.\r\n */\nfunction loadChildren(route, compiler, parentInjector, onLoadEndListener) {\n  return wrapIntoObservable(route.loadChildren()).pipe(map(maybeUnwrapDefaultExport), mergeMap(t => {\n    if (t instanceof NgModuleFactory || Array.isArray(t)) {\n      return of(t);\n    } else {\n      return from(compiler.compileModuleAsync(t));\n    }\n  }), map(factoryOrRoutes => {\n    if (onLoadEndListener) {\n      onLoadEndListener(route);\n    }\n    // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n    // no injector associated with lazy loading a `Route` array.\n    let injector;\n    let rawRoutes;\n    let requireStandaloneComponents = false;\n    if (Array.isArray(factoryOrRoutes)) {\n      rawRoutes = factoryOrRoutes;\n      requireStandaloneComponents = true;\n    } else {\n      injector = factoryOrRoutes.create(parentInjector).injector;\n      // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n      // will get stuck in an infinite loop. The child module's Injector will look to\n      // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n      // for it's parent module instead.\n      rawRoutes = injector.get(ROUTES, [], {\n        optional: true,\n        self: true\n      }).flat();\n    }\n    const routes = rawRoutes.map(standardizeConfig);\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(routes, route.path, requireStandaloneComponents);\n    return {\n      routes,\n      injector\n    };\n  }));\n}\nfunction isWrappedDefaultExport(value) {\n  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n  // `default` will be a renamed property.\n  return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n  // subject to property renaming, so we reference it with bracket access.\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\n\n/**\r\n * @description\r\n *\r\n * Provides a way to migrate AngularJS applications to Angular.\r\n *\r\n * @publicApi\r\n */\nclass UrlHandlingStrategy {\n  static ɵfac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || UrlHandlingStrategy)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlHandlingStrategy,\n    factory: () => (() => inject(DefaultUrlHandlingStrategy))(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlHandlingStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => inject(DefaultUrlHandlingStrategy)\n    }]\n  }], null, null);\n})();\n/**\r\n * @publicApi\r\n */\nclass DefaultUrlHandlingStrategy {\n  shouldProcessUrl(url) {\n    return true;\n  }\n  extract(url) {\n    return url;\n  }\n  merge(newUrlPart, wholeUrl) {\n    return newUrlPart;\n  }\n  static ɵfac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || DefaultUrlHandlingStrategy)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultUrlHandlingStrategy,\n    factory: DefaultUrlHandlingStrategy.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultUrlHandlingStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/// <reference types=\"dom-view-transitions\" />\nconst CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? 'view transition helper' : '');\nconst VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? 'view transition options' : '');\n/**\r\n * A helper function for using browser view transitions. This function skips the call to\r\n * `startViewTransition` if the browser does not support it.\r\n *\r\n * @returns A Promise that resolves when the view transition callback begins.\r\n */\nfunction createViewTransition(injector, from, to) {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  // Create promises outside the Angular zone to avoid causing extra change detections\n  return injector.get(NgZone).runOutsideAngular(() => {\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n      transitionOptions.skipNextTransition = false;\n      // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n      // until the current event loop exits so we use a promise resolved in a timeout instead\n      // of Promise.resolve().\n      return new Promise(resolve => setTimeout(resolve));\n    }\n    let resolveViewTransitionStarted;\n    const viewTransitionStarted = new Promise(resolve => {\n      resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n      resolveViewTransitionStarted();\n      // We don't actually update dom within the transition callback. The resolving of the above\n      // promise unblocks the Router navigation, which synchronously activates and deactivates\n      // routes (the DOM update). This view transition waits for the next change detection to\n      // complete (below), which includes the update phase of the routed components.\n      return createRenderPromise(injector);\n      // TODO(atscott): Types in DefinitelyTyped are not up-to-date\n    });\n    const {\n      onViewTransitionCreated\n    } = transitionOptions;\n    if (onViewTransitionCreated) {\n      runInInjectionContext(injector, () => onViewTransitionCreated({\n        transition,\n        from,\n        to\n      }));\n    }\n    return viewTransitionStarted;\n  });\n}\n/**\r\n * Creates a promise that resolves after next render.\r\n */\nfunction createRenderPromise(injector) {\n  return new Promise(resolve => {\n    // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n    // This ensures any follow-up renders in the microtask queue are completed before the\n    // view transition starts animating.\n    afterNextRender({\n      read: () => setTimeout(resolve)\n    }, {\n      injector\n    });\n  });\n}\nconst NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\nclass NavigationTransitions {\n  currentNavigation = null;\n  currentTransition = null;\n  lastSuccessfulNavigation = null;\n  /**\r\n   * These events are used to communicate back to the Router about the state of the transition. The\r\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\r\n   * class is not public, this event subject is not publicly exposed.\r\n   */\n  events = new Subject();\n  /**\r\n   * Used to abort the current transition with an error.\r\n   */\n  transitionAbortSubject = new Subject();\n  configLoader = inject(RouterConfigLoader);\n  environmentInjector = inject(EnvironmentInjector);\n  destroyRef = inject(DestroyRef);\n  urlSerializer = inject(UrlSerializer);\n  rootContexts = inject(ChildrenOutletContexts);\n  location = inject(Location);\n  inputBindingEnabled = inject(INPUT_BINDER, {\n    optional: true\n  }) !== null;\n  titleStrategy = inject(TitleStrategy);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  createViewTransition = inject(CREATE_VIEW_TRANSITION, {\n    optional: true\n  });\n  navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {\n    optional: true\n  });\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  transitions;\n  /**\r\n   * Hook that enables you to pause navigation after the preactivation phase.\r\n   * Used by `RouterModule`.\r\n   *\r\n   * @internal\r\n   */\n  afterPreactivation = () => of(void 0);\n  /** @internal */\n  rootComponentType = null;\n  destroyed = false;\n  constructor() {\n    const onLoadStart = r => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = r => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  complete() {\n    this.transitions?.complete();\n  }\n  handleNavigationRequest(request) {\n    const id = ++this.navigationId;\n    this.transitions?.next({\n      ...request,\n      extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n      targetSnapshot: null,\n      targetRouterState: null,\n      guards: {\n        canActivateChecks: [],\n        canDeactivateChecks: []\n      },\n      guardsResult: null,\n      id\n    });\n  }\n  setupNavigations(router) {\n    this.transitions = new BehaviorSubject(null);\n    return this.transitions.pipe(filter(t => t !== null),\n    // Using switchMap so we cancel executing navigations when a new one comes in\n    switchMap(overallTransitionState => {\n      let completed = false;\n      let errored = false;\n      return of(overallTransitionState).pipe(switchMap(t => {\n        // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n        // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n        // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n        // https://github.com/ReactiveX/rxjs/issues/7455\n        if (this.navigationId > overallTransitionState.id) {\n          const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n          this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n          return EMPTY;\n        }\n        this.currentTransition = overallTransitionState;\n        // Store the Navigation object\n        this.currentNavigation = {\n          id: t.id,\n          initialUrl: t.rawUrl,\n          extractedUrl: t.extractedUrl,\n          targetBrowserUrl: typeof t.extras.browserUrl === 'string' ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,\n          trigger: t.source,\n          extras: t.extras,\n          previousNavigation: !this.lastSuccessfulNavigation ? null : {\n            ...this.lastSuccessfulNavigation,\n            previousNavigation: null\n          }\n        };\n        const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n        const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n        if (!urlTransition && onSameUrlNavigation !== 'reload') {\n          const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : '';\n          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n          t.resolve(false);\n          return EMPTY;\n        }\n        if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n          return of(t).pipe(\n          // Fire NavigationStart event\n          switchMap(t => {\n            this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\n            if (t.id !== this.navigationId) {\n              return EMPTY;\n            }\n            // This delay is required to match old behavior that forced\n            // navigation to always be async\n            return Promise.resolve(t);\n          }),\n          // Recognize\n          recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),\n          // Update URL if in `eager` update mode\n          tap(t => {\n            overallTransitionState.targetSnapshot = t.targetSnapshot;\n            overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n            this.currentNavigation = {\n              ...this.currentNavigation,\n              finalUrl: t.urlAfterRedirects\n            };\n            // Fire RoutesRecognized\n            const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n            this.events.next(routesRecognized);\n          }));\n        } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n          /* When the current URL shouldn't be processed, but the previous one\r\n           * was, we handle this \"error condition\" by navigating to the\r\n           * previously successful URL, but leaving the URL intact.*/\n          const {\n            id,\n            extractedUrl,\n            source,\n            restoredState,\n            extras\n          } = t;\n          const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n          this.events.next(navStart);\n          const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n          this.currentTransition = overallTransitionState = {\n            ...t,\n            targetSnapshot,\n            urlAfterRedirects: extractedUrl,\n            extras: {\n              ...extras,\n              skipLocationChange: false,\n              replaceUrl: false\n            }\n          };\n          this.currentNavigation.finalUrl = extractedUrl;\n          return of(overallTransitionState);\n        } else {\n          /* When neither the current or previous URL can be processed, do\r\n           * nothing other than update router's internal reference to the\r\n           * current \"settled\" URL. This way the next navigation will be coming\r\n           * from the current URL in the browser.\r\n           */\n          const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy` + ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : '';\n          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n          t.resolve(false);\n          return EMPTY;\n        }\n      }),\n      // --- GUARDS ---\n      tap(t => {\n        const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n        this.events.next(guardsStart);\n      }), map(t => {\n        this.currentTransition = overallTransitionState = {\n          ...t,\n          guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)\n        };\n        return overallTransitionState;\n      }), checkGuards(this.environmentInjector, evt => this.events.next(evt)), tap(t => {\n        overallTransitionState.guardsResult = t.guardsResult;\n        if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n          throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n        }\n        const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n        this.events.next(guardsEnd);\n      }), filter(t => {\n        if (!t.guardsResult) {\n          this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n          return false;\n        }\n        return true;\n      }),\n      // --- RESOLVE ---\n      switchTap(t => {\n        if (t.guards.canActivateChecks.length === 0) {\n          return undefined;\n        }\n        return of(t).pipe(tap(t => {\n          const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n          this.events.next(resolveStart);\n        }), switchMap(t => {\n          let dataResolved = false;\n          return of(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\n            next: () => dataResolved = true,\n            complete: () => {\n              if (!dataResolved) {\n                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode ? `At least one route resolver didn't emit any value.` : '', NavigationCancellationCode.NoDataFromResolver);\n              }\n            }\n          }));\n        }), tap(t => {\n          const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n          this.events.next(resolveEnd);\n        }));\n      }),\n      // --- LOAD COMPONENTS ---\n      switchTap(t => {\n        const loadComponents = route => {\n          const loaders = [];\n          if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\n            loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap(loadedComponent => {\n              route.component = loadedComponent;\n            }), map(() => void 0)));\n          }\n          for (const child of route.children) {\n            loaders.push(...loadComponents(child));\n          }\n          return loaders;\n        };\n        return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));\n      }), switchTap(() => this.afterPreactivation()), switchMap(() => {\n        const {\n          currentSnapshot,\n          targetSnapshot\n        } = overallTransitionState;\n        const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n        // If view transitions are enabled, block the navigation until the view\n        // transition callback starts. Otherwise, continue immediately.\n        return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);\n      }), map(t => {\n        const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n        this.currentTransition = overallTransitionState = {\n          ...t,\n          targetRouterState\n        };\n        this.currentNavigation.targetRouterState = targetRouterState;\n        return overallTransitionState;\n      }), tap(() => {\n        this.events.next(new BeforeActivateRoutes());\n      }), activateRoutes(this.rootContexts, router.routeReuseStrategy, evt => this.events.next(evt), this.inputBindingEnabled),\n      // Ensure that if some observable used to drive the transition doesn't\n      // complete, the navigation still finalizes This should never happen, but\n      // this is done as a safety measure to avoid surfacing this error (#49567).\n      take(1), tap({\n        next: t => {\n          completed = true;\n          this.lastSuccessfulNavigation = this.currentNavigation;\n          this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n          this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n          t.resolve(true);\n        },\n        complete: () => {\n          completed = true;\n        }\n      }),\n      // There used to be a lot more logic happening directly within the\n      // transition Observable. Some of this logic has been refactored out to\n      // other places but there may still be errors that happen there. This gives\n      // us a way to cancel the transition from the outside. This may also be\n      // required in the future to support something like the abort signal of the\n      // Navigation API where the navigation gets aborted from outside the\n      // transition.\n      takeUntil(this.transitionAbortSubject.pipe(tap(err => {\n        throw err;\n      }))), finalize(() => {\n        /* When the navigation stream finishes either through error or success,\r\n         * we set the `completed` or `errored` flag. However, there are some\r\n         * situations where we could get here without either of those being set.\r\n         * For instance, a redirect during NavigationStart. Therefore, this is a\r\n         * catch-all to make sure the NavigationCancel event is fired when a\r\n         * navigation gets cancelled but not caught by other means. */\n        if (!completed && !errored) {\n          const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n          this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n        }\n        // Only clear current navigation if it is still set to the one that\n        // finalized.\n        if (this.currentTransition?.id === overallTransitionState.id) {\n          this.currentNavigation = null;\n          this.currentTransition = null;\n        }\n      }), catchError(e => {\n        // If the application is already destroyed, the catch block should not\n        // execute anything in practice because other resources have already\n        // been released and destroyed.\n        if (this.destroyed) {\n          overallTransitionState.resolve(false);\n          return EMPTY;\n        }\n        errored = true;\n        /* This error type is issued during Redirect, and is handled as a\r\n         * cancellation rather than an error. */\n        if (isNavigationCancelingError(e)) {\n          this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n          // When redirecting, we need to delay resolving the navigation\n          // promise and push it to the redirect navigation\n          if (!isRedirectingNavigationCancelingError(e)) {\n            overallTransitionState.resolve(false);\n          } else {\n            this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n          }\n          /* All other errors should reset to the router's internal URL reference\r\n           * to the pre-error state. */\n        } else {\n          const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\n          try {\n            const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n            if (navigationErrorHandlerResult instanceof RedirectCommand) {\n              const {\n                message,\n                cancellationCode\n              } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n              this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n            } else {\n              this.events.next(navigationError);\n              throw e;\n            }\n          } catch (ee) {\n            // TODO(atscott): consider flipping the default behavior of\n            // resolveNavigationPromiseOnError to be `resolve(false)` when\n            // undefined. This is the most sane thing to do given that\n            // applications very rarely handle the promise rejection and, as a\n            // result, would get \"unhandled promise rejection\" console logs.\n            // The vast majority of applications would not be affected by this\n            // change so omitting a migration seems reasonable. Instead,\n            // applications that rely on rejection can specifically opt-in to the\n            // old behavior.\n            if (this.options.resolveNavigationPromiseOnError) {\n              overallTransitionState.resolve(false);\n            } else {\n              overallTransitionState.reject(ee);\n            }\n          }\n        }\n        return EMPTY;\n      }));\n      // casting because `pipe` returns observable({}) when called with 8+ arguments\n    }));\n  }\n  cancelNavigationTransition(t, reason, code) {\n    const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n  /**\r\n   * @returns Whether we're navigating to somewhere that is not what the Router is\r\n   * currently set to.\r\n   */\n  isUpdatingInternalState() {\n    // TODO(atscott): The serializer should likely be used instead of\n    // `UrlTree.toString()`. Custom serializers are often written to handle\n    // things better than the default one (objects, for example will be\n    // [Object object] with the custom serializer and be \"the same\" when they\n    // aren't).\n    // (Same for isUpdatedBrowserUrl)\n    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();\n  }\n  /**\r\n   * @returns Whether we're updating the browser URL to something new (navigation is going\r\n   * to somewhere not displayed in the URL bar and we will update the URL\r\n   * bar if navigation succeeds).\r\n   */\n  isUpdatedBrowserUrl() {\n    // The extracted URL is the part of the URL that this application cares about. `extract` may\n    // return only part of the browser URL and that part may have not changed even if some other\n    // portion of the URL did.\n    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n    const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\n    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !this.currentNavigation?.extras.skipLocationChange;\n  }\n  static ɵfac = function NavigationTransitions_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || NavigationTransitions)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationTransitions,\n    factory: NavigationTransitions.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NavigationTransitions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nfunction isBrowserTriggeredNavigation(source) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\n\n/**\r\n * @description\r\n *\r\n * Provides a way to customize when activated routes get reused.\r\n *\r\n * @publicApi\r\n */\nclass RouteReuseStrategy {\n  static ɵfac = function RouteReuseStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || RouteReuseStrategy)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouteReuseStrategy,\n    factory: () => (() => inject(DefaultRouteReuseStrategy))(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RouteReuseStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => inject(DefaultRouteReuseStrategy)\n    }]\n  }], null, null);\n})();\n/**\r\n * @description\r\n *\r\n * This base route reuse strategy only reuses routes when the matched router configs are\r\n * identical. This prevents components from being destroyed and recreated\r\n * when just the route parameters, query parameters or fragment change\r\n * (that is, the existing component is _reused_).\r\n *\r\n * This strategy does not store any routes for later reuse.\r\n *\r\n * Angular uses this strategy by default.\r\n *\r\n *\r\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\r\n * class that extends the `BaseRouteReuseStrategy` one.\r\n * @publicApi\r\n */\nclass BaseRouteReuseStrategy {\n  /**\r\n   * Whether the given route should detach for later reuse.\r\n   * Always returns false for `BaseRouteReuseStrategy`.\r\n   * */\n  shouldDetach(route) {\n    return false;\n  }\n  /**\r\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\r\n   */\n  store(route, detachedTree) {}\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route) {\n    return false;\n  }\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route) {\n    return null;\n  }\n  /**\r\n   * Determines if a route should be reused.\r\n   * This strategy returns `true` when the future route config and current route config are\r\n   * identical.\r\n   */\n  shouldReuseRoute(future, curr) {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\nclass DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n  static ɵfac = /* @__PURE__ */(() => {\n    let ɵDefaultRouteReuseStrategy_BaseFactory;\n    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {\n      return (ɵDefaultRouteReuseStrategy_BaseFactory || (ɵDefaultRouteReuseStrategy_BaseFactory = i0.ɵɵgetInheritedFactory(DefaultRouteReuseStrategy)))(__ngFactoryType__ || DefaultRouteReuseStrategy);\n    };\n  })();\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultRouteReuseStrategy,\n    factory: DefaultRouteReuseStrategy.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultRouteReuseStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nclass StateManager {\n  urlSerializer = inject(UrlSerializer);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\n  location = inject(Location);\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  currentUrlTree = new UrlTree();\n  /**\r\n   * Returns the currently activated `UrlTree`.\r\n   *\r\n   * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\r\n   * `UrlHandlingStrategy`).\r\n   *\r\n   * The value is set after finding the route config tree to activate but before activating the\r\n   * route.\r\n   */\n  getCurrentUrlTree() {\n    return this.currentUrlTree;\n  }\n  rawUrlTree = this.currentUrlTree;\n  /**\r\n   * Returns a `UrlTree` that is represents what the browser is actually showing.\r\n   *\r\n   * In the life of a navigation transition:\r\n   * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\r\n   * navigated to.\r\n   * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\r\n   * to `UrlHandlingStrategy`).\r\n   * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\r\n   * original raw URL.\r\n   *\r\n   * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\r\n   * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\r\n   * deviated from the raw `UrlTree`.\r\n   *\r\n   * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\r\n   * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\r\n   * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\r\n   * occurs, it needs to know the _whole_ browser URL, not just the part handled by\r\n   * `UrlHandlingStrategy`.\r\n   * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\r\n   * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\r\n   * location change listener due to a URL update by the AngularJS router. In this case, the router\r\n   * still need to know what the browser's URL is for future navigations.\r\n   */\n  getRawUrlTree() {\n    return this.rawUrlTree;\n  }\n  createBrowserPath({\n    finalUrl,\n    initialUrl,\n    targetBrowserUrl\n  }) {\n    const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\n    const url = targetBrowserUrl ?? rawUrl;\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    return path;\n  }\n  commitTransition({\n    targetRouterState,\n    finalUrl,\n    initialUrl\n  }) {\n    // If we are committing the transition after having a final URL and target state, we're updating\n    // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n    // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n    if (finalUrl && targetRouterState) {\n      this.currentUrlTree = finalUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n      this.routerState = targetRouterState;\n    } else {\n      this.rawUrlTree = initialUrl;\n    }\n  }\n  routerState = createEmptyState(null);\n  /** Returns the current RouterState. */\n  getRouterState() {\n    return this.routerState;\n  }\n  stateMemento = this.createStateMemento();\n  updateStateMemento() {\n    this.stateMemento = this.createStateMemento();\n  }\n  createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState\n    };\n  }\n  resetInternalState({\n    finalUrl\n  }) {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n    // configured to handle only part of the navigation URL. This means we would only want to reset\n    // the part of the navigation handled by the Angular router rather than the whole URL. In\n    // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n    // when merging, such as the query params so they are not lost on a refresh.\n    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n  }\n  static ɵfac = function StateManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || StateManager)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateManager,\n    factory: () => (() => inject(HistoryStateManager))(),\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => inject(HistoryStateManager)\n    }]\n  }], null, null);\n})();\nclass HistoryStateManager extends StateManager {\n  /**\r\n   * The id of the currently active page in the router.\r\n   * Updated to the transition's target id on a successful navigation.\r\n   *\r\n   * This is used to track what page the router last activated. When an attempted navigation fails,\r\n   * the router can then use this to compute how to restore the state back to the previously active\r\n   * page.\r\n   */\n  currentPageId = 0;\n  lastSuccessfulId = -1;\n  restoredState() {\n    return this.location.getState();\n  }\n  /**\r\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\r\n   * important for computing the target page id for new navigations because we need to ensure each\r\n   * page id in the browser history is 1 more than the previous entry.\r\n   */\n  get browserPageId() {\n    if (this.canceledNavigationResolution !== 'computed') {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n  }\n  registerNonRouterCurrentEntryChangeListener(listener) {\n    return this.location.subscribe(event => {\n      if (event['type'] === 'popstate') {\n        // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n        // hybrid apps.\n        setTimeout(() => {\n          listener(event['url'], event.state, 'popstate');\n        });\n      }\n    });\n  }\n  handleRouterEvent(e, currentTransition) {\n    if (e instanceof NavigationStart) {\n      this.updateStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.commitTransition(currentTransition);\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === 'eager') {\n        if (!currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.commitTransition(currentTransition);\n      if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n      }\n    } else if (e instanceof NavigationCancel && (e.code === NavigationCancellationCode.GuardRejected || e.code === NavigationCancellationCode.NoDataFromResolver)) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n  setBrowserUrl(path, {\n    extras,\n    id\n  }) {\n    const {\n      replaceUrl,\n      state\n    } = extras;\n    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n      // replacements do not update the target page\n      const currentBrowserPageId = this.browserPageId;\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, currentBrowserPageId)\n      };\n      this.location.replaceState(path, '', newState);\n    } else {\n      const newState = {\n        ...state,\n        ...this.generateNgRouterState(id, this.browserPageId + 1)\n      };\n      this.location.go(path, '', newState);\n    }\n  }\n  /**\r\n   * Performs the necessary rollback action to restore the browser URL to the\r\n   * state before the transition.\r\n   */\n  restoreHistory(navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === 'computed') {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n        // We got to the activation stage (where currentUrlTree is set to the navigation's\n        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n        // We still need to reset the router state back to what it was when the navigation started.\n        this.resetInternalState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else ;\n    } else if (this.canceledNavigationResolution === 'replace') {\n      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n      // for `deferred` navigations that haven't change the internal state yet because guards\n      // reject. For 'eager' navigations, it seems like we also really should reset the state\n      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n      if (restoringFromCaughtError) {\n        this.resetInternalState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n  resetUrlToCurrentUrlTree() {\n    this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n  }\n  generateNgRouterState(navigationId, routerPageId) {\n    if (this.canceledNavigationResolution === 'computed') {\n      return {\n        navigationId,\n        ɵrouterPageId: routerPageId\n      };\n    }\n    return {\n      navigationId\n    };\n  }\n  static ɵfac = /* @__PURE__ */(() => {\n    let ɵHistoryStateManager_BaseFactory;\n    return function HistoryStateManager_Factory(__ngFactoryType__) {\n      return (ɵHistoryStateManager_BaseFactory || (ɵHistoryStateManager_BaseFactory = i0.ɵɵgetInheritedFactory(HistoryStateManager)))(__ngFactoryType__ || HistoryStateManager);\n    };\n  })();\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HistoryStateManager,\n    factory: HistoryStateManager.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\r\n * Performs the given action once the router finishes its next/current navigation.\r\n *\r\n * The navigation is considered complete under the following conditions:\r\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\r\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\r\n * redirecting/superseding navigation must finish.\r\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\r\n */\nfunction afterNextNavigation(router, action) {\n  router.events.pipe(filter(e => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map(e => {\n    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n      return 0 /* NavigationResult.COMPLETE */;\n    }\n    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;\n    return redirecting ? 2 /* NavigationResult.REDIRECTING */ : 1 /* NavigationResult.FAILED */;\n  }), filter(result => result !== 2 /* NavigationResult.REDIRECTING */), take(1)).subscribe(() => {\n    action();\n  });\n}\n\n/**\r\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\r\n * (exact = true).\r\n */\nconst exactMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\n/**\r\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\r\n * (exact = false).\r\n */\nconst subsetMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\n/**\r\n * @description\r\n *\r\n * A service that facilitates navigation among views and URL manipulation capabilities.\r\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\r\n *\r\n * @see {@link Route}\r\n * @see {@link provideRouter}\r\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\nclass Router {\n  get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  disposed = false;\n  nonRouterCurrentEntryChangeSubscription;\n  console = inject(_Console);\n  stateManager = inject(StateManager);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  pendingTasks = inject(_PendingTasksInternal);\n  urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n  navigationTransitions = inject(NavigationTransitions);\n  urlSerializer = inject(UrlSerializer);\n  location = inject(Location);\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  /**\r\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\r\n   * to push events to. The separate field allows us to expose separate types in the public API\r\n   * (i.e., an Observable rather than the Subject).\r\n   */\n  _events = new Subject();\n  /**\r\n   * An event stream for routing events.\r\n   */\n  get events() {\n    // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n    // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n    // allowed/supported but we still have to fix these or file bugs against the teams before making\n    // the change.\n    return this._events;\n  }\n  /**\r\n   * The current state of routing in this NgModule.\r\n   */\n  get routerState() {\n    return this.stateManager.getRouterState();\n  }\n  /**\r\n   * True if at least one navigation event has occurred,\r\n   * false otherwise.\r\n   */\n  navigated = false;\n  /**\r\n   * A strategy for re-using routes.\r\n   *\r\n   * @deprecated Configure using `providers` instead:\r\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\r\n   */\n  routeReuseStrategy = inject(RouteReuseStrategy);\n  /**\r\n   * How to handle a navigation request to the current URL.\r\n   *\r\n   *\r\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\r\n   * @see {@link withRouterConfig}\r\n   * @see {@link provideRouter}\r\n   * @see {@link RouterModule}\r\n   */\n  onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n  config = inject(ROUTES, {\n    optional: true\n  })?.flat() ?? [];\n  /**\r\n   * Indicates whether the application has opted in to binding Router data to component inputs.\r\n   *\r\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\r\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\r\n   */\n  componentInputBindingEnabled = !!inject(INPUT_BINDER, {\n    optional: true\n  });\n  constructor() {\n    this.resetConfig(this.config);\n    this.navigationTransitions.setupNavigations(this).subscribe({\n      error: e => {\n        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n      }\n    });\n    this.subscribeToNavigationEvents();\n  }\n  eventsSubscription = new Subscription();\n  subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe(e => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = this.navigationTransitions.currentNavigation;\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n            // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n            // however it's how things were written initially. Investigation would need to be done\n            // to determine if this can be removed.\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const opts = e.navigationBehaviorOptions;\n            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n            const extras = {\n              browserUrl: currentTransition.extras.browserUrl,\n              info: currentTransition.extras.info,\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === 'eager' || isBrowserTriggeredNavigation(currentTransition.source),\n              // allow developer to override default options with RedirectCommand\n              ...opts\n            };\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise\n            });\n          }\n        }\n        // Note that it's important to have the Router process the events _before_ the event is\n        // pushed through the public observable. This ensures the correct router state is in place\n        // before applications observe the events.\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e) {\n        this.navigationTransitions.transitionAbortSubject.next(e);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n  /** @internal */\n  resetRootComponentType(rootComponentType) {\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n  /**\r\n   * Sets up the location change listener and performs the initial navigation.\r\n   */\n  initialNavigation() {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n    }\n  }\n  /**\r\n   * Sets up the location change listener. This listener detects navigations triggered from outside\r\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\r\n   * navigation so that the correct events, guards, etc. are triggered.\r\n   */\n  setUpLocationChangeListener() {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n      this.navigateToSyncWithBrowser(url, source, state);\n    });\n  }\n  /**\r\n   * Schedules a router navigation to synchronize Router state with the browser state.\r\n   *\r\n   * This is done as a response to a popstate event and the initial navigation. These\r\n   * two scenarios represent times when the browser URL/state has been updated and\r\n   * the Router needs to respond to ensure its internal state matches.\r\n   */\n  navigateToSyncWithBrowser(url, source, state) {\n    const extras = {\n      replaceUrl: true\n    };\n    // TODO: restoredState should always include the entire state, regardless\n    // of navigationId. This requires a breaking change to update the type on\n    // NavigationStart’s restoredState, which currently requires navigationId\n    // to always be present. The Router used to only restore history state if\n    // a navigationId was present.\n    // The stored navigationId is used by the RouterScroller to retrieve the scroll\n    // position for the page.\n    const restoredState = state?.navigationId ? state : null;\n    // Separate to NavigationStart.restoredState, we must also restore the state to\n    // history.state and generate a new navigationId, since it will be overwritten\n    if (state) {\n      const stateCopy = {\n        ...state\n      };\n      delete stateCopy.navigationId;\n      delete stateCopy.ɵrouterPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras);\n  }\n  /** The current URL. */\n  get url() {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n  /**\r\n   * Returns the current `Navigation` object when the router is navigating,\r\n   * and `null` when idle.\r\n   */\n  getCurrentNavigation() {\n    return this.navigationTransitions.currentNavigation;\n  }\n  /**\r\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\r\n   *     has not been a successful navigation yet.\r\n   */\n  get lastSuccessfulNavigation() {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n  /**\r\n   * Resets the route configuration used for navigation and generating links.\r\n   *\r\n   * @param config The route array for the new configuration.\r\n   *\r\n   * @usageNotes\r\n   *\r\n   * ```ts\r\n   * router.resetConfig([\r\n   *  { path: 'team/:id', component: TeamCmp, children: [\r\n   *    { path: 'simple', component: SimpleCmp },\r\n   *    { path: 'user/:name', component: UserCmp }\r\n   *  ]}\r\n   * ]);\r\n   * ```\r\n   */\n  resetConfig(config) {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n  }\n  /** @docs-private */\n  ngOnDestroy() {\n    this.dispose();\n  }\n  /** Disposes of the router. */\n  dispose() {\n    // We call `unsubscribe()` to release observers, as users may forget to\n    // unsubscribe manually when subscribing to `router.events`. We do not call\n    // `complete()` because it is unsafe; if someone subscribes using the `first`\n    // operator and the observable completes before emitting a value,\n    // RxJS will throw an error.\n    this._events.unsubscribe();\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = undefined;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n  /**\r\n   * Appends URL segments to the current URL tree to create a new URL tree.\r\n   *\r\n   * @param commands An array of URL fragments with which to construct the new URL tree.\r\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n   * segments, followed by the parameters for each segment.\r\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\r\n   * property of the options object, if supplied.\r\n   * @param navigationExtras Options that control the navigation strategy.\r\n   * @returns The new URL tree.\r\n   *\r\n   * @usageNotes\r\n   *\r\n   * ```\r\n   * // create /team/33/user/11\r\n   * router.createUrlTree(['/team', 33, 'user', 11]);\r\n   *\r\n   * // create /team/33;expand=true/user/11\r\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\r\n   *\r\n   * // you can collapse static segments like this (this works only with the first passed-in value):\r\n   * router.createUrlTree(['/team/33/user', userId]);\r\n   *\r\n   * // If the first segment can contain slashes, and you do not want the router to split it,\r\n   * // you can do the following:\r\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\r\n   *\r\n   * // create /team/33/(user/11//right:chat)\r\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\r\n   *\r\n   * // remove the right secondary node\r\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\r\n   *\r\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\r\n   *\r\n   * // navigate to /team/33/user/11/details\r\n   * router.createUrlTree(['details'], {relativeTo: route});\r\n   *\r\n   * // navigate to /team/33/user/22\r\n   * router.createUrlTree(['../22'], {relativeTo: route});\r\n   *\r\n   * // navigate to /team/44/user/22\r\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\r\n   *\r\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\r\n   * tree should be created relative to the root.\r\n   * ```\r\n   */\n  createUrlTree(commands, navigationExtras = {}) {\n    const {\n      relativeTo,\n      queryParams,\n      fragment,\n      queryParamsHandling,\n      preserveFragment\n    } = navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q = null;\n    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n      case 'merge':\n        q = {\n          ...this.currentUrlTree.queryParams,\n          ...queryParams\n        };\n        break;\n      case 'preserve':\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n    let relativeToUrlSegmentGroup;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e) {\n      // This is strictly for backwards compatibility with tests that create\n      // invalid `ActivatedRoute` mocks.\n      // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n      // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n      // the moment.\n      if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n        // Navigations that were absolute in the old way of creating UrlTrees\n        // would still work because they wouldn't attempt to match the\n        // segments in the `ActivatedRoute` to the `currentUrlTree` but\n        // instead just replace the root segment with the navigation result.\n        // Non-absolute navigations would fail to apply the commands because\n        // the logic could not find the segment to replace (so they'd act like there were no\n        // commands).\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n  }\n  /**\r\n   * Navigates to a view using an absolute route path.\r\n   *\r\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\r\n   *     current URL.\r\n   * @param extras An object containing properties that modify the navigation strategy.\r\n   *\r\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\r\n   * to 'false' when navigation fails, or is rejected on error.\r\n   *\r\n   * @usageNotes\r\n   *\r\n   * The following calls request navigation to an absolute path.\r\n   *\r\n   * ```ts\r\n   * router.navigateByUrl(\"/team/33/user/11\");\r\n   *\r\n   * // Navigate without updating the URL\r\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\r\n   * ```\r\n   *\r\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\r\n   *\r\n   */\n  navigateByUrl(url, extras = {\n    skipLocationChange: false\n  }) {\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n  /**\r\n   * Navigate based on the provided array of commands and a starting point.\r\n   * If no starting route is provided, the navigation is absolute.\r\n   *\r\n   * @param commands An array of URL fragments with which to construct the target URL.\r\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n   * segments, followed by the parameters for each segment.\r\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\r\n   * of the options object, if supplied.\r\n   * @param extras An options object that determines how the URL should be constructed or\r\n   *     interpreted.\r\n   *\r\n   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\r\n   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\r\n   * not `true`.\r\n   *\r\n   * @usageNotes\r\n   *\r\n   * The following calls request navigation to a dynamic route path relative to the current URL.\r\n   *\r\n   * ```ts\r\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\r\n   *\r\n   * // Navigate without updating the URL, overriding the default behavior\r\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\r\n   * ```\r\n   *\r\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\r\n   *\r\n   */\n  navigate(commands, extras = {\n    skipLocationChange: false\n  }) {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url) {\n    return this.urlSerializer.serialize(url);\n  }\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url) {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch {\n      return this.urlSerializer.parse('/');\n    }\n  }\n  isActive(url, matchOptions) {\n    let options;\n    if (matchOptions === true) {\n      options = {\n        ...exactMatchOptions\n      };\n    } else if (matchOptions === false) {\n      options = {\n        ...subsetMatchOptions\n      };\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n  removeEmptyProps(params) {\n    return Object.entries(params).reduce((result, [key, value]) => {\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n    let resolve;\n    let reject;\n    let promise;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n    // Indicate that the navigation is happening.\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      // Remove pending task in a microtask to allow for cancelled\n      // initial navigations and redirects within the same task.\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve: resolve,\n      reject: reject,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState\n    });\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch(e => {\n      return Promise.reject(e);\n    });\n  }\n  static ɵfac = function Router_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || Router)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Router,\n    factory: Router.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Router, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nfunction validateCommands(commands) {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new _RuntimeError(4008 /* RuntimeErrorCode.NULLISH_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\nfunction isPublicRouterEvent(e) {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, isUrlTree, loadChildren, stringifyEvent, ɵEmptyOutletComponent };","map":{"version":3,"names":["DOCUMENT","Location","i0","ɵisPromise","_isPromise","ɵRuntimeError","_RuntimeError","Injectable","ɵisNgModule","_isNgModule","isStandalone","createEnvironmentInjector","InjectionToken","EventEmitter","input","inject","ViewContainerRef","ChangeDetectorRef","Output","Input","Directive","reflectComponentType","Component","ɵisInjectable","_isInjectable","runInInjectionContext","NgModuleFactory","Compiler","NgZone","afterNextRender","EnvironmentInjector","DestroyRef","ɵConsole","_Console","ɵPendingTasksInternal","_PendingTasksInternal","isObservable","from","of","BehaviorSubject","combineLatest","EmptyError","concat","defer","pipe","throwError","EMPTY","ConnectableObservable","Subject","Subscription","map","switchMap","take","startWith","filter","mergeMap","first","concatMap","tap","catchError","scan","defaultIfEmpty","last","last$1","takeLast","finalize","refCount","takeUntil","i1","PRIMARY_OUTLET","RouteTitleKey","Symbol","ParamsAsMap","params","constructor","has","name","Object","prototype","hasOwnProperty","call","get","v","Array","isArray","getAll","keys","convertToParamMap","defaultUrlMatcher","segments","segmentGroup","route","parts","path","split","length","pathMatch","hasChildren","posParams","index","part","segment","isParameter","substring","consumed","slice","shallowEqualArrays","a","b","i","shallowEqual","k1","getDataKeys","undefined","k2","key","equalArraysOrString","obj","getOwnPropertySymbols","aSorted","sort","bSorted","every","val","wrapIntoObservable","value","Promise","resolve","pathCompareMap","equalSegmentGroups","containsSegmentGroup","paramCompareMap","equalParams","containsParams","ignored","containsTree","container","containee","options","paths","root","matrixParams","queryParams","fragment","equalPath","matrixParamsMatch","numberOfChildren","c","children","containsSegmentGroupHelper","containeePaths","current","next","containerPaths","containeeSegment","parameters","UrlTree","_queryParamMap","UrlSegmentGroup","ngDevMode","queryParamMap","toString","DEFAULT_SERIALIZER","serialize","parent","values","forEach","serializePaths","UrlSegment","_parameterMap","parameterMap","serializePath","equalSegments","as","bs","mapChildrenIntoArray","fn","res","entries","childOutlet","child","UrlSerializer","ɵfac","UrlSerializer_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","DefaultUrlSerializer","providedIn","ɵsetClassMetadata","type","args","useFactory","parse","url","p","UrlParser","parseRootSegment","parseQueryParams","parseFragment","tree","serializeSegment","query","serializeQueryParams","encodeUriFragment","join","primary","k","push","encodeUriString","s","encodeURIComponent","replace","encodeUriQuery","encodeURI","encodeUriSegment","decode","decodeURIComponent","decodeQuery","serializeMatrixParams","strParams","SEGMENT_RE","matchSegments","str","match","MATRIX_PARAM_SEGMENT_RE","matchMatrixKeySegments","QUERY_PARAM_RE","matchQueryParams","QUERY_PARAM_VALUE_RE","matchUrlQueryParamValue","remaining","consumeOptional","peekStartsWith","parseChildren","parseQueryParam","parseSegment","capture","parseParens","parseMatrixParams","parseParam","valueMatch","decodedKey","decodedVal","currentVal","allowPrimary","outletName","indexOf","startsWith","createRoot","rootCandidate","squashSegmentGroup","newChildren","childCandidate","grandChildOutlet","grandChild","mergeTrivialChildren","isUrlTree","createUrlTreeFromSnapshot","relativeTo","commands","relativeToUrlSegmentGroup","createSegmentGroupFromRoute","createUrlTreeFromSegmentGroup","targetGroup","createSegmentGroupFromRouteRecursive","currentRoute","childOutlets","childSnapshot","outlet","rootSegmentGroup","nav","computeNavigation","toRoot","position","findStartingPositionForTargetGroup","newSegmentGroup","processChildren","updateSegmentGroupChildren","updateSegmentGroup","isMatrixParams","command","outlets","segmentPath","isCommandWithOutlets","oldRoot","oldSegmentGroup","qp","replaceSegment","newRoot","oldSegment","newSegment","Navigation","isAbsolute","numberOfDoubleDots","cmdWithOutlet","find","reduce","cmd","cmdIdx","urlPart","partIndex","Position","target","NaN","modifier","createPositionApplyingDoubleDots","group","g","ci","dd","getOutlets","startIndex","m","prefixedWith","slicedCommands","commandIndex","pathIndex","createNewSegmentGroup","some","o","childrenOfEmptyChild","currentCommandIndex","currentPathIndex","noMatch","curr","compare","createNewSegmentChildren","stringify","IMPERATIVE_NAVIGATION","EventType","RouterEvent","id","NavigationStart","navigationTrigger","restoredState","NavigationEnd","urlAfterRedirects","NavigationCancellationCode","NavigationSkippedCode","NavigationCancel","reason","code","NavigationSkipped","NavigationError","error","RoutesRecognized","state","GuardsCheckStart","GuardsCheckEnd","shouldActivate","ResolveStart","ResolveEnd","RouteConfigLoadStart","RouteConfigLoadEnd","ChildActivationStart","snapshot","routeConfig","ChildActivationEnd","ActivationStart","ActivationEnd","Scroll","routerEvent","anchor","pos","BeforeActivateRoutes","RedirectRequest","navigationBehaviorOptions","stringifyEvent","getOrCreateRouteInjectorIfNeeded","currentInjector","providers","_injector","validateConfig","config","parentPath","requireStandaloneComponents","fullPath","getFullPath","validateNode","assertStandalone","component","redirectTo","loadComponent","loadChildren","canActivate","matcher","charAt","exp","getOutlet","sortByMatchingOutlets","routes","sortedConfig","r","getClosestRouteInjector","_loadedInjector","OutletContext","rootInjector","attachRef","injector","ChildrenOutletContexts","contexts","Map","onChildOutletCreated","childName","context","getOrCreateContext","set","onChildOutletDestroyed","getContext","onOutletDeactivated","onOutletReAttached","ChildrenOutletContexts_Factory","ɵɵinject","Tree","_root","t","pathFromRoot","n","findNode","firstChild","siblings","findPath","cc","node","unshift","TreeNode","nodeChildrenAsMap","RouterState","setRouterState","createEmptyState","rootComponent","createEmptyStateSnapshot","emptyUrl","emptyParams","emptyData","emptyQueryParams","activated","ActivatedRoute","ActivatedRouteSnapshot","RouterStateSnapshot","urlSubject","paramsSubject","queryParamsSubject","fragmentSubject","dataSubject","_futureSnapshot","_routerState","_paramMap","title","data","futureSnapshot","d","paramMap","getInherited","paramsInheritanceStrategy","inherited","_resolvedData","hasStaticTitle","_resolve","matched","serializeNode","advanceActivatedRoute","currentSnapshot","nextSnapshot","equalParamsAndUrlSegments","equalUrlParams","parentsMismatch","ROUTER_OUTLET_DATA","RouterOutlet","activatedComponentRef","_activatedRoute","activateEvents","deactivateEvents","attachEvents","detachEvents","routerOutletData","parentContexts","location","changeDetector","inputBinder","INPUT_BINDER","optional","supportsBindingToComponentInputs","ngOnChanges","changes","firstChange","previousValue","isTrackedInParentContexts","deactivate","initializeOutletWithName","ngOnDestroy","unsubscribeFromRouteData","ngOnInit","attach","activateWith","isActivated","instance","activatedRoute","activatedRouteData","detach","cmp","emit","ref","insert","hostView","bindActivatedRouteToOutletComponent","destroy","environmentInjector","childContexts","OutletInjector","createComponent","markForCheck","RouterOutlet_Factory","ɵdir","ɵɵdefineDirective","selectors","inputs","outputs","exportAs","features","ɵɵNgOnChangesFeature","selector","outletData","notFoundValue","RoutedComponentInputBinder","outletDataSubscriptions","subscribeToRouteData","unsubscribe","delete","dataSubscription","subscribe","mirror","templateName","setInput","RoutedComponentInputBinder_Factory","ɵEmptyOutletComponent","ɵEmptyOutletComponent_Factory","ɵcmp","ɵɵdefineComponent","decls","vars","template","_EmptyOutletComponent_Template","rf","ctx","ɵɵelement","dependencies","encapsulation","imports","standardizeConfig","createRouterState","routeReuseStrategy","prevState","createNode","shouldReuseRoute","createOrReuseChildren","shouldAttach","detachedRouteHandle","retrieve","createActivatedRoute","RedirectCommand","NAVIGATION_CANCELING_ERROR","redirectingNavigationError","urlSerializer","redirect","navigationCancelingError","Redirect","message","Error","cancellationCode","isRedirectingNavigationCancelingError","isNavigationCancelingError","warnedAboutUnsupportedInputBinding","activateRoutes","rootContexts","forwardEvent","inputBindingEnabled","ActivateRoutes","targetRouterState","currentRouterState","activate","futureState","currState","futureRoot","currRoot","deactivateChildRoutes","activateChildRoutes","futureNode","currNode","futureChild","childOutletName","deactivateRoutes","deactivateRouteAndItsChildren","parentContext","future","shouldDetach","detachAndStoreRouteSubtree","deactivateRouteAndOutlet","treeNode","componentRef","store","stored","console","warn","CanActivate","CanDeactivate","getAllRouteGuards","getChildRouteGuards","getCanActivateChild","canActivateChild","guards","getTokenOrFunctionIdentity","tokenOrFunction","NOT_FOUND","result","futurePath","checks","canDeactivateChecks","canActivateChecks","prevChildren","getRouteGuards","shouldRun","shouldRunGuardsAndResolvers","runGuardsAndResolvers","mode","isFunction","isBoolean","isCanLoad","guard","canLoad","isCanActivate","isCanActivateChild","isCanDeactivate","canDeactivate","isCanMatch","canMatch","isEmptyError","e","INITIAL_VALUE","prioritizedGuardValue","obs","results","isRedirect","item","checkGuards","targetSnapshot","guardsResult","runCanDeactivateChecks","runCanActivateChecks","futureRSS","currRSS","check","runCanDeactivate","fireChildActivationStart","fireActivationStart","runCanActivateChild","runCanActivate","futureARS","canActivateObservables","closestInjector","guardVal","canActivateChildGuards","reverse","_","canActivateChildGuardsMapped","guardsMapped","currARS","canDeactivateObservables","runCanLoadGuards","canLoadObservables","injectionToken","redirectIfUrlTree","runCanMatchGuards","canMatchObservables","NoMatch","AbsoluteRedirect","urlTree","noMatch$1","namedOutletsRedirect","canLoadFails","GuardRejected","ApplyRedirects","lineralizeSegments","applyRedirectCommands","redirectToFn","newRedirect","newTree","applyRedirectCreateUrlTree","createSegmentGroup","createQueryParams","redirectToParams","actualParams","copySourceValue","sourceName","updatedSegments","createSegments","redirectToSegments","actualSegments","findPosParam","findOrReturn","redirectToUrlSegment","idx","splice","consumedSegments","remainingSegments","positionalParamSegments","matchWithChecks","createWildcardMatchResult","slicedSegments","containsEmptyPathMatchesWithNamedOutlets","createChildrenForEmptyPaths","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","emptyPathMatch","primarySegment","noLeftoversInUrl","NoLeftoversInUrl","recognize$1","configLoader","rootComponentType","Recognizer","recognize","MAX_ALLOWED_REDIRECTS","applyRedirects","absoluteRedirectCount","allowRedirects","noMatchError","rootSnapshot","rootNode","routeState","freeze","processSegmentGroup","parentRoute","processSegment","outletChildren","mergedChildren","mergeEmptyPathMatches","checkOutletNameUniqueness","sortActivatedRouteSnapshots","processSegmentAgainstRoute","x","rawSegment","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","getData","_loadedComponent","getResolve","newSegments","matchResult","getChildConfig","childConfig","childInjector","matchedOnOutlet","_loadedRoutes","shouldLoadResult","cfg","nodes","localeCompare","hasEmptyPathConfig","mergedNodes","Set","duplicateEmptyPathNode","resultNode","add","mergedNode","names","routeWithSameOutletName","serializer","extractedUrl","resolveData","routesWithResolversToRun","routesNeedingDataUpdates","newRoute","flattenRouteTree","routesProcessed","runResolve","size","descendants","flat","resolveNode","resolvedData","getResolver","resolver","resolverValue","switchTap","nextResult","TitleStrategy","buildTitle","pageTitle","getResolvedTitleForRoute","TitleStrategy_Factory","DefaultTitleStrategy","updateTitle","setTitle","DefaultTitleStrategy_Factory","Title","ROUTER_CONFIGURATION","ROUTES","RouterConfigLoader","componentLoaders","WeakMap","childrenLoaders","onLoadStartListener","onLoadEndListener","compiler","loadRunner","maybeUnwrapDefaultExport","loader","parentInjector","moduleFactoryOrRoutes$","RouterConfigLoader_Factory","compileModuleAsync","factoryOrRoutes","rawRoutes","create","self","isWrappedDefaultExport","UrlHandlingStrategy","UrlHandlingStrategy_Factory","DefaultUrlHandlingStrategy","shouldProcessUrl","extract","merge","newUrlPart","wholeUrl","DefaultUrlHandlingStrategy_Factory","CREATE_VIEW_TRANSITION","VIEW_TRANSITION_OPTIONS","createViewTransition","to","transitionOptions","document","runOutsideAngular","startViewTransition","skipNextTransition","setTimeout","resolveViewTransitionStarted","viewTransitionStarted","transition","createRenderPromise","onViewTransitionCreated","read","NAVIGATION_ERROR_HANDLER","NavigationTransitions","currentNavigation","currentTransition","lastSuccessfulNavigation","events","transitionAbortSubject","destroyRef","titleStrategy","urlHandlingStrategy","navigationErrorHandler","navigationId","hasRequestedNavigation","transitions","afterPreactivation","destroyed","onLoadStart","onLoadEnd","onDestroy","complete","handleNavigationRequest","request","rawUrl","setupNavigations","router","overallTransitionState","completed","errored","cancellationReason","cancelNavigationTransition","SupersededByNewNavigation","initialUrl","targetBrowserUrl","extras","browserUrl","trigger","source","previousNavigation","urlTransition","navigated","isUpdatingInternalState","isUpdatedBrowserUrl","onSameUrlNavigation","IgnoredSameUrlNavigation","finalUrl","routesRecognized","currentRawUrl","navStart","skipLocationChange","replaceUrl","IgnoredByUrlHandlingStrategy","guardsStart","evt","guardsEnd","resolveStart","dataResolved","NoDataFromResolver","resolveEnd","loadComponents","loaders","loadedComponent","err","cancelationReason","navigationError","navigationErrorHandlerResult","ee","resolveNavigationPromiseOnError","reject","navCancel","currentUrlTree","currentBrowserUrl","NavigationTransitions_Factory","isBrowserTriggeredNavigation","RouteReuseStrategy","RouteReuseStrategy_Factory","DefaultRouteReuseStrategy","BaseRouteReuseStrategy","detachedTree","ɵDefaultRouteReuseStrategy_BaseFactory","DefaultRouteReuseStrategy_Factory","ɵɵgetInheritedFactory","StateManager","canceledNavigationResolution","urlUpdateStrategy","getCurrentUrlTree","rawUrlTree","getRawUrlTree","createBrowserPath","commitTransition","routerState","getRouterState","stateMemento","createStateMemento","updateStateMemento","resetInternalState","StateManager_Factory","HistoryStateManager","currentPageId","lastSuccessfulId","getState","browserPageId","ɵrouterPageId","registerNonRouterCurrentEntryChangeListener","listener","event","handleRouterEvent","setBrowserUrl","restoreHistory","isCurrentPathEqualTo","currentBrowserPageId","newState","generateNgRouterState","replaceState","go","navigation","restoringFromCaughtError","targetPagePosition","historyGo","resetUrlToCurrentUrlTree","routerPageId","ɵHistoryStateManager_BaseFactory","HistoryStateManager_Factory","afterNextNavigation","action","redirecting","exactMatchOptions","subsetMatchOptions","Router","stateManager","disposed","nonRouterCurrentEntryChangeSubscription","pendingTasks","navigationTransitions","_events","componentInputBindingEnabled","resetConfig","subscribeToNavigationEvents","eventsSubscription","subscription","opts","mergedTree","info","scheduleNavigation","promise","isPublicRouterEvent","resetRootComponentType","initialNavigation","setUpLocationChangeListener","navigateToSyncWithBrowser","stateCopy","parseUrl","serializeUrl","getCurrentNavigation","dispose","createUrlTree","navigationExtras","queryParamsHandling","preserveFragment","f","q","defaultQueryParamsHandling","removeEmptyProps","relativeToSnapshot","navigateByUrl","navigate","validateCommands","isActive","matchOptions","priorPromise","rej","taskId","queueMicrotask","remove","catch","Router_Factory"],"sources":["D:/WHYQ_PROJECTS/AKLINKS_LINKSHORTNER/aklinks_frontned/node_modules/@angular/router/fesm2022/router-Dwfin5Au.mjs"],"sourcesContent":["/**\r\n * @license Angular v19.2.15\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { DOCUMENT, Location } from '@angular/common';\r\nimport * as i0 from '@angular/core';\r\nimport { ɵisPromise as _isPromise, ɵRuntimeError as _RuntimeError, Injectable, ɵisNgModule as _isNgModule, isStandalone, createEnvironmentInjector, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Output, Input, Directive, reflectComponentType, Component, ɵisInjectable as _isInjectable, runInInjectionContext, NgModuleFactory, Compiler, NgZone, afterNextRender, EnvironmentInjector, DestroyRef, ɵConsole as _Console, ɵPendingTasksInternal as _PendingTasksInternal } from '@angular/core';\r\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, concat, defer, pipe, throwError, EMPTY, ConnectableObservable, Subject, Subscription } from 'rxjs';\r\nimport { map, switchMap, take, startWith, filter, mergeMap, first, concatMap, tap, catchError, scan, defaultIfEmpty, last as last$1, takeLast, finalize, refCount, takeUntil } from 'rxjs/operators';\r\nimport * as i1 from '@angular/platform-browser';\r\n\r\n/**\r\n * The primary routing outlet.\r\n *\r\n * @publicApi\r\n */\r\nconst PRIMARY_OUTLET = 'primary';\r\n/**\r\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\r\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\r\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\r\n */\r\nconst RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\r\nclass ParamsAsMap {\r\n    params;\r\n    constructor(params) {\r\n        this.params = params || {};\r\n    }\r\n    has(name) {\r\n        return Object.prototype.hasOwnProperty.call(this.params, name);\r\n    }\r\n    get(name) {\r\n        if (this.has(name)) {\r\n            const v = this.params[name];\r\n            return Array.isArray(v) ? v[0] : v;\r\n        }\r\n        return null;\r\n    }\r\n    getAll(name) {\r\n        if (this.has(name)) {\r\n            const v = this.params[name];\r\n            return Array.isArray(v) ? v : [v];\r\n        }\r\n        return [];\r\n    }\r\n    get keys() {\r\n        return Object.keys(this.params);\r\n    }\r\n}\r\n/**\r\n * Converts a `Params` instance to a `ParamMap`.\r\n * @param params The instance to convert.\r\n * @returns The new map instance.\r\n *\r\n * @publicApi\r\n */\r\nfunction convertToParamMap(params) {\r\n    return new ParamsAsMap(params);\r\n}\r\n/**\r\n * Matches the route configuration (`route`) against the actual URL (`segments`).\r\n *\r\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\r\n *\r\n * @param segments The remaining unmatched segments in the current navigation\r\n * @param segmentGroup The current segment group being matched\r\n * @param route The `Route` to match against.\r\n *\r\n * @see {@link UrlMatchResult}\r\n * @see {@link Route}\r\n *\r\n * @returns The resulting match information or `null` if the `route` should not match.\r\n * @publicApi\r\n */\r\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\r\n    const parts = route.path.split('/');\r\n    if (parts.length > segments.length) {\r\n        // The actual URL is shorter than the config, no match\r\n        return null;\r\n    }\r\n    if (route.pathMatch === 'full' &&\r\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\r\n        // The config is longer than the actual URL but we are looking for a full match, return null\r\n        return null;\r\n    }\r\n    const posParams = {};\r\n    // Check each config part against the actual URL\r\n    for (let index = 0; index < parts.length; index++) {\r\n        const part = parts[index];\r\n        const segment = segments[index];\r\n        const isParameter = part[0] === ':';\r\n        if (isParameter) {\r\n            posParams[part.substring(1)] = segment;\r\n        }\r\n        else if (part !== segment.path) {\r\n            // The actual URL part does not match the config, no match\r\n            return null;\r\n        }\r\n    }\r\n    return { consumed: segments.slice(0, parts.length), posParams };\r\n}\r\n\r\nfunction shallowEqualArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    for (let i = 0; i < a.length; ++i) {\r\n        if (!shallowEqual(a[i], b[i]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction shallowEqual(a, b) {\r\n    // While `undefined` should never be possible, it would sometimes be the case in IE 11\r\n    // and pre-chromium Edge. The check below accounts for this edge case.\r\n    const k1 = a ? getDataKeys(a) : undefined;\r\n    const k2 = b ? getDataKeys(b) : undefined;\r\n    if (!k1 || !k2 || k1.length != k2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (let i = 0; i < k1.length; i++) {\r\n        key = k1[i];\r\n        if (!equalArraysOrString(a[key], b[key])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Gets the keys of an object, including `symbol` keys.\r\n */\r\nfunction getDataKeys(obj) {\r\n    return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\r\n}\r\n/**\r\n * Test equality for arrays of strings or a string.\r\n */\r\nfunction equalArraysOrString(a, b) {\r\n    if (Array.isArray(a) && Array.isArray(b)) {\r\n        if (a.length !== b.length)\r\n            return false;\r\n        const aSorted = [...a].sort();\r\n        const bSorted = [...b].sort();\r\n        return aSorted.every((val, index) => bSorted[index] === val);\r\n    }\r\n    else {\r\n        return a === b;\r\n    }\r\n}\r\n/**\r\n * Return the last element of an array.\r\n */\r\nfunction last(a) {\r\n    return a.length > 0 ? a[a.length - 1] : null;\r\n}\r\nfunction wrapIntoObservable(value) {\r\n    if (isObservable(value)) {\r\n        return value;\r\n    }\r\n    if (_isPromise(value)) {\r\n        // Use `Promise.resolve()` to wrap promise-like instances.\r\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\r\n        // change detection.\r\n        return from(Promise.resolve(value));\r\n    }\r\n    return of(value);\r\n}\r\n\r\nconst pathCompareMap = {\r\n    'exact': equalSegmentGroups,\r\n    'subset': containsSegmentGroup,\r\n};\r\nconst paramCompareMap = {\r\n    'exact': equalParams,\r\n    'subset': containsParams,\r\n    'ignored': () => true,\r\n};\r\nfunction containsTree(container, containee, options) {\r\n    return (pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\r\n        paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\r\n        !(options.fragment === 'exact' && container.fragment !== containee.fragment));\r\n}\r\nfunction equalParams(container, containee) {\r\n    // TODO: This does not handle array params correctly.\r\n    return shallowEqual(container, containee);\r\n}\r\nfunction equalSegmentGroups(container, containee, matrixParams) {\r\n    if (!equalPath(container.segments, containee.segments))\r\n        return false;\r\n    if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\r\n        return false;\r\n    }\r\n    if (container.numberOfChildren !== containee.numberOfChildren)\r\n        return false;\r\n    for (const c in containee.children) {\r\n        if (!container.children[c])\r\n            return false;\r\n        if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction containsParams(container, containee) {\r\n    return (Object.keys(containee).length <= Object.keys(container).length &&\r\n        Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key])));\r\n}\r\nfunction containsSegmentGroup(container, containee, matrixParams) {\r\n    return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\r\n}\r\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\r\n    if (container.segments.length > containeePaths.length) {\r\n        const current = container.segments.slice(0, containeePaths.length);\r\n        if (!equalPath(current, containeePaths))\r\n            return false;\r\n        if (containee.hasChildren())\r\n            return false;\r\n        if (!matrixParamsMatch(current, containeePaths, matrixParams))\r\n            return false;\r\n        return true;\r\n    }\r\n    else if (container.segments.length === containeePaths.length) {\r\n        if (!equalPath(container.segments, containeePaths))\r\n            return false;\r\n        if (!matrixParamsMatch(container.segments, containeePaths, matrixParams))\r\n            return false;\r\n        for (const c in containee.children) {\r\n            if (!container.children[c])\r\n                return false;\r\n            if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    else {\r\n        const current = containeePaths.slice(0, container.segments.length);\r\n        const next = containeePaths.slice(container.segments.length);\r\n        if (!equalPath(container.segments, current))\r\n            return false;\r\n        if (!matrixParamsMatch(container.segments, current, matrixParams))\r\n            return false;\r\n        if (!container.children[PRIMARY_OUTLET])\r\n            return false;\r\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\r\n    }\r\n}\r\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\r\n    return containeePaths.every((containeeSegment, i) => {\r\n        return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\r\n    });\r\n}\r\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL.\r\n *\r\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\r\n * serialized tree.\r\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree =\r\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\r\n *     const f = tree.fragment; // return 'fragment'\r\n *     const q = tree.queryParams; // returns {debug: 'true'}\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\r\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\r\n *     g.children['support'].segments; // return 1 segment 'help'\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass UrlTree {\r\n    root;\r\n    queryParams;\r\n    fragment;\r\n    /** @internal */\r\n    _queryParamMap;\r\n    constructor(\r\n    /** The root segment group of the URL tree */\r\n    root = new UrlSegmentGroup([], {}), \r\n    /** The query params of the URL */\r\n    queryParams = {}, \r\n    /** The fragment of the URL */\r\n    fragment = null) {\r\n        this.root = root;\r\n        this.queryParams = queryParams;\r\n        this.fragment = fragment;\r\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n            if (root.segments.length > 0) {\r\n                throw new _RuntimeError(4015 /* RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT */, 'The root `UrlSegmentGroup` should not contain `segments`. ' +\r\n                    'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\r\n            }\r\n        }\r\n    }\r\n    get queryParamMap() {\r\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\r\n        return this._queryParamMap;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return DEFAULT_SERIALIZER.serialize(this);\r\n    }\r\n}\r\n/**\r\n * @description\r\n *\r\n * Represents the parsed URL segment group.\r\n *\r\n * See `UrlTree` for more information.\r\n *\r\n * @publicApi\r\n */\r\nclass UrlSegmentGroup {\r\n    segments;\r\n    children;\r\n    /** The parent node in the url tree */\r\n    parent = null;\r\n    constructor(\r\n    /** The URL segments of this group. See `UrlSegment` for more information */\r\n    segments, \r\n    /** The list of children of this group */\r\n    children) {\r\n        this.segments = segments;\r\n        this.children = children;\r\n        Object.values(children).forEach((v) => (v.parent = this));\r\n    }\r\n    /** Whether the segment has child segments */\r\n    hasChildren() {\r\n        return this.numberOfChildren > 0;\r\n    }\r\n    /** Number of child segments */\r\n    get numberOfChildren() {\r\n        return Object.keys(this.children).length;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return serializePaths(this);\r\n    }\r\n}\r\n/**\r\n * @description\r\n *\r\n * Represents a single URL segment.\r\n *\r\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\r\n * parameters associated with the segment.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\r\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\r\n *     const s: UrlSegment[] = g.segments;\r\n *     s[0].path; // returns 'team'\r\n *     s[0].parameters; // returns {id: 33}\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass UrlSegment {\r\n    path;\r\n    parameters;\r\n    /** @internal */\r\n    _parameterMap;\r\n    constructor(\r\n    /** The path part of a URL segment */\r\n    path, \r\n    /** The matrix parameters associated with a segment */\r\n    parameters) {\r\n        this.path = path;\r\n        this.parameters = parameters;\r\n    }\r\n    get parameterMap() {\r\n        this._parameterMap ??= convertToParamMap(this.parameters);\r\n        return this._parameterMap;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return serializePath(this);\r\n    }\r\n}\r\nfunction equalSegments(as, bs) {\r\n    return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\r\n}\r\nfunction equalPath(as, bs) {\r\n    if (as.length !== bs.length)\r\n        return false;\r\n    return as.every((a, i) => a.path === bs[i].path);\r\n}\r\nfunction mapChildrenIntoArray(segment, fn) {\r\n    let res = [];\r\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\r\n        if (childOutlet === PRIMARY_OUTLET) {\r\n            res = res.concat(fn(child, childOutlet));\r\n        }\r\n    });\r\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\r\n        if (childOutlet !== PRIMARY_OUTLET) {\r\n            res = res.concat(fn(child, childOutlet));\r\n        }\r\n    });\r\n    return res;\r\n}\r\n/**\r\n * @description\r\n *\r\n * Serializes and deserializes a URL string into a URL tree.\r\n *\r\n * The url serialization strategy is customizable. You can\r\n * make all URLs case insensitive by providing a custom UrlSerializer.\r\n *\r\n * See `DefaultUrlSerializer` for an example of a URL serializer.\r\n *\r\n * @publicApi\r\n */\r\nclass UrlSerializer {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlSerializer, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlSerializer, providedIn: 'root', useFactory: () => new DefaultUrlSerializer() });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlSerializer, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root', useFactory: () => new DefaultUrlSerializer() }]\r\n        }] });\r\n/**\r\n * @description\r\n *\r\n * A default implementation of the `UrlSerializer`.\r\n *\r\n * Example URLs:\r\n *\r\n * ```\r\n * /inbox/33(popup:compose)\r\n * /inbox/33;open=true/messages/44\r\n * ```\r\n *\r\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\r\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\r\n * specify route specific parameters.\r\n *\r\n * @publicApi\r\n */\r\nclass DefaultUrlSerializer {\r\n    /** Parses a url into a `UrlTree` */\r\n    parse(url) {\r\n        const p = new UrlParser(url);\r\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\r\n    }\r\n    /** Converts a `UrlTree` into a url */\r\n    serialize(tree) {\r\n        const segment = `/${serializeSegment(tree.root, true)}`;\r\n        const query = serializeQueryParams(tree.queryParams);\r\n        const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\r\n        return `${segment}${query}${fragment}`;\r\n    }\r\n}\r\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\r\nfunction serializePaths(segment) {\r\n    return segment.segments.map((p) => serializePath(p)).join('/');\r\n}\r\nfunction serializeSegment(segment, root) {\r\n    if (!segment.hasChildren()) {\r\n        return serializePaths(segment);\r\n    }\r\n    if (root) {\r\n        const primary = segment.children[PRIMARY_OUTLET]\r\n            ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\r\n            : '';\r\n        const children = [];\r\n        Object.entries(segment.children).forEach(([k, v]) => {\r\n            if (k !== PRIMARY_OUTLET) {\r\n                children.push(`${k}:${serializeSegment(v, false)}`);\r\n            }\r\n        });\r\n        return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\r\n    }\r\n    else {\r\n        const children = mapChildrenIntoArray(segment, (v, k) => {\r\n            if (k === PRIMARY_OUTLET) {\r\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\r\n            }\r\n            return [`${k}:${serializeSegment(v, false)}`];\r\n        });\r\n        // use no parenthesis if the only child is a primary outlet route\r\n        if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\r\n            return `${serializePaths(segment)}/${children[0]}`;\r\n        }\r\n        return `${serializePaths(segment)}/(${children.join('//')})`;\r\n    }\r\n}\r\n/**\r\n * Encodes a URI string with the default encoding. This function will only ever be called from\r\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\r\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\r\n * have to be encoded per https://url.spec.whatwg.org.\r\n */\r\nfunction encodeUriString(s) {\r\n    return encodeURIComponent(s)\r\n        .replace(/%40/g, '@')\r\n        .replace(/%3A/gi, ':')\r\n        .replace(/%24/g, '$')\r\n        .replace(/%2C/gi, ',');\r\n}\r\n/**\r\n * This function should be used to encode both keys and values in a query string key/value. In\r\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\r\nfunction encodeUriQuery(s) {\r\n    return encodeUriString(s).replace(/%3B/gi, ';');\r\n}\r\n/**\r\n * This function should be used to encode a URL fragment. In the following URL, you need to call\r\n * encodeUriFragment on \"f\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\r\nfunction encodeUriFragment(s) {\r\n    return encodeURI(s);\r\n}\r\n/**\r\n * This function should be run on any URI segment as well as the key and value in a key/value\r\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\r\n * \"mk\", and \"mv\":\r\n *\r\n * http://www.site.org/html;mk=mv?k=v#f\r\n */\r\nfunction encodeUriSegment(s) {\r\n    return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\r\n}\r\nfunction decode(s) {\r\n    return decodeURIComponent(s);\r\n}\r\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\r\n// decodeURIComponent function will not decode \"+\" as a space.\r\nfunction decodeQuery(s) {\r\n    return decode(s.replace(/\\+/g, '%20'));\r\n}\r\nfunction serializePath(path) {\r\n    return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\r\n}\r\nfunction serializeMatrixParams(params) {\r\n    return Object.entries(params)\r\n        .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\r\n        .join('');\r\n}\r\nfunction serializeQueryParams(params) {\r\n    const strParams = Object.entries(params)\r\n        .map(([name, value]) => {\r\n        return Array.isArray(value)\r\n            ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\r\n            : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\r\n    })\r\n        .filter((s) => s);\r\n    return strParams.length ? `?${strParams.join('&')}` : '';\r\n}\r\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\r\nfunction matchSegments(str) {\r\n    const match = str.match(SEGMENT_RE);\r\n    return match ? match[0] : '';\r\n}\r\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\r\nfunction matchMatrixKeySegments(str) {\r\n    const match = str.match(MATRIX_PARAM_SEGMENT_RE);\r\n    return match ? match[0] : '';\r\n}\r\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\r\n// Return the name of the query param at the start of the string or an empty string\r\nfunction matchQueryParams(str) {\r\n    const match = str.match(QUERY_PARAM_RE);\r\n    return match ? match[0] : '';\r\n}\r\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\r\n// Return the value of the query param at the start of the string or an empty string\r\nfunction matchUrlQueryParamValue(str) {\r\n    const match = str.match(QUERY_PARAM_VALUE_RE);\r\n    return match ? match[0] : '';\r\n}\r\nclass UrlParser {\r\n    url;\r\n    remaining;\r\n    constructor(url) {\r\n        this.url = url;\r\n        this.remaining = url;\r\n    }\r\n    parseRootSegment() {\r\n        this.consumeOptional('/');\r\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\r\n            return new UrlSegmentGroup([], {});\r\n        }\r\n        // The root segment group never has segments\r\n        return new UrlSegmentGroup([], this.parseChildren());\r\n    }\r\n    parseQueryParams() {\r\n        const params = {};\r\n        if (this.consumeOptional('?')) {\r\n            do {\r\n                this.parseQueryParam(params);\r\n            } while (this.consumeOptional('&'));\r\n        }\r\n        return params;\r\n    }\r\n    parseFragment() {\r\n        return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\r\n    }\r\n    parseChildren() {\r\n        if (this.remaining === '') {\r\n            return {};\r\n        }\r\n        this.consumeOptional('/');\r\n        const segments = [];\r\n        if (!this.peekStartsWith('(')) {\r\n            segments.push(this.parseSegment());\r\n        }\r\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\r\n            this.capture('/');\r\n            segments.push(this.parseSegment());\r\n        }\r\n        let children = {};\r\n        if (this.peekStartsWith('/(')) {\r\n            this.capture('/');\r\n            children = this.parseParens(true);\r\n        }\r\n        let res = {};\r\n        if (this.peekStartsWith('(')) {\r\n            res = this.parseParens(false);\r\n        }\r\n        if (segments.length > 0 || Object.keys(children).length > 0) {\r\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\r\n        }\r\n        return res;\r\n    }\r\n    // parse a segment with its matrix parameters\r\n    // ie `name;k1=v1;k2`\r\n    parseSegment() {\r\n        const path = matchSegments(this.remaining);\r\n        if (path === '' && this.peekStartsWith(';')) {\r\n            throw new _RuntimeError(4009 /* RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                `Empty path url segment cannot have parameters: '${this.remaining}'.`);\r\n        }\r\n        this.capture(path);\r\n        return new UrlSegment(decode(path), this.parseMatrixParams());\r\n    }\r\n    parseMatrixParams() {\r\n        const params = {};\r\n        while (this.consumeOptional(';')) {\r\n            this.parseParam(params);\r\n        }\r\n        return params;\r\n    }\r\n    parseParam(params) {\r\n        const key = matchMatrixKeySegments(this.remaining);\r\n        if (!key) {\r\n            return;\r\n        }\r\n        this.capture(key);\r\n        let value = '';\r\n        if (this.consumeOptional('=')) {\r\n            const valueMatch = matchSegments(this.remaining);\r\n            if (valueMatch) {\r\n                value = valueMatch;\r\n                this.capture(value);\r\n            }\r\n        }\r\n        params[decode(key)] = decode(value);\r\n    }\r\n    // Parse a single query parameter `name[=value]`\r\n    parseQueryParam(params) {\r\n        const key = matchQueryParams(this.remaining);\r\n        if (!key) {\r\n            return;\r\n        }\r\n        this.capture(key);\r\n        let value = '';\r\n        if (this.consumeOptional('=')) {\r\n            const valueMatch = matchUrlQueryParamValue(this.remaining);\r\n            if (valueMatch) {\r\n                value = valueMatch;\r\n                this.capture(value);\r\n            }\r\n        }\r\n        const decodedKey = decodeQuery(key);\r\n        const decodedVal = decodeQuery(value);\r\n        if (params.hasOwnProperty(decodedKey)) {\r\n            // Append to existing values\r\n            let currentVal = params[decodedKey];\r\n            if (!Array.isArray(currentVal)) {\r\n                currentVal = [currentVal];\r\n                params[decodedKey] = currentVal;\r\n            }\r\n            currentVal.push(decodedVal);\r\n        }\r\n        else {\r\n            // Create a new value\r\n            params[decodedKey] = decodedVal;\r\n        }\r\n    }\r\n    // parse `(a/b//outlet_name:c/d)`\r\n    parseParens(allowPrimary) {\r\n        const segments = {};\r\n        this.capture('(');\r\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\r\n            const path = matchSegments(this.remaining);\r\n            const next = this.remaining[path.length];\r\n            // if is is not one of these characters, then the segment was unescaped\r\n            // or the group was not closed\r\n            if (next !== '/' && next !== ')' && next !== ';') {\r\n                throw new _RuntimeError(4010 /* RuntimeErrorCode.UNPARSABLE_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\r\n            }\r\n            let outletName = undefined;\r\n            if (path.indexOf(':') > -1) {\r\n                outletName = path.slice(0, path.indexOf(':'));\r\n                this.capture(outletName);\r\n                this.capture(':');\r\n            }\r\n            else if (allowPrimary) {\r\n                outletName = PRIMARY_OUTLET;\r\n            }\r\n            const children = this.parseChildren();\r\n            segments[outletName] =\r\n                Object.keys(children).length === 1\r\n                    ? children[PRIMARY_OUTLET]\r\n                    : new UrlSegmentGroup([], children);\r\n            this.consumeOptional('//');\r\n        }\r\n        return segments;\r\n    }\r\n    peekStartsWith(str) {\r\n        return this.remaining.startsWith(str);\r\n    }\r\n    // Consumes the prefix when it is present and returns whether it has been consumed\r\n    consumeOptional(str) {\r\n        if (this.peekStartsWith(str)) {\r\n            this.remaining = this.remaining.substring(str.length);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    capture(str) {\r\n        if (!this.consumeOptional(str)) {\r\n            throw new _RuntimeError(4011 /* RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\r\n        }\r\n    }\r\n}\r\nfunction createRoot(rootCandidate) {\r\n    return rootCandidate.segments.length > 0\r\n        ? new UrlSegmentGroup([], { [PRIMARY_OUTLET]: rootCandidate })\r\n        : rootCandidate;\r\n}\r\n/**\r\n * Recursively\r\n * - merges primary segment children into their parents\r\n * - drops empty children (those which have no segments and no children themselves). This latter\r\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\r\n * segment.\r\n * - merges named outlets without a primary segment sibling into the children. This prevents\r\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\r\n * root but the `a` route lives under an empty path primary route.\r\n */\r\nfunction squashSegmentGroup(segmentGroup) {\r\n    const newChildren = {};\r\n    for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\r\n        const childCandidate = squashSegmentGroup(child);\r\n        // moves named children in an empty path primary child into this group\r\n        if (childOutlet === PRIMARY_OUTLET &&\r\n            childCandidate.segments.length === 0 &&\r\n            childCandidate.hasChildren()) {\r\n            for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\r\n                newChildren[grandChildOutlet] = grandChild;\r\n            }\r\n        } // don't add empty children\r\n        else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\r\n            newChildren[childOutlet] = childCandidate;\r\n        }\r\n    }\r\n    const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\r\n    return mergeTrivialChildren(s);\r\n}\r\n/**\r\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\r\n *\r\n * When a segment group has only one child which is a primary outlet, merges that child into the\r\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\r\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\r\n * group into the parent.\r\n */\r\nfunction mergeTrivialChildren(s) {\r\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\r\n        const c = s.children[PRIMARY_OUTLET];\r\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\r\n    }\r\n    return s;\r\n}\r\nfunction isUrlTree(v) {\r\n    return v instanceof UrlTree;\r\n}\r\n\r\n/**\r\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\r\n *\r\n * @publicApi\r\n *\r\n *\r\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\r\n * @param commands An array of URL fragments with which to construct the new URL tree.\r\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n * segments, followed by the parameters for each segment.\r\n * The fragments are applied to the one provided in the `relativeTo` parameter.\r\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\r\n *     any query parameters.\r\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\r\n *\r\n * @usageNotes\r\n *\r\n * ```ts\r\n * // create /team/33/user/11\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\r\n *\r\n * // create /team/33;expand=true/user/11\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\r\n *\r\n * // you can collapse static segments like this (this works only with the first passed-in value):\r\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\r\n *\r\n * // If the first segment can contain slashes, and you do not want the router to split it,\r\n * // you can do the following:\r\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\r\n *\r\n * // create /team/33/(user/11//right:chat)\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\r\n * 'chat'}}], null, null);\r\n *\r\n * // remove the right secondary node\r\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\r\n *\r\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\r\n * `ActivatedRouteSnapshot` points to `user/11`:\r\n *\r\n * // navigate to /team/33/user/11/details\r\n * createUrlTreeFromSnapshot(snapshot, ['details']);\r\n *\r\n * // navigate to /team/33/user/22\r\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\r\n *\r\n * // navigate to /team/44/user/22\r\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\r\n * ```\r\n */\r\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {\r\n    const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\r\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\r\n}\r\nfunction createSegmentGroupFromRoute(route) {\r\n    let targetGroup;\r\n    function createSegmentGroupFromRouteRecursive(currentRoute) {\r\n        const childOutlets = {};\r\n        for (const childSnapshot of currentRoute.children) {\r\n            const root = createSegmentGroupFromRouteRecursive(childSnapshot);\r\n            childOutlets[childSnapshot.outlet] = root;\r\n        }\r\n        const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\r\n        if (currentRoute === route) {\r\n            targetGroup = segmentGroup;\r\n        }\r\n        return segmentGroup;\r\n    }\r\n    const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\r\n    const rootSegmentGroup = createRoot(rootCandidate);\r\n    return targetGroup ?? rootSegmentGroup;\r\n}\r\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\r\n    let root = relativeTo;\r\n    while (root.parent) {\r\n        root = root.parent;\r\n    }\r\n    // There are no commands so the `UrlTree` goes to the same path as the one created from the\r\n    // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\r\n    // applying any other logic.\r\n    if (commands.length === 0) {\r\n        return tree(root, root, root, queryParams, fragment);\r\n    }\r\n    const nav = computeNavigation(commands);\r\n    if (nav.toRoot()) {\r\n        return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\r\n    }\r\n    const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\r\n    const newSegmentGroup = position.processChildren\r\n        ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\r\n        : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\r\n    return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\r\n}\r\nfunction isMatrixParams(command) {\r\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\r\n}\r\n/**\r\n * Determines if a given command has an `outlets` map. When we encounter a command\r\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\r\n */\r\nfunction isCommandWithOutlets(command) {\r\n    return typeof command === 'object' && command != null && command.outlets;\r\n}\r\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\r\n    let qp = {};\r\n    if (queryParams) {\r\n        Object.entries(queryParams).forEach(([name, value]) => {\r\n            qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;\r\n        });\r\n    }\r\n    let rootCandidate;\r\n    if (oldRoot === oldSegmentGroup) {\r\n        rootCandidate = newSegmentGroup;\r\n    }\r\n    else {\r\n        rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\r\n    }\r\n    const newRoot = createRoot(squashSegmentGroup(rootCandidate));\r\n    return new UrlTree(newRoot, qp, fragment);\r\n}\r\n/**\r\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\r\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\r\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\r\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\r\n * value.\r\n */\r\nfunction replaceSegment(current, oldSegment, newSegment) {\r\n    const children = {};\r\n    Object.entries(current.children).forEach(([outletName, c]) => {\r\n        if (c === oldSegment) {\r\n            children[outletName] = newSegment;\r\n        }\r\n        else {\r\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\r\n        }\r\n    });\r\n    return new UrlSegmentGroup(current.segments, children);\r\n}\r\nclass Navigation {\r\n    isAbsolute;\r\n    numberOfDoubleDots;\r\n    commands;\r\n    constructor(isAbsolute, numberOfDoubleDots, commands) {\r\n        this.isAbsolute = isAbsolute;\r\n        this.numberOfDoubleDots = numberOfDoubleDots;\r\n        this.commands = commands;\r\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\r\n            throw new _RuntimeError(4003 /* RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                'Root segment cannot have matrix parameters');\r\n        }\r\n        const cmdWithOutlet = commands.find(isCommandWithOutlets);\r\n        if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\r\n            throw new _RuntimeError(4004 /* RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                '{outlets:{}} has to be the last command');\r\n        }\r\n    }\r\n    toRoot() {\r\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\r\n    }\r\n}\r\n/** Transforms commands to a normalized `Navigation` */\r\nfunction computeNavigation(commands) {\r\n    if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\r\n        return new Navigation(true, 0, commands);\r\n    }\r\n    let numberOfDoubleDots = 0;\r\n    let isAbsolute = false;\r\n    const res = commands.reduce((res, cmd, cmdIdx) => {\r\n        if (typeof cmd === 'object' && cmd != null) {\r\n            if (cmd.outlets) {\r\n                const outlets = {};\r\n                Object.entries(cmd.outlets).forEach(([name, commands]) => {\r\n                    outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\r\n                });\r\n                return [...res, { outlets }];\r\n            }\r\n            if (cmd.segmentPath) {\r\n                return [...res, cmd.segmentPath];\r\n            }\r\n        }\r\n        if (!(typeof cmd === 'string')) {\r\n            return [...res, cmd];\r\n        }\r\n        if (cmdIdx === 0) {\r\n            cmd.split('/').forEach((urlPart, partIndex) => {\r\n                if (partIndex == 0 && urlPart === '.') ;\r\n                else if (partIndex == 0 && urlPart === '') {\r\n                    //  '/a'\r\n                    isAbsolute = true;\r\n                }\r\n                else if (urlPart === '..') {\r\n                    //  '../a'\r\n                    numberOfDoubleDots++;\r\n                }\r\n                else if (urlPart != '') {\r\n                    res.push(urlPart);\r\n                }\r\n            });\r\n            return res;\r\n        }\r\n        return [...res, cmd];\r\n    }, []);\r\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\r\n}\r\nclass Position {\r\n    segmentGroup;\r\n    processChildren;\r\n    index;\r\n    constructor(segmentGroup, processChildren, index) {\r\n        this.segmentGroup = segmentGroup;\r\n        this.processChildren = processChildren;\r\n        this.index = index;\r\n    }\r\n}\r\nfunction findStartingPositionForTargetGroup(nav, root, target) {\r\n    if (nav.isAbsolute) {\r\n        return new Position(root, true, 0);\r\n    }\r\n    if (!target) {\r\n        // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\r\n        // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\r\n        // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\r\n        // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\r\n        return new Position(root, false, NaN);\r\n    }\r\n    if (target.parent === null) {\r\n        return new Position(target, true, 0);\r\n    }\r\n    const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\r\n    const index = target.segments.length - 1 + modifier;\r\n    return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\r\n}\r\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\r\n    let g = group;\r\n    let ci = index;\r\n    let dd = numberOfDoubleDots;\r\n    while (dd > ci) {\r\n        dd -= ci;\r\n        g = g.parent;\r\n        if (!g) {\r\n            throw new _RuntimeError(4005 /* RuntimeErrorCode.INVALID_DOUBLE_DOTS */, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\r\n        }\r\n        ci = g.segments.length;\r\n    }\r\n    return new Position(g, false, ci - dd);\r\n}\r\nfunction getOutlets(commands) {\r\n    if (isCommandWithOutlets(commands[0])) {\r\n        return commands[0].outlets;\r\n    }\r\n    return { [PRIMARY_OUTLET]: commands };\r\n}\r\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\r\n    segmentGroup ??= new UrlSegmentGroup([], {});\r\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\r\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\r\n    }\r\n    const m = prefixedWith(segmentGroup, startIndex, commands);\r\n    const slicedCommands = commands.slice(m.commandIndex);\r\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\r\n        const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\r\n        g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\r\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\r\n    }\r\n    else if (m.match && slicedCommands.length === 0) {\r\n        return new UrlSegmentGroup(segmentGroup.segments, {});\r\n    }\r\n    else if (m.match && !segmentGroup.hasChildren()) {\r\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\r\n    }\r\n    else if (m.match) {\r\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\r\n    }\r\n    else {\r\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\r\n    }\r\n}\r\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\r\n    if (commands.length === 0) {\r\n        return new UrlSegmentGroup(segmentGroup.segments, {});\r\n    }\r\n    else {\r\n        const outlets = getOutlets(commands);\r\n        const children = {};\r\n        // If the set of commands applies to anything other than the primary outlet and the child\r\n        // segment is an empty path primary segment on its own, we want to apply the commands to the\r\n        // empty child path rather than here. The outcome is that the empty primary child is effectively\r\n        // removed from the final output UrlTree. Imagine the following config:\r\n        //\r\n        // {path: '', children: [{path: '**', outlet: 'popup'}]}.\r\n        //\r\n        // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\r\n        // navigation with commands\r\n        // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\r\n        // root segment because that would result in\r\n        // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\r\n        // the `ActivatedRoute` rather than updating the existing one.\r\n        //\r\n        // Because empty paths do not appear in the URL segments and the fact that the segments used in\r\n        // the output `UrlTree` are squashed to eliminate these empty paths where possible\r\n        // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\r\n        // it can be hard to determine what is the right thing to do when applying commands to a\r\n        // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\r\n        // This code effectively \"squashes\" empty path primary routes when they have no siblings on\r\n        // the same level of the tree.\r\n        if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\r\n            segmentGroup.children[PRIMARY_OUTLET] &&\r\n            segmentGroup.numberOfChildren === 1 &&\r\n            segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\r\n            const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\r\n            return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\r\n        }\r\n        Object.entries(outlets).forEach(([outlet, commands]) => {\r\n            if (typeof commands === 'string') {\r\n                commands = [commands];\r\n            }\r\n            if (commands !== null) {\r\n                children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\r\n            }\r\n        });\r\n        Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\r\n            if (outlets[childOutlet] === undefined) {\r\n                children[childOutlet] = child;\r\n            }\r\n        });\r\n        return new UrlSegmentGroup(segmentGroup.segments, children);\r\n    }\r\n}\r\nfunction prefixedWith(segmentGroup, startIndex, commands) {\r\n    let currentCommandIndex = 0;\r\n    let currentPathIndex = startIndex;\r\n    const noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\r\n    while (currentPathIndex < segmentGroup.segments.length) {\r\n        if (currentCommandIndex >= commands.length)\r\n            return noMatch;\r\n        const path = segmentGroup.segments[currentPathIndex];\r\n        const command = commands[currentCommandIndex];\r\n        // Do not try to consume command as part of the prefixing if it has outlets because it can\r\n        // contain outlets other than the one being processed. Consuming the outlets command would\r\n        // result in other outlets being ignored.\r\n        if (isCommandWithOutlets(command)) {\r\n            break;\r\n        }\r\n        const curr = `${command}`;\r\n        const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\r\n        if (currentPathIndex > 0 && curr === undefined)\r\n            break;\r\n        if (curr && next && typeof next === 'object' && next.outlets === undefined) {\r\n            if (!compare(curr, next, path))\r\n                return noMatch;\r\n            currentCommandIndex += 2;\r\n        }\r\n        else {\r\n            if (!compare(curr, {}, path))\r\n                return noMatch;\r\n            currentCommandIndex++;\r\n        }\r\n        currentPathIndex++;\r\n    }\r\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\r\n}\r\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\r\n    const paths = segmentGroup.segments.slice(0, startIndex);\r\n    let i = 0;\r\n    while (i < commands.length) {\r\n        const command = commands[i];\r\n        if (isCommandWithOutlets(command)) {\r\n            const children = createNewSegmentChildren(command.outlets);\r\n            return new UrlSegmentGroup(paths, children);\r\n        }\r\n        // if we start with an object literal, we need to reuse the path part from the segment\r\n        if (i === 0 && isMatrixParams(commands[0])) {\r\n            const p = segmentGroup.segments[startIndex];\r\n            paths.push(new UrlSegment(p.path, stringify(commands[0])));\r\n            i++;\r\n            continue;\r\n        }\r\n        const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\r\n        const next = i < commands.length - 1 ? commands[i + 1] : null;\r\n        if (curr && next && isMatrixParams(next)) {\r\n            paths.push(new UrlSegment(curr, stringify(next)));\r\n            i += 2;\r\n        }\r\n        else {\r\n            paths.push(new UrlSegment(curr, {}));\r\n            i++;\r\n        }\r\n    }\r\n    return new UrlSegmentGroup(paths, {});\r\n}\r\nfunction createNewSegmentChildren(outlets) {\r\n    const children = {};\r\n    Object.entries(outlets).forEach(([outlet, commands]) => {\r\n        if (typeof commands === 'string') {\r\n            commands = [commands];\r\n        }\r\n        if (commands !== null) {\r\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\r\n        }\r\n    });\r\n    return children;\r\n}\r\nfunction stringify(params) {\r\n    const res = {};\r\n    Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\r\n    return res;\r\n}\r\nfunction compare(path, params, segment) {\r\n    return path == segment.path && shallowEqual(params, segment.parameters);\r\n}\r\n\r\nconst IMPERATIVE_NAVIGATION = 'imperative';\r\n/**\r\n * Identifies the type of a router event.\r\n *\r\n * @publicApi\r\n */\r\nvar EventType;\r\n(function (EventType) {\r\n    EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\r\n    EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\r\n    EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\r\n    EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\r\n    EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\r\n    EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\r\n    EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\r\n    EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\r\n    EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\r\n    EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\r\n    EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\r\n    EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\r\n    EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\r\n    EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\r\n    EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\r\n    EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\r\n    EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\r\n})(EventType || (EventType = {}));\r\n/**\r\n * Base for events the router goes through, as opposed to events tied to a specific\r\n * route. Fired one time for any given navigation.\r\n *\r\n * The following code shows how a class subscribes to router events.\r\n *\r\n * ```ts\r\n * import {Event, RouterEvent, Router} from '@angular/router';\r\n *\r\n * class MyService {\r\n *   constructor(public router: Router) {\r\n *     router.events.pipe(\r\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\r\n *     ).subscribe((e: RouterEvent) => {\r\n *       // Do something\r\n *     });\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see {@link Event}\r\n * @see [Router events summary](guide/routing/router-reference#router-events)\r\n * @publicApi\r\n */\r\nclass RouterEvent {\r\n    id;\r\n    url;\r\n    constructor(\r\n    /** A unique ID that the router assigns to every router navigation. */\r\n    id, \r\n    /** The URL that is the destination for this navigation. */\r\n    url) {\r\n        this.id = id;\r\n        this.url = url;\r\n    }\r\n}\r\n/**\r\n * An event triggered when a navigation starts.\r\n *\r\n * @publicApi\r\n */\r\nclass NavigationStart extends RouterEvent {\r\n    type = EventType.NavigationStart;\r\n    /**\r\n     * Identifies the call or event that triggered the navigation.\r\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\r\n     *\r\n     * @see {@link NavigationEnd}\r\n     * @see {@link NavigationCancel}\r\n     * @see {@link NavigationError}\r\n     */\r\n    navigationTrigger;\r\n    /**\r\n     * The navigation state that was previously supplied to the `pushState` call,\r\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\r\n     *\r\n     * The state object is defined by `NavigationExtras`, and contains any\r\n     * developer-defined state value, as well as a unique ID that\r\n     * the router assigns to every router transition/navigation.\r\n     *\r\n     * From the perspective of the router, the router never \"goes back\".\r\n     * When the user clicks on the back button in the browser,\r\n     * a new navigation ID is created.\r\n     *\r\n     * Use the ID in this previous-state object to differentiate between a newly created\r\n     * state and one returned to by a `popstate` event, so that you can restore some\r\n     * remembered state, such as scroll position.\r\n     *\r\n     */\r\n    restoredState;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    navigationTrigger = 'imperative', \r\n    /** @docsNotRequired */\r\n    restoredState = null) {\r\n        super(id, url);\r\n        this.navigationTrigger = navigationTrigger;\r\n        this.restoredState = restoredState;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered when a navigation ends successfully.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationCancel}\r\n * @see {@link NavigationError}\r\n *\r\n * @publicApi\r\n */\r\nclass NavigationEnd extends RouterEvent {\r\n    urlAfterRedirects;\r\n    type = EventType.NavigationEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\r\n    }\r\n}\r\n/**\r\n * A code for the `NavigationCancel` event of the `Router` to indicate the\r\n * reason a navigation failed.\r\n *\r\n * @publicApi\r\n */\r\nvar NavigationCancellationCode;\r\n(function (NavigationCancellationCode) {\r\n    /**\r\n     * A navigation failed because a guard returned a `UrlTree` to redirect.\r\n     */\r\n    NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\r\n    /**\r\n     * A navigation failed because a more recent navigation started.\r\n     */\r\n    NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\r\n    /**\r\n     * A navigation failed because one of the resolvers completed without emitting a value.\r\n     */\r\n    NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\r\n    /**\r\n     * A navigation failed because a guard returned `false`.\r\n     */\r\n    NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\r\n})(NavigationCancellationCode || (NavigationCancellationCode = {}));\r\n/**\r\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\r\n * reason a navigation was skipped.\r\n *\r\n * @publicApi\r\n */\r\nvar NavigationSkippedCode;\r\n(function (NavigationSkippedCode) {\r\n    /**\r\n     * A navigation was skipped because the navigation URL was the same as the current Router URL.\r\n     */\r\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\r\n    /**\r\n     * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\r\n     * the current Router URL and the target of the navigation.\r\n     *\r\n     * @see {@link UrlHandlingStrategy}\r\n     */\r\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\r\n})(NavigationSkippedCode || (NavigationSkippedCode = {}));\r\n/**\r\n * An event triggered when a navigation is canceled, directly or indirectly.\r\n * This can happen for several reasons including when a route guard\r\n * returns `false` or initiates a redirect by returning a `UrlTree`.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationEnd}\r\n * @see {@link NavigationError}\r\n *\r\n * @publicApi\r\n */\r\nclass NavigationCancel extends RouterEvent {\r\n    reason;\r\n    code;\r\n    type = EventType.NavigationCancel;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /**\r\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\r\n     * instead for a stable cancellation reason that can be used in production.\r\n     */\r\n    reason, \r\n    /**\r\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\r\n     * the reason and can be relied on whereas the `reason` string could change and should not be\r\n     * used in production.\r\n     */\r\n    code) {\r\n        super(id, url);\r\n        this.reason = reason;\r\n        this.code = code;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered when a navigation is skipped.\r\n * This can happen for a couple reasons including onSameUrlHandling\r\n * is set to `ignore` and the navigation URL is not different than the\r\n * current state.\r\n *\r\n * @publicApi\r\n */\r\nclass NavigationSkipped extends RouterEvent {\r\n    reason;\r\n    code;\r\n    type = EventType.NavigationSkipped;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /**\r\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\r\n     * instead for a stable skipped reason that can be used in production.\r\n     */\r\n    reason, \r\n    /**\r\n     * A code to indicate why the navigation was skipped. This code is stable for\r\n     * the reason and can be relied on whereas the `reason` string could change and should not be\r\n     * used in production.\r\n     */\r\n    code) {\r\n        super(id, url);\r\n        this.reason = reason;\r\n        this.code = code;\r\n    }\r\n}\r\n/**\r\n * An event triggered when a navigation fails due to an unexpected error.\r\n *\r\n * @see {@link NavigationStart}\r\n * @see {@link NavigationEnd}\r\n * @see {@link NavigationCancel}\r\n *\r\n * @publicApi\r\n */\r\nclass NavigationError extends RouterEvent {\r\n    error;\r\n    target;\r\n    type = EventType.NavigationError;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    error, \r\n    /**\r\n     * The target of the navigation when the error occurred.\r\n     *\r\n     * Note that this can be `undefined` because an error could have occurred before the\r\n     * `RouterStateSnapshot` was created for the navigation.\r\n     */\r\n    target) {\r\n        super(id, url);\r\n        this.error = error;\r\n        this.target = target;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered when routes are recognized.\r\n *\r\n * @publicApi\r\n */\r\nclass RoutesRecognized extends RouterEvent {\r\n    urlAfterRedirects;\r\n    state;\r\n    type = EventType.RoutesRecognized;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects, \r\n    /** @docsNotRequired */\r\n    state) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n        this.state = state;\r\n    }\r\n    /** @docsNotRequired */\r\n    toString() {\r\n        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the start of the Guard phase of routing.\r\n *\r\n * @see {@link GuardsCheckEnd}\r\n *\r\n * @publicApi\r\n */\r\nclass GuardsCheckStart extends RouterEvent {\r\n    urlAfterRedirects;\r\n    state;\r\n    type = EventType.GuardsCheckStart;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects, \r\n    /** @docsNotRequired */\r\n    state) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n        this.state = state;\r\n    }\r\n    toString() {\r\n        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the end of the Guard phase of routing.\r\n *\r\n * @see {@link GuardsCheckStart}\r\n *\r\n * @publicApi\r\n */\r\nclass GuardsCheckEnd extends RouterEvent {\r\n    urlAfterRedirects;\r\n    state;\r\n    shouldActivate;\r\n    type = EventType.GuardsCheckEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects, \r\n    /** @docsNotRequired */\r\n    state, \r\n    /** @docsNotRequired */\r\n    shouldActivate) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n        this.state = state;\r\n        this.shouldActivate = shouldActivate;\r\n    }\r\n    toString() {\r\n        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the start of the Resolve phase of routing.\r\n *\r\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\r\n * In future, may change to only run when there are things to be resolved.\r\n *\r\n * @see {@link ResolveEnd}\r\n *\r\n * @publicApi\r\n */\r\nclass ResolveStart extends RouterEvent {\r\n    urlAfterRedirects;\r\n    state;\r\n    type = EventType.ResolveStart;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects, \r\n    /** @docsNotRequired */\r\n    state) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n        this.state = state;\r\n    }\r\n    toString() {\r\n        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the end of the Resolve phase of routing.\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\r\nclass ResolveEnd extends RouterEvent {\r\n    urlAfterRedirects;\r\n    state;\r\n    type = EventType.ResolveEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    id, \r\n    /** @docsNotRequired */\r\n    url, \r\n    /** @docsNotRequired */\r\n    urlAfterRedirects, \r\n    /** @docsNotRequired */\r\n    state) {\r\n        super(id, url);\r\n        this.urlAfterRedirects = urlAfterRedirects;\r\n        this.state = state;\r\n    }\r\n    toString() {\r\n        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered before lazy loading a route configuration.\r\n *\r\n * @see {@link RouteConfigLoadEnd}\r\n *\r\n * @publicApi\r\n */\r\nclass RouteConfigLoadStart {\r\n    route;\r\n    type = EventType.RouteConfigLoadStart;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    route) {\r\n        this.route = route;\r\n    }\r\n    toString() {\r\n        return `RouteConfigLoadStart(path: ${this.route.path})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered when a route has been lazy loaded.\r\n *\r\n * @see {@link RouteConfigLoadStart}\r\n *\r\n * @publicApi\r\n */\r\nclass RouteConfigLoadEnd {\r\n    route;\r\n    type = EventType.RouteConfigLoadEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    route) {\r\n        this.route = route;\r\n    }\r\n    toString() {\r\n        return `RouteConfigLoadEnd(path: ${this.route.path})`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the start of the child-activation\r\n * part of the Resolve phase of routing.\r\n * @see {@link ChildActivationEnd}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\r\nclass ChildActivationStart {\r\n    snapshot;\r\n    type = EventType.ChildActivationStart;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot) {\r\n        this.snapshot = snapshot;\r\n    }\r\n    toString() {\r\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\r\n        return `ChildActivationStart(path: '${path}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the end of the child-activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ChildActivationStart}\r\n * @see {@link ResolveStart}\r\n * @publicApi\r\n */\r\nclass ChildActivationEnd {\r\n    snapshot;\r\n    type = EventType.ChildActivationEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot) {\r\n        this.snapshot = snapshot;\r\n    }\r\n    toString() {\r\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\r\n        return `ChildActivationEnd(path: '${path}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the start of the activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ActivationEnd}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\r\nclass ActivationStart {\r\n    snapshot;\r\n    type = EventType.ActivationStart;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot) {\r\n        this.snapshot = snapshot;\r\n    }\r\n    toString() {\r\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\r\n        return `ActivationStart(path: '${path}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered at the end of the activation part\r\n * of the Resolve phase of routing.\r\n * @see {@link ActivationStart}\r\n * @see {@link ResolveStart}\r\n *\r\n * @publicApi\r\n */\r\nclass ActivationEnd {\r\n    snapshot;\r\n    type = EventType.ActivationEnd;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    snapshot) {\r\n        this.snapshot = snapshot;\r\n    }\r\n    toString() {\r\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\r\n        return `ActivationEnd(path: '${path}')`;\r\n    }\r\n}\r\n/**\r\n * An event triggered by scrolling.\r\n *\r\n * @publicApi\r\n */\r\nclass Scroll {\r\n    routerEvent;\r\n    position;\r\n    anchor;\r\n    type = EventType.Scroll;\r\n    constructor(\r\n    /** @docsNotRequired */\r\n    routerEvent, \r\n    /** @docsNotRequired */\r\n    position, \r\n    /** @docsNotRequired */\r\n    anchor) {\r\n        this.routerEvent = routerEvent;\r\n        this.position = position;\r\n        this.anchor = anchor;\r\n    }\r\n    toString() {\r\n        const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\r\n        return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\r\n    }\r\n}\r\nclass BeforeActivateRoutes {\r\n}\r\nclass RedirectRequest {\r\n    url;\r\n    navigationBehaviorOptions;\r\n    constructor(url, navigationBehaviorOptions) {\r\n        this.url = url;\r\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\r\n    }\r\n}\r\nfunction stringifyEvent(routerEvent) {\r\n    switch (routerEvent.type) {\r\n        case EventType.ActivationEnd:\r\n            return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\r\n        case EventType.ActivationStart:\r\n            return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\r\n        case EventType.ChildActivationEnd:\r\n            return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\r\n        case EventType.ChildActivationStart:\r\n            return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\r\n        case EventType.GuardsCheckEnd:\r\n            return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\r\n        case EventType.GuardsCheckStart:\r\n            return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\r\n        case EventType.NavigationCancel:\r\n            return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\r\n        case EventType.NavigationSkipped:\r\n            return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\r\n        case EventType.NavigationEnd:\r\n            return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\r\n        case EventType.NavigationError:\r\n            return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\r\n        case EventType.NavigationStart:\r\n            return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\r\n        case EventType.ResolveEnd:\r\n            return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\r\n        case EventType.ResolveStart:\r\n            return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\r\n        case EventType.RouteConfigLoadEnd:\r\n            return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\r\n        case EventType.RouteConfigLoadStart:\r\n            return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\r\n        case EventType.RoutesRecognized:\r\n            return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\r\n        case EventType.Scroll:\r\n            const pos = routerEvent.position\r\n                ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\r\n                : null;\r\n            return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\r\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\r\n * `currentInjector`.\r\n *\r\n * @param route The route that might have providers\r\n * @param currentInjector The parent injector of the `Route`\r\n */\r\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\r\n    if (route.providers && !route._injector) {\r\n        route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\r\n    }\r\n    return route._injector ?? currentInjector;\r\n}\r\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\r\n    // forEach doesn't iterate undefined values\r\n    for (let i = 0; i < config.length; i++) {\r\n        const route = config[i];\r\n        const fullPath = getFullPath(parentPath, route);\r\n        validateNode(route, fullPath, requireStandaloneComponents);\r\n    }\r\n}\r\nfunction assertStandalone(fullPath, component) {\r\n    if (component && _isNgModule(component)) {\r\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\r\n            `but it must be used with standalone components. Use 'loadChildren' instead.`);\r\n    }\r\n    else if (component && !isStandalone(component)) {\r\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\r\n    }\r\n}\r\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\r\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n        if (!route) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `\r\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\r\n      The reason might be an extra comma.\r\n\r\n      Example:\r\n      const routes: Routes = [\r\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\r\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\r\n        { path: 'detail/:id', component: HeroDetailComponent }\r\n      ];\r\n    `);\r\n        }\r\n        if (Array.isArray(route)) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\r\n        }\r\n        if (!route.redirectTo &&\r\n            !route.component &&\r\n            !route.loadComponent &&\r\n            !route.children &&\r\n            !route.loadChildren &&\r\n            route.outlet &&\r\n            route.outlet !== PRIMARY_OUTLET) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\r\n        }\r\n        if (route.redirectTo && route.children) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\r\n        }\r\n        if (route.redirectTo && route.loadChildren) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\r\n        }\r\n        if (route.children && route.loadChildren) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\r\n        }\r\n        if (route.redirectTo && (route.component || route.loadComponent)) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\r\n        }\r\n        if (route.component && route.loadComponent) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\r\n        }\r\n        if (route.redirectTo && route.canActivate) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation ` +\r\n                `so canActivate will never be executed.`);\r\n        }\r\n        if (route.path && route.matcher) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\r\n        }\r\n        if (route.redirectTo === void 0 &&\r\n            !route.component &&\r\n            !route.loadComponent &&\r\n            !route.children &&\r\n            !route.loadChildren) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\r\n        }\r\n        if (route.path === void 0 && route.matcher === void 0) {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\r\n        }\r\n        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\r\n        }\r\n        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\r\n            const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\r\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\r\n        }\r\n        if (requireStandaloneComponents) {\r\n            assertStandalone(fullPath, route.component);\r\n        }\r\n    }\r\n    if (route.children) {\r\n        validateConfig(route.children, fullPath, requireStandaloneComponents);\r\n    }\r\n}\r\nfunction getFullPath(parentPath, currentRoute) {\r\n    if (!currentRoute) {\r\n        return parentPath;\r\n    }\r\n    if (!parentPath && !currentRoute.path) {\r\n        return '';\r\n    }\r\n    else if (parentPath && !currentRoute.path) {\r\n        return `${parentPath}/`;\r\n    }\r\n    else if (!parentPath && currentRoute.path) {\r\n        return currentRoute.path;\r\n    }\r\n    else {\r\n        return `${parentPath}/${currentRoute.path}`;\r\n    }\r\n}\r\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\r\nfunction getOutlet(route) {\r\n    return route.outlet || PRIMARY_OUTLET;\r\n}\r\n/**\r\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\r\n * The order of the configs is otherwise preserved.\r\n */\r\nfunction sortByMatchingOutlets(routes, outletName) {\r\n    const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\r\n    sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\r\n    return sortedConfig;\r\n}\r\n/**\r\n * Gets the first injector in the snapshot's parent tree.\r\n *\r\n * If the `Route` has a static list of providers, the returned injector will be the one created from\r\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\r\n * loaded config or their static providers.\r\n *\r\n * Returns `null` if there is neither this nor any parents have a stored injector.\r\n *\r\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\r\n * also used for getting the correct injector to use for creating components.\r\n */\r\nfunction getClosestRouteInjector(snapshot) {\r\n    if (!snapshot)\r\n        return null;\r\n    // If the current route has its own injector, which is created from the static providers on the\r\n    // route itself, we should use that. Otherwise, we start at the parent since we do not want to\r\n    // include the lazy loaded injector from this route.\r\n    if (snapshot.routeConfig?._injector) {\r\n        return snapshot.routeConfig._injector;\r\n    }\r\n    for (let s = snapshot.parent; s; s = s.parent) {\r\n        const route = s.routeConfig;\r\n        // Note that the order here is important. `_loadedInjector` stored on the route with\r\n        // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\r\n        // is created from the static providers on that parent route, so it applies to the children as\r\n        // well, but only if there is no lazy loaded NgModuleRef injector.\r\n        if (route?._loadedInjector)\r\n            return route._loadedInjector;\r\n        if (route?._injector)\r\n            return route._injector;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Store contextual information about a `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\r\nclass OutletContext {\r\n    rootInjector;\r\n    outlet = null;\r\n    route = null;\r\n    children;\r\n    attachRef = null;\r\n    get injector() {\r\n        return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\r\n    }\r\n    constructor(rootInjector) {\r\n        this.rootInjector = rootInjector;\r\n        this.children = new ChildrenOutletContexts(this.rootInjector);\r\n    }\r\n}\r\n/**\r\n * Store contextual information about the children (= nested) `RouterOutlet`\r\n *\r\n * @publicApi\r\n */\r\nclass ChildrenOutletContexts {\r\n    rootInjector;\r\n    // contexts for child outlets, by name.\r\n    contexts = new Map();\r\n    /** @docs-private */\r\n    constructor(rootInjector) {\r\n        this.rootInjector = rootInjector;\r\n    }\r\n    /** Called when a `RouterOutlet` directive is instantiated */\r\n    onChildOutletCreated(childName, outlet) {\r\n        const context = this.getOrCreateContext(childName);\r\n        context.outlet = outlet;\r\n        this.contexts.set(childName, context);\r\n    }\r\n    /**\r\n     * Called when a `RouterOutlet` directive is destroyed.\r\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\r\n     * re-created later.\r\n     */\r\n    onChildOutletDestroyed(childName) {\r\n        const context = this.getContext(childName);\r\n        if (context) {\r\n            context.outlet = null;\r\n            context.attachRef = null;\r\n        }\r\n    }\r\n    /**\r\n     * Called when the corresponding route is deactivated during navigation.\r\n     * Because the component get destroyed, all children outlet are destroyed.\r\n     */\r\n    onOutletDeactivated() {\r\n        const contexts = this.contexts;\r\n        this.contexts = new Map();\r\n        return contexts;\r\n    }\r\n    onOutletReAttached(contexts) {\r\n        this.contexts = contexts;\r\n    }\r\n    getOrCreateContext(childName) {\r\n        let context = this.getContext(childName);\r\n        if (!context) {\r\n            context = new OutletContext(this.rootInjector);\r\n            this.contexts.set(childName, context);\r\n        }\r\n        return context;\r\n    }\r\n    getContext(childName) {\r\n        return this.contexts.get(childName) || null;\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ChildrenOutletContexts, deps: [{ token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ChildrenOutletContexts, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ChildrenOutletContexts, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\r\n\r\nclass Tree {\r\n    /** @internal */\r\n    _root;\r\n    constructor(root) {\r\n        this._root = root;\r\n    }\r\n    get root() {\r\n        return this._root.value;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    parent(t) {\r\n        const p = this.pathFromRoot(t);\r\n        return p.length > 1 ? p[p.length - 2] : null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    children(t) {\r\n        const n = findNode(t, this._root);\r\n        return n ? n.children.map((t) => t.value) : [];\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    firstChild(t) {\r\n        const n = findNode(t, this._root);\r\n        return n && n.children.length > 0 ? n.children[0].value : null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    siblings(t) {\r\n        const p = findPath(t, this._root);\r\n        if (p.length < 2)\r\n            return [];\r\n        const c = p[p.length - 2].children.map((c) => c.value);\r\n        return c.filter((cc) => cc !== t);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    pathFromRoot(t) {\r\n        return findPath(t, this._root).map((s) => s.value);\r\n    }\r\n}\r\n// DFS for the node matching the value\r\nfunction findNode(value, node) {\r\n    if (value === node.value)\r\n        return node;\r\n    for (const child of node.children) {\r\n        const node = findNode(value, child);\r\n        if (node)\r\n            return node;\r\n    }\r\n    return null;\r\n}\r\n// Return the path to the node with the given value using DFS\r\nfunction findPath(value, node) {\r\n    if (value === node.value)\r\n        return [node];\r\n    for (const child of node.children) {\r\n        const path = findPath(value, child);\r\n        if (path.length) {\r\n            path.unshift(node);\r\n            return path;\r\n        }\r\n    }\r\n    return [];\r\n}\r\nclass TreeNode {\r\n    value;\r\n    children;\r\n    constructor(value, children) {\r\n        this.value = value;\r\n        this.children = children;\r\n    }\r\n    toString() {\r\n        return `TreeNode(${this.value})`;\r\n    }\r\n}\r\n// Return the list of T indexed by outlet name\r\nfunction nodeChildrenAsMap(node) {\r\n    const map = {};\r\n    if (node) {\r\n        node.children.forEach((child) => (map[child.value.outlet] = child));\r\n    }\r\n    return map;\r\n}\r\n\r\n/**\r\n * Represents the state of the router as a tree of activated routes.\r\n *\r\n * @usageNotes\r\n *\r\n * Every node in the route tree is an `ActivatedRoute` instance\r\n * that knows about the \"consumed\" URL segments, the extracted parameters,\r\n * and the resolved data.\r\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\r\n *\r\n * The following fragment shows how a component gets the root node\r\n * of the current state to establish its own route tree:\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const root: ActivatedRoute = state.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @see {@link ActivatedRoute}\r\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\r\n *\r\n * @publicApi\r\n */\r\nclass RouterState extends Tree {\r\n    snapshot;\r\n    /** @internal */\r\n    constructor(root, \r\n    /** The current snapshot of the router state */\r\n    snapshot) {\r\n        super(root);\r\n        this.snapshot = snapshot;\r\n        setRouterState(this, root);\r\n    }\r\n    toString() {\r\n        return this.snapshot.toString();\r\n    }\r\n}\r\nfunction createEmptyState(rootComponent) {\r\n    const snapshot = createEmptyStateSnapshot(rootComponent);\r\n    const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\r\n    const emptyParams = new BehaviorSubject({});\r\n    const emptyData = new BehaviorSubject({});\r\n    const emptyQueryParams = new BehaviorSubject({});\r\n    const fragment = new BehaviorSubject('');\r\n    const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\r\n    activated.snapshot = snapshot.root;\r\n    return new RouterState(new TreeNode(activated, []), snapshot);\r\n}\r\nfunction createEmptyStateSnapshot(rootComponent) {\r\n    const emptyParams = {};\r\n    const emptyData = {};\r\n    const emptyQueryParams = {};\r\n    const fragment = '';\r\n    const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\r\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\r\n}\r\n/**\r\n * Provides access to information about a route associated with a component\r\n * that is loaded in an outlet.\r\n * Use to traverse the `RouterState` tree and extract information from nodes.\r\n *\r\n * The following example shows how to construct a component using information from a\r\n * currently activated route.\r\n *\r\n * Note: the observables in this class only emit when the current and previous values differ based\r\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\r\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\r\n *\r\n * {@example router/activated-route/module.ts region=\"activated-route\"\r\n *     header=\"activated-route.component.ts\"}\r\n *\r\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\r\n *\r\n * @publicApi\r\n */\r\nclass ActivatedRoute {\r\n    urlSubject;\r\n    paramsSubject;\r\n    queryParamsSubject;\r\n    fragmentSubject;\r\n    dataSubject;\r\n    outlet;\r\n    component;\r\n    /** The current snapshot of this route */\r\n    snapshot;\r\n    /** @internal */\r\n    _futureSnapshot;\r\n    /** @internal */\r\n    _routerState;\r\n    /** @internal */\r\n    _paramMap;\r\n    /** @internal */\r\n    _queryParamMap;\r\n    /** An Observable of the resolved route title */\r\n    title;\r\n    /** An observable of the URL segments matched by this route. */\r\n    url;\r\n    /** An observable of the matrix parameters scoped to this route. */\r\n    params;\r\n    /** An observable of the query parameters shared by all the routes. */\r\n    queryParams;\r\n    /** An observable of the URL fragment shared by all the routes. */\r\n    fragment;\r\n    /** An observable of the static and resolved data of this route. */\r\n    data;\r\n    /** @internal */\r\n    constructor(\r\n    /** @internal */\r\n    urlSubject, \r\n    /** @internal */\r\n    paramsSubject, \r\n    /** @internal */\r\n    queryParamsSubject, \r\n    /** @internal */\r\n    fragmentSubject, \r\n    /** @internal */\r\n    dataSubject, \r\n    /** The outlet name of the route, a constant. */\r\n    outlet, \r\n    /** The component of the route, a constant. */\r\n    component, futureSnapshot) {\r\n        this.urlSubject = urlSubject;\r\n        this.paramsSubject = paramsSubject;\r\n        this.queryParamsSubject = queryParamsSubject;\r\n        this.fragmentSubject = fragmentSubject;\r\n        this.dataSubject = dataSubject;\r\n        this.outlet = outlet;\r\n        this.component = component;\r\n        this._futureSnapshot = futureSnapshot;\r\n        this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(undefined);\r\n        // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\r\n        this.url = urlSubject;\r\n        this.params = paramsSubject;\r\n        this.queryParams = queryParamsSubject;\r\n        this.fragment = fragmentSubject;\r\n        this.data = dataSubject;\r\n    }\r\n    /** The configuration used to match this route. */\r\n    get routeConfig() {\r\n        return this._futureSnapshot.routeConfig;\r\n    }\r\n    /** The root of the router state. */\r\n    get root() {\r\n        return this._routerState.root;\r\n    }\r\n    /** The parent of this route in the router state tree. */\r\n    get parent() {\r\n        return this._routerState.parent(this);\r\n    }\r\n    /** The first child of this route in the router state tree. */\r\n    get firstChild() {\r\n        return this._routerState.firstChild(this);\r\n    }\r\n    /** The children of this route in the router state tree. */\r\n    get children() {\r\n        return this._routerState.children(this);\r\n    }\r\n    /** The path from the root of the router state tree to this route. */\r\n    get pathFromRoot() {\r\n        return this._routerState.pathFromRoot(this);\r\n    }\r\n    /**\r\n     * An Observable that contains a map of the required and optional parameters\r\n     * specific to the route.\r\n     * The map supports retrieving single and multiple values from the same parameter.\r\n     */\r\n    get paramMap() {\r\n        this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));\r\n        return this._paramMap;\r\n    }\r\n    /**\r\n     * An Observable that contains a map of the query parameters available to all routes.\r\n     * The map supports retrieving single and multiple values from the query parameter.\r\n     */\r\n    get queryParamMap() {\r\n        this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));\r\n        return this._queryParamMap;\r\n    }\r\n    toString() {\r\n        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\r\n    }\r\n}\r\n/**\r\n * Returns the inherited params, data, and resolve for a given route.\r\n *\r\n * By default, we do not inherit parent data unless the current route is path-less or the parent\r\n * route is component-less.\r\n */\r\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\r\n    let inherited;\r\n    const { routeConfig } = route;\r\n    if (parent !== null &&\r\n        (paramsInheritanceStrategy === 'always' ||\r\n            // inherit parent data if route is empty path\r\n            routeConfig?.path === '' ||\r\n            // inherit parent data if parent was componentless\r\n            (!parent.component && !parent.routeConfig?.loadComponent))) {\r\n        inherited = {\r\n            params: { ...parent.params, ...route.params },\r\n            data: { ...parent.data, ...route.data },\r\n            resolve: {\r\n                // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\r\n                // change data because it's not frozen...\r\n                // This first line could be deleted chose to break/disallow mutating the `data` object in\r\n                // guards.\r\n                // Note that data from parents still override this mutated data so anyone relying on this\r\n                // might be surprised that it doesn't work if parent data is inherited but otherwise does.\r\n                ...route.data,\r\n                // Ensure inherited resolved data overrides inherited static data\r\n                ...parent.data,\r\n                // static data from the current route overrides any inherited data\r\n                ...routeConfig?.data,\r\n                // resolved data from current route overrides everything\r\n                ...route._resolvedData,\r\n            },\r\n        };\r\n    }\r\n    else {\r\n        inherited = {\r\n            params: { ...route.params },\r\n            data: { ...route.data },\r\n            resolve: { ...route.data, ...(route._resolvedData ?? {}) },\r\n        };\r\n    }\r\n    if (routeConfig && hasStaticTitle(routeConfig)) {\r\n        inherited.resolve[RouteTitleKey] = routeConfig.title;\r\n    }\r\n    return inherited;\r\n}\r\n/**\r\n * @description\r\n *\r\n * Contains the information about a route associated with a component loaded in an\r\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\r\n * traverse the router state tree.\r\n *\r\n * The following example initializes a component with route information extracted\r\n * from the snapshot of the root node at the time of creation.\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'./my-component.html'})\r\n * class MyComponent {\r\n *   constructor(route: ActivatedRoute) {\r\n *     const id: string = route.snapshot.params.id;\r\n *     const url: string = route.snapshot.url.join('');\r\n *     const user = route.snapshot.data.user;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass ActivatedRouteSnapshot {\r\n    url;\r\n    params;\r\n    queryParams;\r\n    fragment;\r\n    data;\r\n    outlet;\r\n    component;\r\n    /** The configuration used to match this route **/\r\n    routeConfig;\r\n    /** @internal */\r\n    _resolve;\r\n    /** @internal */\r\n    _resolvedData;\r\n    /** @internal */\r\n    _routerState;\r\n    /** @internal */\r\n    _paramMap;\r\n    /** @internal */\r\n    _queryParamMap;\r\n    /** The resolved route title */\r\n    get title() {\r\n        // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\r\n        // available at the time of class instantiation.\r\n        return this.data?.[RouteTitleKey];\r\n    }\r\n    /** @internal */\r\n    constructor(\r\n    /** The URL segments matched by this route */\r\n    url, \r\n    /**\r\n     *  The matrix parameters scoped to this route.\r\n     *\r\n     *  You can compute all params (or data) in the router state or to get params outside\r\n     *  of an activated component by traversing the `RouterState` tree as in the following\r\n     *  example:\r\n     *  ```ts\r\n     *  collectRouteParams(router: Router) {\r\n     *    let params = {};\r\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\r\n     *    while (stack.length > 0) {\r\n     *      const route = stack.pop()!;\r\n     *      params = {...params, ...route.params};\r\n     *      stack.push(...route.children);\r\n     *    }\r\n     *    return params;\r\n     *  }\r\n     *  ```\r\n     */\r\n    params, \r\n    /** The query parameters shared by all the routes */\r\n    queryParams, \r\n    /** The URL fragment shared by all the routes */\r\n    fragment, \r\n    /** The static and resolved data of this route */\r\n    data, \r\n    /** The outlet name of the route */\r\n    outlet, \r\n    /** The component of the route */\r\n    component, routeConfig, resolve) {\r\n        this.url = url;\r\n        this.params = params;\r\n        this.queryParams = queryParams;\r\n        this.fragment = fragment;\r\n        this.data = data;\r\n        this.outlet = outlet;\r\n        this.component = component;\r\n        this.routeConfig = routeConfig;\r\n        this._resolve = resolve;\r\n    }\r\n    /** The root of the router state */\r\n    get root() {\r\n        return this._routerState.root;\r\n    }\r\n    /** The parent of this route in the router state tree */\r\n    get parent() {\r\n        return this._routerState.parent(this);\r\n    }\r\n    /** The first child of this route in the router state tree */\r\n    get firstChild() {\r\n        return this._routerState.firstChild(this);\r\n    }\r\n    /** The children of this route in the router state tree */\r\n    get children() {\r\n        return this._routerState.children(this);\r\n    }\r\n    /** The path from the root of the router state tree to this route */\r\n    get pathFromRoot() {\r\n        return this._routerState.pathFromRoot(this);\r\n    }\r\n    get paramMap() {\r\n        this._paramMap ??= convertToParamMap(this.params);\r\n        return this._paramMap;\r\n    }\r\n    get queryParamMap() {\r\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\r\n        return this._queryParamMap;\r\n    }\r\n    toString() {\r\n        const url = this.url.map((segment) => segment.toString()).join('/');\r\n        const matched = this.routeConfig ? this.routeConfig.path : '';\r\n        return `Route(url:'${url}', path:'${matched}')`;\r\n    }\r\n}\r\n/**\r\n * @description\r\n *\r\n * Represents the state of the router at a moment in time.\r\n *\r\n * This is a tree of activated route snapshots. Every node in this tree knows about\r\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\r\n *\r\n * The following example shows how a component is initialized with information\r\n * from the snapshot of the root node's state at the time of creation.\r\n *\r\n * ```ts\r\n * @Component({templateUrl:'template.html'})\r\n * class MyComponent {\r\n *   constructor(router: Router) {\r\n *     const state: RouterState = router.routerState;\r\n *     const snapshot: RouterStateSnapshot = state.snapshot;\r\n *     const root: ActivatedRouteSnapshot = snapshot.root;\r\n *     const child = root.firstChild;\r\n *     const id: Observable<string> = child.params.map(p => p.id);\r\n *     //...\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass RouterStateSnapshot extends Tree {\r\n    url;\r\n    /** @internal */\r\n    constructor(\r\n    /** The url from which this snapshot was created */\r\n    url, root) {\r\n        super(root);\r\n        this.url = url;\r\n        setRouterState(this, root);\r\n    }\r\n    toString() {\r\n        return serializeNode(this._root);\r\n    }\r\n}\r\nfunction setRouterState(state, node) {\r\n    node.value._routerState = state;\r\n    node.children.forEach((c) => setRouterState(state, c));\r\n}\r\nfunction serializeNode(node) {\r\n    const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\r\n    return `${node.value}${c}`;\r\n}\r\n/**\r\n * The expectation is that the activate route is created with the right set of parameters.\r\n * So we push new values into the observables only when they are not the initial values.\r\n * And we detect that by checking if the snapshot field is set.\r\n */\r\nfunction advanceActivatedRoute(route) {\r\n    if (route.snapshot) {\r\n        const currentSnapshot = route.snapshot;\r\n        const nextSnapshot = route._futureSnapshot;\r\n        route.snapshot = nextSnapshot;\r\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\r\n            route.queryParamsSubject.next(nextSnapshot.queryParams);\r\n        }\r\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\r\n            route.fragmentSubject.next(nextSnapshot.fragment);\r\n        }\r\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\r\n            route.paramsSubject.next(nextSnapshot.params);\r\n        }\r\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\r\n            route.urlSubject.next(nextSnapshot.url);\r\n        }\r\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\r\n            route.dataSubject.next(nextSnapshot.data);\r\n        }\r\n    }\r\n    else {\r\n        route.snapshot = route._futureSnapshot;\r\n        // this is for resolved data\r\n        route.dataSubject.next(route._futureSnapshot.data);\r\n    }\r\n}\r\nfunction equalParamsAndUrlSegments(a, b) {\r\n    const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\r\n    const parentsMismatch = !a.parent !== !b.parent;\r\n    return (equalUrlParams &&\r\n        !parentsMismatch &&\r\n        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent)));\r\n}\r\nfunction hasStaticTitle(config) {\r\n    return typeof config.title === 'string' || config.title === null;\r\n}\r\n\r\n/**\r\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\r\n * input.\r\n *\r\n * When unset, this value is `null` by default.\r\n *\r\n * @usageNotes\r\n *\r\n * To set the data from the template of the component with `router-outlet`:\r\n * ```html\r\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\r\n * ```\r\n *\r\n * To read the data in the routed component:\r\n * ```ts\r\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nconst ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? 'RouterOutlet data' : '');\r\n/**\r\n * @description\r\n *\r\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\r\n *\r\n * Each outlet can have a unique name, determined by the optional `name` attribute.\r\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\r\n *\r\n * ```html\r\n * <router-outlet></router-outlet>\r\n * <router-outlet name='left'></router-outlet>\r\n * <router-outlet name='right'></router-outlet>\r\n * ```\r\n *\r\n * Named outlets can be the targets of secondary routes.\r\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\r\n *\r\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\r\n *\r\n * Using named outlets and secondary routes, you can target multiple outlets in\r\n * the same `RouterLink` directive.\r\n *\r\n * The router keeps track of separate branches in a navigation tree for each named outlet and\r\n * generates a representation of that tree in the URL.\r\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\r\n * routes at the same time:\r\n *\r\n * `http://base-path/primary-route-path(outlet-name:route-path)`\r\n *\r\n * A router outlet emits an activate event when a new component is instantiated,\r\n * deactivate event when a component is destroyed.\r\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\r\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\r\n * detach the subtree.\r\n *\r\n * ```html\r\n * <router-outlet\r\n *   (activate)='onActivate($event)'\r\n *   (deactivate)='onDeactivate($event)'\r\n *   (attach)='onAttach($event)'\r\n *   (detach)='onDetach($event)'></router-outlet>\r\n * ```\r\n *\r\n * @see {@link RouterLink}\r\n * @see {@link Route}\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nclass RouterOutlet {\r\n    activated = null;\r\n    /** @internal */\r\n    get activatedComponentRef() {\r\n        return this.activated;\r\n    }\r\n    _activatedRoute = null;\r\n    /**\r\n     * The name of the outlet\r\n     *\r\n     */\r\n    name = PRIMARY_OUTLET;\r\n    activateEvents = new EventEmitter();\r\n    deactivateEvents = new EventEmitter();\r\n    /**\r\n     * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\r\n     * previously detached subtree.\r\n     **/\r\n    attachEvents = new EventEmitter();\r\n    /**\r\n     * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\r\n     * subtree.\r\n     */\r\n    detachEvents = new EventEmitter();\r\n    /**\r\n     * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\r\n     *\r\n     * When unset, the value of the token is `undefined` by default.\r\n     */\r\n    routerOutletData = input(undefined);\r\n    parentContexts = inject(ChildrenOutletContexts);\r\n    location = inject(ViewContainerRef);\r\n    changeDetector = inject(ChangeDetectorRef);\r\n    inputBinder = inject(INPUT_BINDER, { optional: true });\r\n    /** @docs-private */\r\n    supportsBindingToComponentInputs = true;\r\n    /** @docs-private */\r\n    ngOnChanges(changes) {\r\n        if (changes['name']) {\r\n            const { firstChange, previousValue } = changes['name'];\r\n            if (firstChange) {\r\n                // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\r\n                // input is set at all, we need to centrally handle the first change there.\r\n                return;\r\n            }\r\n            // unregister with the old name\r\n            if (this.isTrackedInParentContexts(previousValue)) {\r\n                this.deactivate();\r\n                this.parentContexts.onChildOutletDestroyed(previousValue);\r\n            }\r\n            // register the new name\r\n            this.initializeOutletWithName();\r\n        }\r\n    }\r\n    /** @docs-private */\r\n    ngOnDestroy() {\r\n        // Ensure that the registered outlet is this one before removing it on the context.\r\n        if (this.isTrackedInParentContexts(this.name)) {\r\n            this.parentContexts.onChildOutletDestroyed(this.name);\r\n        }\r\n        this.inputBinder?.unsubscribeFromRouteData(this);\r\n    }\r\n    isTrackedInParentContexts(outletName) {\r\n        return this.parentContexts.getContext(outletName)?.outlet === this;\r\n    }\r\n    /** @docs-private */\r\n    ngOnInit() {\r\n        this.initializeOutletWithName();\r\n    }\r\n    initializeOutletWithName() {\r\n        this.parentContexts.onChildOutletCreated(this.name, this);\r\n        if (this.activated) {\r\n            return;\r\n        }\r\n        // If the outlet was not instantiated at the time the route got activated we need to populate\r\n        // the outlet when it is initialized (ie inside a NgIf)\r\n        const context = this.parentContexts.getContext(this.name);\r\n        if (context?.route) {\r\n            if (context.attachRef) {\r\n                // `attachRef` is populated when there is an existing component to mount\r\n                this.attach(context.attachRef, context.route);\r\n            }\r\n            else {\r\n                // otherwise the component defined in the configuration is created\r\n                this.activateWith(context.route, context.injector);\r\n            }\r\n        }\r\n    }\r\n    get isActivated() {\r\n        return !!this.activated;\r\n    }\r\n    /**\r\n     * @returns The currently activated component instance.\r\n     * @throws An error if the outlet is not activated.\r\n     */\r\n    get component() {\r\n        if (!this.activated)\r\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\r\n        return this.activated.instance;\r\n    }\r\n    get activatedRoute() {\r\n        if (!this.activated)\r\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\r\n        return this._activatedRoute;\r\n    }\r\n    get activatedRouteData() {\r\n        if (this._activatedRoute) {\r\n            return this._activatedRoute.snapshot.data;\r\n        }\r\n        return {};\r\n    }\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\r\n     */\r\n    detach() {\r\n        if (!this.activated)\r\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\r\n        this.location.detach();\r\n        const cmp = this.activated;\r\n        this.activated = null;\r\n        this._activatedRoute = null;\r\n        this.detachEvents.emit(cmp.instance);\r\n        return cmp;\r\n    }\r\n    /**\r\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\r\n     */\r\n    attach(ref, activatedRoute) {\r\n        this.activated = ref;\r\n        this._activatedRoute = activatedRoute;\r\n        this.location.insert(ref.hostView);\r\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\r\n        this.attachEvents.emit(ref.instance);\r\n    }\r\n    deactivate() {\r\n        if (this.activated) {\r\n            const c = this.component;\r\n            this.activated.destroy();\r\n            this.activated = null;\r\n            this._activatedRoute = null;\r\n            this.deactivateEvents.emit(c);\r\n        }\r\n    }\r\n    activateWith(activatedRoute, environmentInjector) {\r\n        if (this.isActivated) {\r\n            throw new _RuntimeError(4013 /* RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                'Cannot activate an already activated outlet');\r\n        }\r\n        this._activatedRoute = activatedRoute;\r\n        const location = this.location;\r\n        const snapshot = activatedRoute.snapshot;\r\n        const component = snapshot.component;\r\n        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\r\n        const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\r\n        this.activated = location.createComponent(component, {\r\n            index: location.length,\r\n            injector,\r\n            environmentInjector: environmentInjector,\r\n        });\r\n        // Calling `markForCheck` to make sure we will run the change detection when the\r\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\r\n        this.changeDetector.markForCheck();\r\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\r\n        this.activateEvents.emit(this.activated.instance);\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouterOutlet, deps: [], target: i0.ɵɵFactoryTarget.Directive });\r\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"17.1.0\", version: \"19.2.15\", type: RouterOutlet, isStandalone: true, selector: \"router-outlet\", inputs: { name: { classPropertyName: \"name\", publicName: \"name\", isSignal: false, isRequired: false, transformFunction: null }, routerOutletData: { classPropertyName: \"routerOutletData\", publicName: \"routerOutletData\", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { activateEvents: \"activate\", deactivateEvents: \"deactivate\", attachEvents: \"attach\", detachEvents: \"detach\" }, exportAs: [\"outlet\"], usesOnChanges: true, ngImport: i0 });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouterOutlet, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'router-outlet',\r\n                    exportAs: 'outlet',\r\n                }]\r\n        }], propDecorators: { name: [{\r\n                type: Input\r\n            }], activateEvents: [{\r\n                type: Output,\r\n                args: ['activate']\r\n            }], deactivateEvents: [{\r\n                type: Output,\r\n                args: ['deactivate']\r\n            }], attachEvents: [{\r\n                type: Output,\r\n                args: ['attach']\r\n            }], detachEvents: [{\r\n                type: Output,\r\n                args: ['detach']\r\n            }] } });\r\nclass OutletInjector {\r\n    route;\r\n    childContexts;\r\n    parent;\r\n    outletData;\r\n    constructor(route, childContexts, parent, outletData) {\r\n        this.route = route;\r\n        this.childContexts = childContexts;\r\n        this.parent = parent;\r\n        this.outletData = outletData;\r\n    }\r\n    get(token, notFoundValue) {\r\n        if (token === ActivatedRoute) {\r\n            return this.route;\r\n        }\r\n        if (token === ChildrenOutletContexts) {\r\n            return this.childContexts;\r\n        }\r\n        if (token === ROUTER_OUTLET_DATA) {\r\n            return this.outletData;\r\n        }\r\n        return this.parent.get(token, notFoundValue);\r\n    }\r\n}\r\nconst INPUT_BINDER = new InjectionToken('');\r\n/**\r\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\r\n * inputs.\r\n *\r\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\r\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\r\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\r\n * Importantly, when an input does not have an item in the route data with a matching key, this\r\n * input is set to `undefined`. If it were not done this way, the previous information would be\r\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\r\n *\r\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\r\n * the subscriptions are cleaned up.\r\n */\r\nclass RoutedComponentInputBinder {\r\n    outletDataSubscriptions = new Map();\r\n    bindActivatedRouteToOutletComponent(outlet) {\r\n        this.unsubscribeFromRouteData(outlet);\r\n        this.subscribeToRouteData(outlet);\r\n    }\r\n    unsubscribeFromRouteData(outlet) {\r\n        this.outletDataSubscriptions.get(outlet)?.unsubscribe();\r\n        this.outletDataSubscriptions.delete(outlet);\r\n    }\r\n    subscribeToRouteData(outlet) {\r\n        const { activatedRoute } = outlet;\r\n        const dataSubscription = combineLatest([\r\n            activatedRoute.queryParams,\r\n            activatedRoute.params,\r\n            activatedRoute.data,\r\n        ])\r\n            .pipe(switchMap(([queryParams, params, data], index) => {\r\n            data = { ...queryParams, ...params, ...data };\r\n            // Get the first result from the data subscription synchronously so it's available to\r\n            // the component as soon as possible (and doesn't require a second change detection).\r\n            if (index === 0) {\r\n                return of(data);\r\n            }\r\n            // Promise.resolve is used to avoid synchronously writing the wrong data when\r\n            // two of the Observables in the `combineLatest` stream emit one after\r\n            // another.\r\n            return Promise.resolve(data);\r\n        }))\r\n            .subscribe((data) => {\r\n            // Outlet may have been deactivated or changed names to be associated with a different\r\n            // route\r\n            if (!outlet.isActivated ||\r\n                !outlet.activatedComponentRef ||\r\n                outlet.activatedRoute !== activatedRoute ||\r\n                activatedRoute.component === null) {\r\n                this.unsubscribeFromRouteData(outlet);\r\n                return;\r\n            }\r\n            const mirror = reflectComponentType(activatedRoute.component);\r\n            if (!mirror) {\r\n                this.unsubscribeFromRouteData(outlet);\r\n                return;\r\n            }\r\n            for (const { templateName } of mirror.inputs) {\r\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\r\n            }\r\n        });\r\n        this.outletDataSubscriptions.set(outlet, dataSubscription);\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RoutedComponentInputBinder, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RoutedComponentInputBinder });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RoutedComponentInputBinder, decorators: [{\r\n            type: Injectable\r\n        }] });\r\n\r\n/**\r\n * This component is used internally within the router to be a placeholder when an empty\r\n * router-outlet is needed. For example, with a config such as:\r\n *\r\n * `{path: 'parent', outlet: 'nav', children: [...]}`\r\n *\r\n * In order to render, there needs to be a component on this config, which will default\r\n * to this `EmptyOutletComponent`.\r\n */\r\nclass ɵEmptyOutletComponent {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ɵEmptyOutletComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\r\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"19.2.15\", type: ɵEmptyOutletComponent, isStandalone: true, selector: \"ng-component\", exportAs: [\"emptyRouterOutlet\"], ngImport: i0, template: `<router-outlet/>`, isInline: true, dependencies: [{ kind: \"directive\", type: RouterOutlet, selector: \"router-outlet\", inputs: [\"name\", \"routerOutletData\"], outputs: [\"activate\", \"deactivate\", \"attach\", \"detach\"], exportAs: [\"outlet\"] }] });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: ɵEmptyOutletComponent, decorators: [{\r\n            type: Component,\r\n            args: [{\r\n                    template: `<router-outlet/>`,\r\n                    imports: [RouterOutlet],\r\n                    // Used to avoid component ID collisions with user code.\r\n                    exportAs: 'emptyRouterOutlet',\r\n                }]\r\n        }] });\r\n/**\r\n * Makes a copy of the config and adds any default required properties.\r\n */\r\nfunction standardizeConfig(r) {\r\n    const children = r.children && r.children.map(standardizeConfig);\r\n    const c = children ? { ...r, children } : { ...r };\r\n    if (!c.component &&\r\n        !c.loadComponent &&\r\n        (children || c.loadChildren) &&\r\n        c.outlet &&\r\n        c.outlet !== PRIMARY_OUTLET) {\r\n        c.component = ɵEmptyOutletComponent;\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\r\n    const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\r\n    return new RouterState(root, curr);\r\n}\r\nfunction createNode(routeReuseStrategy, curr, prevState) {\r\n    // reuse an activated route that is currently displayed on the screen\r\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\r\n        const value = prevState.value;\r\n        value._futureSnapshot = curr.value;\r\n        const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\r\n        return new TreeNode(value, children);\r\n    }\r\n    else {\r\n        if (routeReuseStrategy.shouldAttach(curr.value)) {\r\n            // retrieve an activated route that is used to be displayed, but is not currently displayed\r\n            const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\r\n            if (detachedRouteHandle !== null) {\r\n                const tree = detachedRouteHandle.route;\r\n                tree.value._futureSnapshot = curr.value;\r\n                tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\r\n                return tree;\r\n            }\r\n        }\r\n        const value = createActivatedRoute(curr.value);\r\n        const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\r\n        return new TreeNode(value, children);\r\n    }\r\n}\r\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\r\n    return curr.children.map((child) => {\r\n        for (const p of prevState.children) {\r\n            if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\r\n                return createNode(routeReuseStrategy, child, p);\r\n            }\r\n        }\r\n        return createNode(routeReuseStrategy, child);\r\n    });\r\n}\r\nfunction createActivatedRoute(c) {\r\n    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\r\n}\r\n\r\n/**\r\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\r\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\r\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\r\n * about _how_ to perform the navigation.\r\n *\r\n * ```ts\r\n * const route: Route = {\r\n *   path: \"user/:userId\",\r\n *   component: User,\r\n *   canActivate: [\r\n *     () => {\r\n *       const router = inject(Router);\r\n *       const authService = inject(AuthenticationService);\r\n *\r\n *       if (!authService.isLoggedIn()) {\r\n *         const loginPath = router.parseUrl(\"/login\");\r\n *         return new RedirectCommand(loginPath, {\r\n *           skipLocationChange: \"true\",\r\n *         });\r\n *       }\r\n *\r\n *       return true;\r\n *     },\r\n *   ],\r\n * };\r\n * ```\r\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\r\n *\r\n * @publicApi\r\n */\r\nclass RedirectCommand {\r\n    redirectTo;\r\n    navigationBehaviorOptions;\r\n    constructor(redirectTo, navigationBehaviorOptions) {\r\n        this.redirectTo = redirectTo;\r\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\r\n    }\r\n}\r\n\r\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\r\nfunction redirectingNavigationError(urlSerializer, redirect) {\r\n    const { redirectTo, navigationBehaviorOptions } = isUrlTree(redirect)\r\n        ? { redirectTo: redirect, navigationBehaviorOptions: undefined }\r\n        : redirect;\r\n    const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\r\n    error.url = redirectTo;\r\n    error.navigationBehaviorOptions = navigationBehaviorOptions;\r\n    return error;\r\n}\r\nfunction navigationCancelingError(message, code) {\r\n    const error = new Error(`NavigationCancelingError: ${message || ''}`);\r\n    error[NAVIGATION_CANCELING_ERROR] = true;\r\n    error.cancellationCode = code;\r\n    return error;\r\n}\r\nfunction isRedirectingNavigationCancelingError(error) {\r\n    return (isNavigationCancelingError(error) &&\r\n        isUrlTree(error.url));\r\n}\r\nfunction isNavigationCancelingError(error) {\r\n    return !!error && error[NAVIGATION_CANCELING_ERROR];\r\n}\r\n\r\nlet warnedAboutUnsupportedInputBinding = false;\r\nconst activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {\r\n    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\r\n    return t;\r\n});\r\nclass ActivateRoutes {\r\n    routeReuseStrategy;\r\n    futureState;\r\n    currState;\r\n    forwardEvent;\r\n    inputBindingEnabled;\r\n    constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\r\n        this.routeReuseStrategy = routeReuseStrategy;\r\n        this.futureState = futureState;\r\n        this.currState = currState;\r\n        this.forwardEvent = forwardEvent;\r\n        this.inputBindingEnabled = inputBindingEnabled;\r\n    }\r\n    activate(parentContexts) {\r\n        const futureRoot = this.futureState._root;\r\n        const currRoot = this.currState ? this.currState._root : null;\r\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\r\n        advanceActivatedRoute(this.futureState.root);\r\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\r\n    }\r\n    // De-activate the child route that are not re-used for the future state\r\n    deactivateChildRoutes(futureNode, currNode, contexts) {\r\n        const children = nodeChildrenAsMap(currNode);\r\n        // Recurse on the routes active in the future state to de-activate deeper children\r\n        futureNode.children.forEach((futureChild) => {\r\n            const childOutletName = futureChild.value.outlet;\r\n            this.deactivateRoutes(futureChild, children[childOutletName], contexts);\r\n            delete children[childOutletName];\r\n        });\r\n        // De-activate the routes that will not be re-used\r\n        Object.values(children).forEach((v) => {\r\n            this.deactivateRouteAndItsChildren(v, contexts);\r\n        });\r\n    }\r\n    deactivateRoutes(futureNode, currNode, parentContext) {\r\n        const future = futureNode.value;\r\n        const curr = currNode ? currNode.value : null;\r\n        if (future === curr) {\r\n            // Reusing the node, check to see if the children need to be de-activated\r\n            if (future.component) {\r\n                // If we have a normal route, we need to go through an outlet.\r\n                const context = parentContext.getContext(future.outlet);\r\n                if (context) {\r\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\r\n                }\r\n            }\r\n            else {\r\n                // if we have a componentless route, we recurse but keep the same outlet map.\r\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\r\n            }\r\n        }\r\n        else {\r\n            if (curr) {\r\n                // Deactivate the current route which will not be re-used\r\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\r\n            }\r\n        }\r\n    }\r\n    deactivateRouteAndItsChildren(route, parentContexts) {\r\n        // If there is no component, the Route is never attached to an outlet (because there is no\r\n        // component to attach).\r\n        if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\r\n            this.detachAndStoreRouteSubtree(route, parentContexts);\r\n        }\r\n        else {\r\n            this.deactivateRouteAndOutlet(route, parentContexts);\r\n        }\r\n    }\r\n    detachAndStoreRouteSubtree(route, parentContexts) {\r\n        const context = parentContexts.getContext(route.value.outlet);\r\n        const contexts = context && route.value.component ? context.children : parentContexts;\r\n        const children = nodeChildrenAsMap(route);\r\n        for (const treeNode of Object.values(children)) {\r\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\r\n        }\r\n        if (context && context.outlet) {\r\n            const componentRef = context.outlet.detach();\r\n            const contexts = context.children.onOutletDeactivated();\r\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef, route, contexts });\r\n        }\r\n    }\r\n    deactivateRouteAndOutlet(route, parentContexts) {\r\n        const context = parentContexts.getContext(route.value.outlet);\r\n        // The context could be `null` if we are on a componentless route but there may still be\r\n        // children that need deactivating.\r\n        const contexts = context && route.value.component ? context.children : parentContexts;\r\n        const children = nodeChildrenAsMap(route);\r\n        for (const treeNode of Object.values(children)) {\r\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\r\n        }\r\n        if (context) {\r\n            if (context.outlet) {\r\n                // Destroy the component\r\n                context.outlet.deactivate();\r\n                // Destroy the contexts for all the outlets that were in the component\r\n                context.children.onOutletDeactivated();\r\n            }\r\n            // Clear the information about the attached component on the context but keep the reference to\r\n            // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\r\n            // info\r\n            context.attachRef = null;\r\n            context.route = null;\r\n        }\r\n    }\r\n    activateChildRoutes(futureNode, currNode, contexts) {\r\n        const children = nodeChildrenAsMap(currNode);\r\n        futureNode.children.forEach((c) => {\r\n            this.activateRoutes(c, children[c.value.outlet], contexts);\r\n            this.forwardEvent(new ActivationEnd(c.value.snapshot));\r\n        });\r\n        if (futureNode.children.length) {\r\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\r\n        }\r\n    }\r\n    activateRoutes(futureNode, currNode, parentContexts) {\r\n        const future = futureNode.value;\r\n        const curr = currNode ? currNode.value : null;\r\n        advanceActivatedRoute(future);\r\n        // reusing the node\r\n        if (future === curr) {\r\n            if (future.component) {\r\n                // If we have a normal route, we need to go through an outlet.\r\n                const context = parentContexts.getOrCreateContext(future.outlet);\r\n                this.activateChildRoutes(futureNode, currNode, context.children);\r\n            }\r\n            else {\r\n                // if we have a componentless route, we recurse but keep the same outlet map.\r\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\r\n            }\r\n        }\r\n        else {\r\n            if (future.component) {\r\n                // if we have a normal route, we need to place the component into the outlet and recurse.\r\n                const context = parentContexts.getOrCreateContext(future.outlet);\r\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\r\n                    const stored = (this.routeReuseStrategy.retrieve(future.snapshot));\r\n                    this.routeReuseStrategy.store(future.snapshot, null);\r\n                    context.children.onOutletReAttached(stored.contexts);\r\n                    context.attachRef = stored.componentRef;\r\n                    context.route = stored.route.value;\r\n                    if (context.outlet) {\r\n                        // Attach right away when the outlet has already been instantiated\r\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\r\n                        context.outlet.attach(stored.componentRef, stored.route.value);\r\n                    }\r\n                    advanceActivatedRoute(stored.route.value);\r\n                    this.activateChildRoutes(futureNode, null, context.children);\r\n                }\r\n                else {\r\n                    context.attachRef = null;\r\n                    context.route = future;\r\n                    if (context.outlet) {\r\n                        // Activate the outlet when it has already been instantiated\r\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\r\n                        context.outlet.activateWith(future, context.injector);\r\n                    }\r\n                    this.activateChildRoutes(futureNode, null, context.children);\r\n                }\r\n            }\r\n            else {\r\n                // if we have a componentless route, we recurse but keep the same outlet map.\r\n                this.activateChildRoutes(futureNode, null, parentContexts);\r\n            }\r\n        }\r\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n            const context = parentContexts.getOrCreateContext(future.outlet);\r\n            const outlet = context.outlet;\r\n            if (outlet &&\r\n                this.inputBindingEnabled &&\r\n                !outlet.supportsBindingToComponentInputs &&\r\n                !warnedAboutUnsupportedInputBinding) {\r\n                console.warn(`'withComponentInputBinding' feature is enabled but ` +\r\n                    `this application is using an outlet that may not support binding to component inputs.`);\r\n                warnedAboutUnsupportedInputBinding = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass CanActivate {\r\n    path;\r\n    route;\r\n    constructor(path) {\r\n        this.path = path;\r\n        this.route = this.path[this.path.length - 1];\r\n    }\r\n}\r\nclass CanDeactivate {\r\n    component;\r\n    route;\r\n    constructor(component, route) {\r\n        this.component = component;\r\n        this.route = route;\r\n    }\r\n}\r\nfunction getAllRouteGuards(future, curr, parentContexts) {\r\n    const futureRoot = future._root;\r\n    const currRoot = curr ? curr._root : null;\r\n    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\r\n}\r\nfunction getCanActivateChild(p) {\r\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\r\n    if (!canActivateChild || canActivateChild.length === 0)\r\n        return null;\r\n    return { node: p, guards: canActivateChild };\r\n}\r\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\r\n    const NOT_FOUND = Symbol();\r\n    const result = injector.get(tokenOrFunction, NOT_FOUND);\r\n    if (result === NOT_FOUND) {\r\n        if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\r\n            // We think the token is just a function so return it as-is\r\n            return tokenOrFunction;\r\n        }\r\n        else {\r\n            // This will throw the not found error\r\n            return injector.get(tokenOrFunction);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\r\n    canDeactivateChecks: [],\r\n    canActivateChecks: [],\r\n}) {\r\n    const prevChildren = nodeChildrenAsMap(currNode);\r\n    // Process the children of the future route\r\n    futureNode.children.forEach((c) => {\r\n        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\r\n        delete prevChildren[c.value.outlet];\r\n    });\r\n    // Process any children left from the current route (not active for the future route)\r\n    Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\r\n    return checks;\r\n}\r\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\r\n    canDeactivateChecks: [],\r\n    canActivateChecks: [],\r\n}) {\r\n    const future = futureNode.value;\r\n    const curr = currNode ? currNode.value : null;\r\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\r\n    // reusing the node\r\n    if (curr && future.routeConfig === curr.routeConfig) {\r\n        const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\r\n        if (shouldRun) {\r\n            checks.canActivateChecks.push(new CanActivate(futurePath));\r\n        }\r\n        else {\r\n            // we need to set the data\r\n            future.data = curr.data;\r\n            future._resolvedData = curr._resolvedData;\r\n        }\r\n        // If we have a component, we need to go through an outlet.\r\n        if (future.component) {\r\n            getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\r\n            // if we have a componentless route, we recurse but keep the same outlet map.\r\n        }\r\n        else {\r\n            getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\r\n        }\r\n        if (shouldRun && context && context.outlet && context.outlet.isActivated) {\r\n            checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\r\n        }\r\n    }\r\n    else {\r\n        if (curr) {\r\n            deactivateRouteAndItsChildren(currNode, context, checks);\r\n        }\r\n        checks.canActivateChecks.push(new CanActivate(futurePath));\r\n        // If we have a component, we need to go through an outlet.\r\n        if (future.component) {\r\n            getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\r\n            // if we have a componentless route, we recurse but keep the same outlet map.\r\n        }\r\n        else {\r\n            getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\r\n        }\r\n    }\r\n    return checks;\r\n}\r\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\r\n    if (typeof mode === 'function') {\r\n        return mode(curr, future);\r\n    }\r\n    switch (mode) {\r\n        case 'pathParamsChange':\r\n            return !equalPath(curr.url, future.url);\r\n        case 'pathParamsOrQueryParamsChange':\r\n            return (!equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams));\r\n        case 'always':\r\n            return true;\r\n        case 'paramsOrQueryParamsChange':\r\n            return (!equalParamsAndUrlSegments(curr, future) ||\r\n                !shallowEqual(curr.queryParams, future.queryParams));\r\n        case 'paramsChange':\r\n        default:\r\n            return !equalParamsAndUrlSegments(curr, future);\r\n    }\r\n}\r\nfunction deactivateRouteAndItsChildren(route, context, checks) {\r\n    const children = nodeChildrenAsMap(route);\r\n    const r = route.value;\r\n    Object.entries(children).forEach(([childName, node]) => {\r\n        if (!r.component) {\r\n            deactivateRouteAndItsChildren(node, context, checks);\r\n        }\r\n        else if (context) {\r\n            deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\r\n        }\r\n        else {\r\n            deactivateRouteAndItsChildren(node, null, checks);\r\n        }\r\n    });\r\n    if (!r.component) {\r\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\r\n    }\r\n    else if (context && context.outlet && context.outlet.isActivated) {\r\n        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\r\n    }\r\n    else {\r\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\r\n    }\r\n}\r\n\r\n/**\r\n * Simple function check, but generic so type inference will flow. Example:\r\n *\r\n * function product(a: number, b: number) {\r\n *   return a * b;\r\n * }\r\n *\r\n * if (isFunction<product>(fn)) {\r\n *   return fn(1, 2);\r\n * } else {\r\n *   throw \"Must provide the `product` function\";\r\n * }\r\n */\r\nfunction isFunction(v) {\r\n    return typeof v === 'function';\r\n}\r\nfunction isBoolean(v) {\r\n    return typeof v === 'boolean';\r\n}\r\nfunction isCanLoad(guard) {\r\n    return guard && isFunction(guard.canLoad);\r\n}\r\nfunction isCanActivate(guard) {\r\n    return guard && isFunction(guard.canActivate);\r\n}\r\nfunction isCanActivateChild(guard) {\r\n    return guard && isFunction(guard.canActivateChild);\r\n}\r\nfunction isCanDeactivate(guard) {\r\n    return guard && isFunction(guard.canDeactivate);\r\n}\r\nfunction isCanMatch(guard) {\r\n    return guard && isFunction(guard.canMatch);\r\n}\r\nfunction isEmptyError(e) {\r\n    return e instanceof EmptyError || e?.name === 'EmptyError';\r\n}\r\n\r\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\r\nfunction prioritizedGuardValue() {\r\n    return switchMap((obs) => {\r\n        return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {\r\n            for (const result of results) {\r\n                if (result === true) {\r\n                    // If result is true, check the next one\r\n                    continue;\r\n                }\r\n                else if (result === INITIAL_VALUE) {\r\n                    // If guard has not finished, we need to stop processing.\r\n                    return INITIAL_VALUE;\r\n                }\r\n                else if (result === false || isRedirect(result)) {\r\n                    // Result finished and was not true. Return the result.\r\n                    // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\r\n                    // ignored.\r\n                    return result;\r\n                }\r\n            }\r\n            // Everything resolved to true. Return true.\r\n            return true;\r\n        }), filter((item) => item !== INITIAL_VALUE), take(1));\r\n    });\r\n}\r\nfunction isRedirect(val) {\r\n    return isUrlTree(val) || val instanceof RedirectCommand;\r\n}\r\n\r\nfunction checkGuards(injector, forwardEvent) {\r\n    return mergeMap((t) => {\r\n        const { targetSnapshot, currentSnapshot, guards: { canActivateChecks, canDeactivateChecks }, } = t;\r\n        if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\r\n            return of({ ...t, guardsResult: true });\r\n        }\r\n        return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {\r\n            return canDeactivate && isBoolean(canDeactivate)\r\n                ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent)\r\n                : of(canDeactivate);\r\n        }), map((guardsResult) => ({ ...t, guardsResult })));\r\n    });\r\n}\r\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\r\n    return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {\r\n        return result !== true;\r\n    }, true));\r\n}\r\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\r\n    return from(checks).pipe(concatMap((check) => {\r\n        return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\r\n    }), first((result) => {\r\n        return result !== true;\r\n    }, true));\r\n}\r\n/**\r\n * This should fire off `ActivationStart` events for each route being activated at this\r\n * level.\r\n * In other words, if you're activating `a` and `b` below, `path` will contain the\r\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\r\n * return\r\n * `true` so checks continue to run.\r\n */\r\nfunction fireActivationStart(snapshot, forwardEvent) {\r\n    if (snapshot !== null && forwardEvent) {\r\n        forwardEvent(new ActivationStart(snapshot));\r\n    }\r\n    return of(true);\r\n}\r\n/**\r\n * This should fire off `ChildActivationStart` events for each route being activated at this\r\n * level.\r\n * In other words, if you're activating `a` and `b` below, `path` will contain the\r\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\r\n * return\r\n * `true` so checks continue to run.\r\n */\r\nfunction fireChildActivationStart(snapshot, forwardEvent) {\r\n    if (snapshot !== null && forwardEvent) {\r\n        forwardEvent(new ChildActivationStart(snapshot));\r\n    }\r\n    return of(true);\r\n}\r\nfunction runCanActivate(futureRSS, futureARS, injector) {\r\n    const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\r\n    if (!canActivate || canActivate.length === 0)\r\n        return of(true);\r\n    const canActivateObservables = canActivate.map((canActivate) => {\r\n        return defer(() => {\r\n            const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\r\n            const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\r\n            const guardVal = isCanActivate(guard)\r\n                ? guard.canActivate(futureARS, futureRSS)\r\n                : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\r\n            return wrapIntoObservable(guardVal).pipe(first());\r\n        });\r\n    });\r\n    return of(canActivateObservables).pipe(prioritizedGuardValue());\r\n}\r\nfunction runCanActivateChild(futureRSS, path, injector) {\r\n    const futureARS = path[path.length - 1];\r\n    const canActivateChildGuards = path\r\n        .slice(0, path.length - 1)\r\n        .reverse()\r\n        .map((p) => getCanActivateChild(p))\r\n        .filter((_) => _ !== null);\r\n    const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {\r\n        return defer(() => {\r\n            const guardsMapped = d.guards.map((canActivateChild) => {\r\n                const closestInjector = getClosestRouteInjector(d.node) ?? injector;\r\n                const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\r\n                const guardVal = isCanActivateChild(guard)\r\n                    ? guard.canActivateChild(futureARS, futureRSS)\r\n                    : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\r\n                return wrapIntoObservable(guardVal).pipe(first());\r\n            });\r\n            return of(guardsMapped).pipe(prioritizedGuardValue());\r\n        });\r\n    });\r\n    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\r\n}\r\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\r\n    const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\r\n    if (!canDeactivate || canDeactivate.length === 0)\r\n        return of(true);\r\n    const canDeactivateObservables = canDeactivate.map((c) => {\r\n        const closestInjector = getClosestRouteInjector(currARS) ?? injector;\r\n        const guard = getTokenOrFunctionIdentity(c, closestInjector);\r\n        const guardVal = isCanDeactivate(guard)\r\n            ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\r\n            : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\r\n        return wrapIntoObservable(guardVal).pipe(first());\r\n    });\r\n    return of(canDeactivateObservables).pipe(prioritizedGuardValue());\r\n}\r\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\r\n    const canLoad = route.canLoad;\r\n    if (canLoad === undefined || canLoad.length === 0) {\r\n        return of(true);\r\n    }\r\n    const canLoadObservables = canLoad.map((injectionToken) => {\r\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\r\n        const guardVal = isCanLoad(guard)\r\n            ? guard.canLoad(route, segments)\r\n            : runInInjectionContext(injector, () => guard(route, segments));\r\n        return wrapIntoObservable(guardVal);\r\n    });\r\n    return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\r\n}\r\nfunction redirectIfUrlTree(urlSerializer) {\r\n    return pipe(tap((result) => {\r\n        if (typeof result === 'boolean')\r\n            return;\r\n        throw redirectingNavigationError(urlSerializer, result);\r\n    }), map((result) => result === true));\r\n}\r\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\r\n    const canMatch = route.canMatch;\r\n    if (!canMatch || canMatch.length === 0)\r\n        return of(true);\r\n    const canMatchObservables = canMatch.map((injectionToken) => {\r\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\r\n        const guardVal = isCanMatch(guard)\r\n            ? guard.canMatch(route, segments)\r\n            : runInInjectionContext(injector, () => guard(route, segments));\r\n        return wrapIntoObservable(guardVal);\r\n    });\r\n    return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\r\n}\r\n\r\nclass NoMatch {\r\n    segmentGroup;\r\n    constructor(segmentGroup) {\r\n        this.segmentGroup = segmentGroup || null;\r\n    }\r\n}\r\nclass AbsoluteRedirect extends Error {\r\n    urlTree;\r\n    constructor(urlTree) {\r\n        super();\r\n        this.urlTree = urlTree;\r\n    }\r\n}\r\nfunction noMatch$1(segmentGroup) {\r\n    return throwError(new NoMatch(segmentGroup));\r\n}\r\nfunction namedOutletsRedirect(redirectTo) {\r\n    return throwError(new _RuntimeError(4000 /* RuntimeErrorCode.NAMED_OUTLET_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\r\n}\r\nfunction canLoadFails(route) {\r\n    return throwError(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\r\n}\r\nclass ApplyRedirects {\r\n    urlSerializer;\r\n    urlTree;\r\n    constructor(urlSerializer, urlTree) {\r\n        this.urlSerializer = urlSerializer;\r\n        this.urlTree = urlTree;\r\n    }\r\n    lineralizeSegments(route, urlTree) {\r\n        let res = [];\r\n        let c = urlTree.root;\r\n        while (true) {\r\n            res = res.concat(c.segments);\r\n            if (c.numberOfChildren === 0) {\r\n                return of(res);\r\n            }\r\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\r\n                return namedOutletsRedirect(`${route.redirectTo}`);\r\n            }\r\n            c = c.children[PRIMARY_OUTLET];\r\n        }\r\n    }\r\n    applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\r\n        if (typeof redirectTo !== 'string') {\r\n            const redirectToFn = redirectTo;\r\n            const { queryParams, fragment, routeConfig, url, outlet, params, data, title } = currentSnapshot;\r\n            const newRedirect = runInInjectionContext(injector, () => redirectToFn({ params, data, queryParams, fragment, routeConfig, url, outlet, title }));\r\n            if (newRedirect instanceof UrlTree) {\r\n                throw new AbsoluteRedirect(newRedirect);\r\n            }\r\n            redirectTo = newRedirect;\r\n        }\r\n        const newTree = this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\r\n        if (redirectTo[0] === '/') {\r\n            throw new AbsoluteRedirect(newTree);\r\n        }\r\n        return newTree;\r\n    }\r\n    applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\r\n        const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\r\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\r\n    }\r\n    createQueryParams(redirectToParams, actualParams) {\r\n        const res = {};\r\n        Object.entries(redirectToParams).forEach(([k, v]) => {\r\n            const copySourceValue = typeof v === 'string' && v[0] === ':';\r\n            if (copySourceValue) {\r\n                const sourceName = v.substring(1);\r\n                res[k] = actualParams[sourceName];\r\n            }\r\n            else {\r\n                res[k] = v;\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n    createSegmentGroup(redirectTo, group, segments, posParams) {\r\n        const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\r\n        let children = {};\r\n        Object.entries(group.children).forEach(([name, child]) => {\r\n            children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\r\n        });\r\n        return new UrlSegmentGroup(updatedSegments, children);\r\n    }\r\n    createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\r\n        return redirectToSegments.map((s) => s.path[0] === ':'\r\n            ? this.findPosParam(redirectTo, s, posParams)\r\n            : this.findOrReturn(s, actualSegments));\r\n    }\r\n    findPosParam(redirectTo, redirectToUrlSegment, posParams) {\r\n        const pos = posParams[redirectToUrlSegment.path.substring(1)];\r\n        if (!pos)\r\n            throw new _RuntimeError(4001 /* RuntimeErrorCode.MISSING_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\r\n        return pos;\r\n    }\r\n    findOrReturn(redirectToUrlSegment, actualSegments) {\r\n        let idx = 0;\r\n        for (const s of actualSegments) {\r\n            if (s.path === redirectToUrlSegment.path) {\r\n                actualSegments.splice(idx);\r\n                return s;\r\n            }\r\n            idx++;\r\n        }\r\n        return redirectToUrlSegment;\r\n    }\r\n}\r\n\r\nconst noMatch = {\r\n    matched: false,\r\n    consumedSegments: [],\r\n    remainingSegments: [],\r\n    parameters: {},\r\n    positionalParamSegments: {},\r\n};\r\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\r\n    const result = match(segmentGroup, route, segments);\r\n    if (!result.matched) {\r\n        return of(result);\r\n    }\r\n    // Only create the Route's `EnvironmentInjector` if it matches the attempted\r\n    // navigation\r\n    injector = getOrCreateRouteInjectorIfNeeded(route, injector);\r\n    return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => (v === true ? result : { ...noMatch })));\r\n}\r\nfunction match(segmentGroup, route, segments) {\r\n    if (route.path === '**') {\r\n        return createWildcardMatchResult(segments);\r\n    }\r\n    if (route.path === '') {\r\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\r\n            return { ...noMatch };\r\n        }\r\n        return {\r\n            matched: true,\r\n            consumedSegments: [],\r\n            remainingSegments: segments,\r\n            parameters: {},\r\n            positionalParamSegments: {},\r\n        };\r\n    }\r\n    const matcher = route.matcher || defaultUrlMatcher;\r\n    const res = matcher(segments, segmentGroup, route);\r\n    if (!res)\r\n        return { ...noMatch };\r\n    const posParams = {};\r\n    Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\r\n        posParams[k] = v.path;\r\n    });\r\n    const parameters = res.consumed.length > 0\r\n        ? { ...posParams, ...res.consumed[res.consumed.length - 1].parameters }\r\n        : posParams;\r\n    return {\r\n        matched: true,\r\n        consumedSegments: res.consumed,\r\n        remainingSegments: segments.slice(res.consumed.length),\r\n        // TODO(atscott): investigate combining parameters and positionalParamSegments\r\n        parameters,\r\n        positionalParamSegments: res.posParams ?? {},\r\n    };\r\n}\r\nfunction createWildcardMatchResult(segments) {\r\n    return {\r\n        matched: true,\r\n        parameters: segments.length > 0 ? last(segments).parameters : {},\r\n        consumedSegments: segments,\r\n        remainingSegments: [],\r\n        positionalParamSegments: {},\r\n    };\r\n}\r\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\r\n    if (slicedSegments.length > 0 &&\r\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\r\n        const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\r\n        return { segmentGroup: s, slicedSegments: [] };\r\n    }\r\n    if (slicedSegments.length === 0 &&\r\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\r\n        const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\r\n        return { segmentGroup: s, slicedSegments };\r\n    }\r\n    const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\r\n    return { segmentGroup: s, slicedSegments };\r\n}\r\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\r\n    const res = {};\r\n    for (const r of routes) {\r\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\r\n            const s = new UrlSegmentGroup([], {});\r\n            res[getOutlet(r)] = s;\r\n        }\r\n    }\r\n    return { ...children, ...res };\r\n}\r\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\r\n    const res = {};\r\n    res[PRIMARY_OUTLET] = primarySegment;\r\n    for (const r of routes) {\r\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\r\n            const s = new UrlSegmentGroup([], {});\r\n            res[getOutlet(r)] = s;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\r\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\r\n}\r\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\r\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\r\n}\r\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\r\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\r\n        return false;\r\n    }\r\n    return r.path === '';\r\n}\r\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\r\n    return segments.length === 0 && !segmentGroup.children[outlet];\r\n}\r\n\r\n/**\r\n * Class used to indicate there were no additional route config matches but that all segments of\r\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\r\n * try to match child configs in case there are empty path children.\r\n */\r\nclass NoLeftoversInUrl {\r\n}\r\nfunction recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly') {\r\n    return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\r\n}\r\nconst MAX_ALLOWED_REDIRECTS = 31;\r\nclass Recognizer {\r\n    injector;\r\n    configLoader;\r\n    rootComponentType;\r\n    config;\r\n    urlTree;\r\n    paramsInheritanceStrategy;\r\n    urlSerializer;\r\n    applyRedirects;\r\n    absoluteRedirectCount = 0;\r\n    allowRedirects = true;\r\n    constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {\r\n        this.injector = injector;\r\n        this.configLoader = configLoader;\r\n        this.rootComponentType = rootComponentType;\r\n        this.config = config;\r\n        this.urlTree = urlTree;\r\n        this.paramsInheritanceStrategy = paramsInheritanceStrategy;\r\n        this.urlSerializer = urlSerializer;\r\n        this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\r\n    }\r\n    noMatchError(e) {\r\n        return new _RuntimeError(4002 /* RuntimeErrorCode.NO_MATCH */, typeof ngDevMode === 'undefined' || ngDevMode\r\n            ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\r\n            : `'${e.segmentGroup}'`);\r\n    }\r\n    recognize() {\r\n        const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\r\n        return this.match(rootSegmentGroup).pipe(map(({ children, rootSnapshot }) => {\r\n            const rootNode = new TreeNode(rootSnapshot, children);\r\n            const routeState = new RouterStateSnapshot('', rootNode);\r\n            const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\r\n            // https://github.com/angular/angular/issues/47307\r\n            // Creating the tree stringifies the query params\r\n            // We don't want to do this here so reassign them to the original.\r\n            tree.queryParams = this.urlTree.queryParams;\r\n            routeState.url = this.urlSerializer.serialize(tree);\r\n            return { state: routeState, tree };\r\n        }));\r\n    }\r\n    match(rootSegmentGroup) {\r\n        // Use Object.freeze to prevent readers of the Router state from modifying it outside\r\n        // of a navigation, resulting in the router being out of sync with the browser.\r\n        const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\r\n        return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {\r\n            return { children, rootSnapshot };\r\n        }), catchError((e) => {\r\n            if (e instanceof AbsoluteRedirect) {\r\n                this.urlTree = e.urlTree;\r\n                return this.match(e.urlTree.root);\r\n            }\r\n            if (e instanceof NoMatch) {\r\n                throw this.noMatchError(e);\r\n            }\r\n            throw e;\r\n        }));\r\n    }\r\n    processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\r\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\r\n            return this.processChildren(injector, config, segmentGroup, parentRoute);\r\n        }\r\n        return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\r\n    }\r\n    /**\r\n     * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\r\n     * we cannot find a match for _any_ of the children.\r\n     *\r\n     * @param config - The `Routes` to match against\r\n     * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\r\n     *     config.\r\n     */\r\n    processChildren(injector, config, segmentGroup, parentRoute) {\r\n        // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\r\n        // because an absolute redirect from the primary outlet takes precedence.\r\n        const childOutlets = [];\r\n        for (const child of Object.keys(segmentGroup.children)) {\r\n            if (child === 'primary') {\r\n                childOutlets.unshift(child);\r\n            }\r\n            else {\r\n                childOutlets.push(child);\r\n            }\r\n        }\r\n        return from(childOutlets).pipe(concatMap((childOutlet) => {\r\n            const child = segmentGroup.children[childOutlet];\r\n            // Sort the config so that routes with outlets that match the one being activated\r\n            // appear first, followed by routes for other outlets, which might match if they have\r\n            // an empty path.\r\n            const sortedConfig = sortByMatchingOutlets(config, childOutlet);\r\n            return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\r\n        }), scan((children, outletChildren) => {\r\n            children.push(...outletChildren);\r\n            return children;\r\n        }), defaultIfEmpty(null), last$1(), mergeMap((children) => {\r\n            if (children === null)\r\n                return noMatch$1(segmentGroup);\r\n            // Because we may have matched two outlets to the same empty path segment, we can have\r\n            // multiple activated results for the same outlet. We should merge the children of\r\n            // these results so the final return value is only one `TreeNode` per outlet.\r\n            const mergedChildren = mergeEmptyPathMatches(children);\r\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n                // This should really never happen - we are only taking the first match for each\r\n                // outlet and merge the empty path matches.\r\n                checkOutletNameUniqueness(mergedChildren);\r\n            }\r\n            sortActivatedRouteSnapshots(mergedChildren);\r\n            return of(mergedChildren);\r\n        }));\r\n    }\r\n    processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\r\n        return from(routes).pipe(concatMap((r) => {\r\n            return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {\r\n                if (e instanceof NoMatch) {\r\n                    return of(null);\r\n                }\r\n                throw e;\r\n            }));\r\n        }), first((x) => !!x), catchError((e) => {\r\n            if (isEmptyError(e)) {\r\n                if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\r\n                    return of(new NoLeftoversInUrl());\r\n                }\r\n                return noMatch$1(segmentGroup);\r\n            }\r\n            throw e;\r\n        }));\r\n    }\r\n    processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\r\n        // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\r\n        // a config like\r\n        // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\r\n        // or even\r\n        // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\r\n        //\r\n        // The exception here is when the segment outlet is for the primary outlet. This would\r\n        // result in a match inside the named outlet because all children there are written as primary\r\n        // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\r\n        // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\r\n        // This should only match if the url is `/(x:b)`.\r\n        if (getOutlet(route) !== outlet &&\r\n            (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\r\n            return noMatch$1(rawSegment);\r\n        }\r\n        if (route.redirectTo === undefined) {\r\n            return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\r\n        }\r\n        if (this.allowRedirects && allowRedirects) {\r\n            return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\r\n        }\r\n        return noMatch$1(rawSegment);\r\n    }\r\n    expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\r\n        const { matched, parameters, consumedSegments, positionalParamSegments, remainingSegments } = match(segmentGroup, route, segments);\r\n        if (!matched)\r\n            return noMatch$1(segmentGroup);\r\n        // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\r\n        // size exceeded in production\r\n        if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\r\n            this.absoluteRedirectCount++;\r\n            if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\r\n                if (ngDevMode) {\r\n                    throw new _RuntimeError(4016 /* RuntimeErrorCode.INFINITE_REDIRECT */, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\r\n                        `This is currently a dev mode only error but will become a` +\r\n                        ` call stack size exceeded error in production in a future major version.`);\r\n                }\r\n                this.allowRedirects = false;\r\n            }\r\n        }\r\n        const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\r\n        const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\r\n        currentSnapshot.params = Object.freeze(inherited.params);\r\n        currentSnapshot.data = Object.freeze(inherited.data);\r\n        const newTree = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\r\n        return this.applyRedirects.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {\r\n            return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\r\n        }));\r\n    }\r\n    matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\r\n        const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\r\n        if (route.path === '**') {\r\n            // Prior versions of the route matching algorithm would stop matching at the wildcard route.\r\n            // We should investigate a better strategy for any existing children. Otherwise, these\r\n            // child segments are silently dropped from the navigation.\r\n            // https://github.com/angular/angular/issues/40089\r\n            rawSegment.children = {};\r\n        }\r\n        return matchResult.pipe(switchMap((result) => {\r\n            if (!result.matched) {\r\n                return noMatch$1(rawSegment);\r\n            }\r\n            // If the route has an injector created from providers, we should start using that.\r\n            injector = route._injector ?? injector;\r\n            return this.getChildConfig(injector, route, segments).pipe(switchMap(({ routes: childConfig }) => {\r\n                const childInjector = route._loadedInjector ?? injector;\r\n                const { parameters, consumedSegments, remainingSegments } = result;\r\n                const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\r\n                const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\r\n                snapshot.params = Object.freeze(inherited.params);\r\n                snapshot.data = Object.freeze(inherited.data);\r\n                const { segmentGroup, slicedSegments } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\r\n                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\r\n                    return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {\r\n                        return new TreeNode(snapshot, children);\r\n                    }));\r\n                }\r\n                if (childConfig.length === 0 && slicedSegments.length === 0) {\r\n                    return of(new TreeNode(snapshot, []));\r\n                }\r\n                const matchedOnOutlet = getOutlet(route) === outlet;\r\n                // If we matched a config due to empty path match on a different outlet, we need to\r\n                // continue passing the current outlet for the segment rather than switch to PRIMARY.\r\n                // Note that we switch to primary when we have a match because outlet configs look like\r\n                // this: {path: 'a', outlet: 'a', children: [\r\n                //  {path: 'b', component: B},\r\n                //  {path: 'c', component: C},\r\n                // ]}\r\n                // Notice that the children of the named outlet are configured with the primary outlet\r\n                return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {\r\n                    return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\r\n                }));\r\n            }));\r\n        }));\r\n    }\r\n    getChildConfig(injector, route, segments) {\r\n        if (route.children) {\r\n            // The children belong to the same module\r\n            return of({ routes: route.children, injector });\r\n        }\r\n        if (route.loadChildren) {\r\n            // lazy children belong to the loaded module\r\n            if (route._loadedRoutes !== undefined) {\r\n                return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\r\n            }\r\n            return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {\r\n                if (shouldLoadResult) {\r\n                    return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {\r\n                        route._loadedRoutes = cfg.routes;\r\n                        route._loadedInjector = cfg.injector;\r\n                    }));\r\n                }\r\n                return canLoadFails(route);\r\n            }));\r\n        }\r\n        return of({ routes: [], injector });\r\n    }\r\n}\r\nfunction sortActivatedRouteSnapshots(nodes) {\r\n    nodes.sort((a, b) => {\r\n        if (a.value.outlet === PRIMARY_OUTLET)\r\n            return -1;\r\n        if (b.value.outlet === PRIMARY_OUTLET)\r\n            return 1;\r\n        return a.value.outlet.localeCompare(b.value.outlet);\r\n    });\r\n}\r\nfunction hasEmptyPathConfig(node) {\r\n    const config = node.value.routeConfig;\r\n    return config && config.path === '';\r\n}\r\n/**\r\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\r\n * the children from each duplicate. This is necessary because different outlets can match a\r\n * single empty path route config and the results need to then be merged.\r\n */\r\nfunction mergeEmptyPathMatches(nodes) {\r\n    const result = [];\r\n    // The set of nodes which contain children that were merged from two duplicate empty path nodes.\r\n    const mergedNodes = new Set();\r\n    for (const node of nodes) {\r\n        if (!hasEmptyPathConfig(node)) {\r\n            result.push(node);\r\n            continue;\r\n        }\r\n        const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);\r\n        if (duplicateEmptyPathNode !== undefined) {\r\n            duplicateEmptyPathNode.children.push(...node.children);\r\n            mergedNodes.add(duplicateEmptyPathNode);\r\n        }\r\n        else {\r\n            result.push(node);\r\n        }\r\n    }\r\n    // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\r\n    // by also merging those children. This is necessary when there are multiple empty path configs\r\n    // in a row. Put another way: whenever we combine children of two nodes, we need to also check\r\n    // if any of those children can be combined into a single node as well.\r\n    for (const mergedNode of mergedNodes) {\r\n        const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\r\n        result.push(new TreeNode(mergedNode.value, mergedChildren));\r\n    }\r\n    return result.filter((n) => !mergedNodes.has(n));\r\n}\r\nfunction checkOutletNameUniqueness(nodes) {\r\n    const names = {};\r\n    nodes.forEach((n) => {\r\n        const routeWithSameOutletName = names[n.value.outlet];\r\n        if (routeWithSameOutletName) {\r\n            const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\r\n            const c = n.value.url.map((s) => s.toString()).join('/');\r\n            throw new _RuntimeError(4006 /* RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\r\n        }\r\n        names[n.value.outlet] = n.value;\r\n    });\r\n}\r\nfunction getData(route) {\r\n    return route.data || {};\r\n}\r\nfunction getResolve(route) {\r\n    return route.resolve || {};\r\n}\r\n\r\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy) {\r\n    return mergeMap((t) => recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({ state: targetSnapshot, tree: urlAfterRedirects }) => {\r\n        return { ...t, targetSnapshot, urlAfterRedirects };\r\n    })));\r\n}\r\n\r\nfunction resolveData(paramsInheritanceStrategy, injector) {\r\n    return mergeMap((t) => {\r\n        const { targetSnapshot, guards: { canActivateChecks }, } = t;\r\n        if (!canActivateChecks.length) {\r\n            return of(t);\r\n        }\r\n        // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\r\n        // preserve the correct order that the resolvers should run in.\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\r\n        const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\r\n        const routesNeedingDataUpdates = new Set();\r\n        for (const route of routesWithResolversToRun) {\r\n            if (routesNeedingDataUpdates.has(route)) {\r\n                continue;\r\n            }\r\n            // All children under the route with a resolver to run need to recompute inherited data.\r\n            for (const newRoute of flattenRouteTree(route)) {\r\n                routesNeedingDataUpdates.add(newRoute);\r\n            }\r\n        }\r\n        let routesProcessed = 0;\r\n        return from(routesNeedingDataUpdates).pipe(concatMap((route) => {\r\n            if (routesWithResolversToRun.has(route)) {\r\n                return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\r\n            }\r\n            else {\r\n                route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\r\n                return of(void 0);\r\n            }\r\n        }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)));\r\n    });\r\n}\r\n/**\r\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\r\n */\r\nfunction flattenRouteTree(route) {\r\n    const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\r\n    return [route, ...descendants];\r\n}\r\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\r\n    const config = futureARS.routeConfig;\r\n    const resolve = futureARS._resolve;\r\n    if (config?.title !== undefined && !hasStaticTitle(config)) {\r\n        resolve[RouteTitleKey] = config.title;\r\n    }\r\n    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {\r\n        futureARS._resolvedData = resolvedData;\r\n        futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\r\n        return null;\r\n    }));\r\n}\r\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\r\n    const keys = getDataKeys(resolve);\r\n    if (keys.length === 0) {\r\n        return of({});\r\n    }\r\n    const data = {};\r\n    return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {\r\n        if (value instanceof RedirectCommand) {\r\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\r\n        }\r\n        data[key] = value;\r\n    }))), takeLast(1), map(() => data), catchError((e) => (isEmptyError(e) ? EMPTY : throwError(e))));\r\n}\r\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\r\n    const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\r\n    const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\r\n    const resolverValue = resolver.resolve\r\n        ? resolver.resolve(futureARS, futureRSS)\r\n        : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\r\n    return wrapIntoObservable(resolverValue);\r\n}\r\n\r\n/**\r\n * Perform a side effect through a switchMap for every emission on the source Observable,\r\n * but return an Observable that is identical to the source. It's essentially the same as\r\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\r\n * it will wait before continuing with the original value.\r\n */\r\nfunction switchTap(next) {\r\n    return switchMap((v) => {\r\n        const nextResult = next(v);\r\n        if (nextResult) {\r\n            return from(nextResult).pipe(map(() => v));\r\n        }\r\n        return of(v);\r\n    });\r\n}\r\n\r\n/**\r\n * Provides a strategy for setting the page title after a router navigation.\r\n *\r\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\r\n * outlet with `title` property. Given the `Routes` below, navigating to\r\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\r\n * ```ts\r\n * [\r\n *   {path: 'base', title: 'base', children: [\r\n *     {path: 'child', title: 'child'},\r\n *   ],\r\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\r\n * ]\r\n * ```\r\n *\r\n * This class can be used as a base class for custom title strategies. That is, you can create your\r\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\r\n * from the named outlet is never used. However, a custom strategy might be implemented to\r\n * incorporate titles in named outlets.\r\n *\r\n * @publicApi\r\n * @see [Page title guide](guide/routing/common-router-tasks#setting-the-page-title)\r\n */\r\nclass TitleStrategy {\r\n    /**\r\n     * @returns The `title` of the deepest primary route.\r\n     */\r\n    buildTitle(snapshot) {\r\n        let pageTitle;\r\n        let route = snapshot.root;\r\n        while (route !== undefined) {\r\n            pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\r\n            route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\r\n        }\r\n        return pageTitle;\r\n    }\r\n    /**\r\n     * Given an `ActivatedRouteSnapshot`, returns the final value of the\r\n     * `Route.title` property, which can either be a static string or a resolved value.\r\n     */\r\n    getResolvedTitleForRoute(snapshot) {\r\n        return snapshot.data[RouteTitleKey];\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: TitleStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: TitleStrategy, providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: TitleStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) }]\r\n        }] });\r\n/**\r\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\r\n */\r\nclass DefaultTitleStrategy extends TitleStrategy {\r\n    title;\r\n    constructor(title) {\r\n        super();\r\n        this.title = title;\r\n    }\r\n    /**\r\n     * Sets the title of the browser to the given value.\r\n     *\r\n     * @param title The `pageTitle` from the deepest primary route.\r\n     */\r\n    updateTitle(snapshot) {\r\n        const title = this.buildTitle(snapshot);\r\n        if (title !== undefined) {\r\n            this.title.setTitle(title);\r\n        }\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultTitleStrategy, deps: [{ token: i1.Title }], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultTitleStrategy, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultTitleStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [{ type: i1.Title }] });\r\n\r\n/**\r\n * A DI token for the router service.\r\n *\r\n * @publicApi\r\n */\r\nconst ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\r\n    providedIn: 'root',\r\n    factory: () => ({}),\r\n});\r\n\r\n/**\r\n * The DI token for a router configuration.\r\n *\r\n * `ROUTES` is a low level API for router configuration via dependency injection.\r\n *\r\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\r\n * `provideRouter`, or `Router.resetConfig()`.\r\n *\r\n * @publicApi\r\n */\r\nconst ROUTES = new InjectionToken(ngDevMode ? 'ROUTES' : '');\r\nclass RouterConfigLoader {\r\n    componentLoaders = new WeakMap();\r\n    childrenLoaders = new WeakMap();\r\n    onLoadStartListener;\r\n    onLoadEndListener;\r\n    compiler = inject(Compiler);\r\n    loadComponent(route) {\r\n        if (this.componentLoaders.get(route)) {\r\n            return this.componentLoaders.get(route);\r\n        }\r\n        else if (route._loadedComponent) {\r\n            return of(route._loadedComponent);\r\n        }\r\n        if (this.onLoadStartListener) {\r\n            this.onLoadStartListener(route);\r\n        }\r\n        const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(map(maybeUnwrapDefaultExport), tap((component) => {\r\n            if (this.onLoadEndListener) {\r\n                this.onLoadEndListener(route);\r\n            }\r\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                assertStandalone(route.path ?? '', component);\r\n            route._loadedComponent = component;\r\n        }), finalize(() => {\r\n            this.componentLoaders.delete(route);\r\n        }));\r\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\r\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\r\n        this.componentLoaders.set(route, loader);\r\n        return loader;\r\n    }\r\n    loadChildren(parentInjector, route) {\r\n        if (this.childrenLoaders.get(route)) {\r\n            return this.childrenLoaders.get(route);\r\n        }\r\n        else if (route._loadedRoutes) {\r\n            return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\r\n        }\r\n        if (this.onLoadStartListener) {\r\n            this.onLoadStartListener(route);\r\n        }\r\n        const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\r\n        const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {\r\n            this.childrenLoaders.delete(route);\r\n        }));\r\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\r\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\r\n        this.childrenLoaders.set(route, loader);\r\n        return loader;\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouterConfigLoader, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouterConfigLoader, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouterConfigLoader, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\r\n/**\r\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\r\n * an injector if that callback returned a module.\r\n *\r\n * This function is used for the route discovery during prerendering\r\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\r\n * an update to the extractor.\r\n */\r\nfunction loadChildren(route, compiler, parentInjector, onLoadEndListener) {\r\n    return wrapIntoObservable(route.loadChildren()).pipe(map(maybeUnwrapDefaultExport), mergeMap((t) => {\r\n        if (t instanceof NgModuleFactory || Array.isArray(t)) {\r\n            return of(t);\r\n        }\r\n        else {\r\n            return from(compiler.compileModuleAsync(t));\r\n        }\r\n    }), map((factoryOrRoutes) => {\r\n        if (onLoadEndListener) {\r\n            onLoadEndListener(route);\r\n        }\r\n        // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\r\n        // no injector associated with lazy loading a `Route` array.\r\n        let injector;\r\n        let rawRoutes;\r\n        let requireStandaloneComponents = false;\r\n        if (Array.isArray(factoryOrRoutes)) {\r\n            rawRoutes = factoryOrRoutes;\r\n            requireStandaloneComponents = true;\r\n        }\r\n        else {\r\n            injector = factoryOrRoutes.create(parentInjector).injector;\r\n            // When loading a module that doesn't provide `RouterModule.forChild()` preloader\r\n            // will get stuck in an infinite loop. The child module's Injector will look to\r\n            // its parent `Injector` when it doesn't find any ROUTES so it will return routes\r\n            // for it's parent module instead.\r\n            rawRoutes = injector.get(ROUTES, [], { optional: true, self: true }).flat();\r\n        }\r\n        const routes = rawRoutes.map(standardizeConfig);\r\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n            validateConfig(routes, route.path, requireStandaloneComponents);\r\n        return { routes, injector };\r\n    }));\r\n}\r\nfunction isWrappedDefaultExport(value) {\r\n    // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\r\n    // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\r\n    // `default` will be a renamed property.\r\n    return value && typeof value === 'object' && 'default' in value;\r\n}\r\nfunction maybeUnwrapDefaultExport(input) {\r\n    // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\r\n    // subject to property renaming, so we reference it with bracket access.\r\n    return isWrappedDefaultExport(input) ? input['default'] : input;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a way to migrate AngularJS applications to Angular.\r\n *\r\n * @publicApi\r\n */\r\nclass UrlHandlingStrategy {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlHandlingStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlHandlingStrategy, providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: UrlHandlingStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) }]\r\n        }] });\r\n/**\r\n * @publicApi\r\n */\r\nclass DefaultUrlHandlingStrategy {\r\n    shouldProcessUrl(url) {\r\n        return true;\r\n    }\r\n    extract(url) {\r\n        return url;\r\n    }\r\n    merge(newUrlPart, wholeUrl) {\r\n        return newUrlPart;\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultUrlHandlingStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultUrlHandlingStrategy, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultUrlHandlingStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\r\n\r\n/// <reference types=\"dom-view-transitions\" />\r\nconst CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? 'view transition helper' : '');\r\nconst VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? 'view transition options' : '');\r\n/**\r\n * A helper function for using browser view transitions. This function skips the call to\r\n * `startViewTransition` if the browser does not support it.\r\n *\r\n * @returns A Promise that resolves when the view transition callback begins.\r\n */\r\nfunction createViewTransition(injector, from, to) {\r\n    const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\r\n    const document = injector.get(DOCUMENT);\r\n    // Create promises outside the Angular zone to avoid causing extra change detections\r\n    return injector.get(NgZone).runOutsideAngular(() => {\r\n        if (!document.startViewTransition || transitionOptions.skipNextTransition) {\r\n            transitionOptions.skipNextTransition = false;\r\n            // The timing of `startViewTransition` is closer to a macrotask. It won't be called\r\n            // until the current event loop exits so we use a promise resolved in a timeout instead\r\n            // of Promise.resolve().\r\n            return new Promise((resolve) => setTimeout(resolve));\r\n        }\r\n        let resolveViewTransitionStarted;\r\n        const viewTransitionStarted = new Promise((resolve) => {\r\n            resolveViewTransitionStarted = resolve;\r\n        });\r\n        const transition = document.startViewTransition(() => {\r\n            resolveViewTransitionStarted();\r\n            // We don't actually update dom within the transition callback. The resolving of the above\r\n            // promise unblocks the Router navigation, which synchronously activates and deactivates\r\n            // routes (the DOM update). This view transition waits for the next change detection to\r\n            // complete (below), which includes the update phase of the routed components.\r\n            return createRenderPromise(injector);\r\n            // TODO(atscott): Types in DefinitelyTyped are not up-to-date\r\n        });\r\n        const { onViewTransitionCreated } = transitionOptions;\r\n        if (onViewTransitionCreated) {\r\n            runInInjectionContext(injector, () => onViewTransitionCreated({ transition, from, to }));\r\n        }\r\n        return viewTransitionStarted;\r\n    });\r\n}\r\n/**\r\n * Creates a promise that resolves after next render.\r\n */\r\nfunction createRenderPromise(injector) {\r\n    return new Promise((resolve) => {\r\n        // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\r\n        // This ensures any follow-up renders in the microtask queue are completed before the\r\n        // view transition starts animating.\r\n        afterNextRender({ read: () => setTimeout(resolve) }, { injector });\r\n    });\r\n}\r\n\r\nconst NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\r\nclass NavigationTransitions {\r\n    currentNavigation = null;\r\n    currentTransition = null;\r\n    lastSuccessfulNavigation = null;\r\n    /**\r\n     * These events are used to communicate back to the Router about the state of the transition. The\r\n     * Router wants to respond to these events in various ways. Because the `NavigationTransition`\r\n     * class is not public, this event subject is not publicly exposed.\r\n     */\r\n    events = new Subject();\r\n    /**\r\n     * Used to abort the current transition with an error.\r\n     */\r\n    transitionAbortSubject = new Subject();\r\n    configLoader = inject(RouterConfigLoader);\r\n    environmentInjector = inject(EnvironmentInjector);\r\n    destroyRef = inject(DestroyRef);\r\n    urlSerializer = inject(UrlSerializer);\r\n    rootContexts = inject(ChildrenOutletContexts);\r\n    location = inject(Location);\r\n    inputBindingEnabled = inject(INPUT_BINDER, { optional: true }) !== null;\r\n    titleStrategy = inject(TitleStrategy);\r\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\r\n    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\r\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\r\n    createViewTransition = inject(CREATE_VIEW_TRANSITION, { optional: true });\r\n    navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, { optional: true });\r\n    navigationId = 0;\r\n    get hasRequestedNavigation() {\r\n        return this.navigationId !== 0;\r\n    }\r\n    transitions;\r\n    /**\r\n     * Hook that enables you to pause navigation after the preactivation phase.\r\n     * Used by `RouterModule`.\r\n     *\r\n     * @internal\r\n     */\r\n    afterPreactivation = () => of(void 0);\r\n    /** @internal */\r\n    rootComponentType = null;\r\n    destroyed = false;\r\n    constructor() {\r\n        const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));\r\n        const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));\r\n        this.configLoader.onLoadEndListener = onLoadEnd;\r\n        this.configLoader.onLoadStartListener = onLoadStart;\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n        });\r\n    }\r\n    complete() {\r\n        this.transitions?.complete();\r\n    }\r\n    handleNavigationRequest(request) {\r\n        const id = ++this.navigationId;\r\n        this.transitions?.next({\r\n            ...request,\r\n            extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\r\n            targetSnapshot: null,\r\n            targetRouterState: null,\r\n            guards: { canActivateChecks: [], canDeactivateChecks: [] },\r\n            guardsResult: null,\r\n            id,\r\n        });\r\n    }\r\n    setupNavigations(router) {\r\n        this.transitions = new BehaviorSubject(null);\r\n        return this.transitions.pipe(filter((t) => t !== null), \r\n        // Using switchMap so we cancel executing navigations when a new one comes in\r\n        switchMap((overallTransitionState) => {\r\n            let completed = false;\r\n            let errored = false;\r\n            return of(overallTransitionState).pipe(switchMap((t) => {\r\n                // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\r\n                // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\r\n                // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\r\n                // https://github.com/ReactiveX/rxjs/issues/7455\r\n                if (this.navigationId > overallTransitionState.id) {\r\n                    const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode\r\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\r\n                        : '';\r\n                    this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\r\n                    return EMPTY;\r\n                }\r\n                this.currentTransition = overallTransitionState;\r\n                // Store the Navigation object\r\n                this.currentNavigation = {\r\n                    id: t.id,\r\n                    initialUrl: t.rawUrl,\r\n                    extractedUrl: t.extractedUrl,\r\n                    targetBrowserUrl: typeof t.extras.browserUrl === 'string'\r\n                        ? this.urlSerializer.parse(t.extras.browserUrl)\r\n                        : t.extras.browserUrl,\r\n                    trigger: t.source,\r\n                    extras: t.extras,\r\n                    previousNavigation: !this.lastSuccessfulNavigation\r\n                        ? null\r\n                        : {\r\n                            ...this.lastSuccessfulNavigation,\r\n                            previousNavigation: null,\r\n                        },\r\n                };\r\n                const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\r\n                const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\r\n                if (!urlTransition && onSameUrlNavigation !== 'reload') {\r\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\r\n                        ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\r\n                        : '';\r\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\r\n                    t.resolve(false);\r\n                    return EMPTY;\r\n                }\r\n                if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\r\n                    return of(t).pipe(\r\n                    // Fire NavigationStart event\r\n                    switchMap((t) => {\r\n                        this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\r\n                        if (t.id !== this.navigationId) {\r\n                            return EMPTY;\r\n                        }\r\n                        // This delay is required to match old behavior that forced\r\n                        // navigation to always be async\r\n                        return Promise.resolve(t);\r\n                    }), \r\n                    // Recognize\r\n                    recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy), \r\n                    // Update URL if in `eager` update mode\r\n                    tap((t) => {\r\n                        overallTransitionState.targetSnapshot = t.targetSnapshot;\r\n                        overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\r\n                        this.currentNavigation = {\r\n                            ...this.currentNavigation,\r\n                            finalUrl: t.urlAfterRedirects,\r\n                        };\r\n                        // Fire RoutesRecognized\r\n                        const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\r\n                        this.events.next(routesRecognized);\r\n                    }));\r\n                }\r\n                else if (urlTransition &&\r\n                    this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\r\n                    /* When the current URL shouldn't be processed, but the previous one\r\n                     * was, we handle this \"error condition\" by navigating to the\r\n                     * previously successful URL, but leaving the URL intact.*/\r\n                    const { id, extractedUrl, source, restoredState, extras } = t;\r\n                    const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\r\n                    this.events.next(navStart);\r\n                    const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\r\n                    this.currentTransition = overallTransitionState = {\r\n                        ...t,\r\n                        targetSnapshot,\r\n                        urlAfterRedirects: extractedUrl,\r\n                        extras: { ...extras, skipLocationChange: false, replaceUrl: false },\r\n                    };\r\n                    this.currentNavigation.finalUrl = extractedUrl;\r\n                    return of(overallTransitionState);\r\n                }\r\n                else {\r\n                    /* When neither the current or previous URL can be processed, do\r\n                     * nothing other than update router's internal reference to the\r\n                     * current \"settled\" URL. This way the next navigation will be coming\r\n                     * from the current URL in the browser.\r\n                     */\r\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\r\n                        ? `Navigation was ignored because the UrlHandlingStrategy` +\r\n                            ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\r\n                        : '';\r\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\r\n                    t.resolve(false);\r\n                    return EMPTY;\r\n                }\r\n            }), \r\n            // --- GUARDS ---\r\n            tap((t) => {\r\n                const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\r\n                this.events.next(guardsStart);\r\n            }), map((t) => {\r\n                this.currentTransition = overallTransitionState = {\r\n                    ...t,\r\n                    guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts),\r\n                };\r\n                return overallTransitionState;\r\n            }), checkGuards(this.environmentInjector, (evt) => this.events.next(evt)), tap((t) => {\r\n                overallTransitionState.guardsResult = t.guardsResult;\r\n                if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\r\n                    throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\r\n                }\r\n                const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\r\n                this.events.next(guardsEnd);\r\n            }), filter((t) => {\r\n                if (!t.guardsResult) {\r\n                    this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\r\n                    return false;\r\n                }\r\n                return true;\r\n            }), \r\n            // --- RESOLVE ---\r\n            switchTap((t) => {\r\n                if (t.guards.canActivateChecks.length === 0) {\r\n                    return undefined;\r\n                }\r\n                return of(t).pipe(tap((t) => {\r\n                    const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\r\n                    this.events.next(resolveStart);\r\n                }), switchMap((t) => {\r\n                    let dataResolved = false;\r\n                    return of(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\r\n                        next: () => (dataResolved = true),\r\n                        complete: () => {\r\n                            if (!dataResolved) {\r\n                                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode\r\n                                    ? `At least one route resolver didn't emit any value.`\r\n                                    : '', NavigationCancellationCode.NoDataFromResolver);\r\n                            }\r\n                        },\r\n                    }));\r\n                }), tap((t) => {\r\n                    const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\r\n                    this.events.next(resolveEnd);\r\n                }));\r\n            }), \r\n            // --- LOAD COMPONENTS ---\r\n            switchTap((t) => {\r\n                const loadComponents = (route) => {\r\n                    const loaders = [];\r\n                    if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\r\n                        loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap((loadedComponent) => {\r\n                            route.component = loadedComponent;\r\n                        }), map(() => void 0)));\r\n                    }\r\n                    for (const child of route.children) {\r\n                        loaders.push(...loadComponents(child));\r\n                    }\r\n                    return loaders;\r\n                };\r\n                return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));\r\n            }), switchTap(() => this.afterPreactivation()), switchMap(() => {\r\n                const { currentSnapshot, targetSnapshot } = overallTransitionState;\r\n                const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\r\n                // If view transitions are enabled, block the navigation until the view\r\n                // transition callback starts. Otherwise, continue immediately.\r\n                return viewTransitionStarted\r\n                    ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\r\n                    : of(overallTransitionState);\r\n            }), map((t) => {\r\n                const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\r\n                this.currentTransition = overallTransitionState = { ...t, targetRouterState };\r\n                this.currentNavigation.targetRouterState = targetRouterState;\r\n                return overallTransitionState;\r\n            }), tap(() => {\r\n                this.events.next(new BeforeActivateRoutes());\r\n            }), activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled), \r\n            // Ensure that if some observable used to drive the transition doesn't\r\n            // complete, the navigation still finalizes This should never happen, but\r\n            // this is done as a safety measure to avoid surfacing this error (#49567).\r\n            take(1), tap({\r\n                next: (t) => {\r\n                    completed = true;\r\n                    this.lastSuccessfulNavigation = this.currentNavigation;\r\n                    this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\r\n                    this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\r\n                    t.resolve(true);\r\n                },\r\n                complete: () => {\r\n                    completed = true;\r\n                },\r\n            }), \r\n            // There used to be a lot more logic happening directly within the\r\n            // transition Observable. Some of this logic has been refactored out to\r\n            // other places but there may still be errors that happen there. This gives\r\n            // us a way to cancel the transition from the outside. This may also be\r\n            // required in the future to support something like the abort signal of the\r\n            // Navigation API where the navigation gets aborted from outside the\r\n            // transition.\r\n            takeUntil(this.transitionAbortSubject.pipe(tap((err) => {\r\n                throw err;\r\n            }))), finalize(() => {\r\n                /* When the navigation stream finishes either through error or success,\r\n                 * we set the `completed` or `errored` flag. However, there are some\r\n                 * situations where we could get here without either of those being set.\r\n                 * For instance, a redirect during NavigationStart. Therefore, this is a\r\n                 * catch-all to make sure the NavigationCancel event is fired when a\r\n                 * navigation gets cancelled but not caught by other means. */\r\n                if (!completed && !errored) {\r\n                    const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode\r\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\r\n                        : '';\r\n                    this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\r\n                }\r\n                // Only clear current navigation if it is still set to the one that\r\n                // finalized.\r\n                if (this.currentTransition?.id === overallTransitionState.id) {\r\n                    this.currentNavigation = null;\r\n                    this.currentTransition = null;\r\n                }\r\n            }), catchError((e) => {\r\n                // If the application is already destroyed, the catch block should not\r\n                // execute anything in practice because other resources have already\r\n                // been released and destroyed.\r\n                if (this.destroyed) {\r\n                    overallTransitionState.resolve(false);\r\n                    return EMPTY;\r\n                }\r\n                errored = true;\r\n                /* This error type is issued during Redirect, and is handled as a\r\n                 * cancellation rather than an error. */\r\n                if (isNavigationCancelingError(e)) {\r\n                    this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\r\n                    // When redirecting, we need to delay resolving the navigation\r\n                    // promise and push it to the redirect navigation\r\n                    if (!isRedirectingNavigationCancelingError(e)) {\r\n                        overallTransitionState.resolve(false);\r\n                    }\r\n                    else {\r\n                        this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\r\n                    }\r\n                    /* All other errors should reset to the router's internal URL reference\r\n                     * to the pre-error state. */\r\n                }\r\n                else {\r\n                    const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\r\n                    try {\r\n                        const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\r\n                        if (navigationErrorHandlerResult instanceof RedirectCommand) {\r\n                            const { message, cancellationCode } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\r\n                            this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\r\n                            this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\r\n                        }\r\n                        else {\r\n                            this.events.next(navigationError);\r\n                            throw e;\r\n                        }\r\n                    }\r\n                    catch (ee) {\r\n                        // TODO(atscott): consider flipping the default behavior of\r\n                        // resolveNavigationPromiseOnError to be `resolve(false)` when\r\n                        // undefined. This is the most sane thing to do given that\r\n                        // applications very rarely handle the promise rejection and, as a\r\n                        // result, would get \"unhandled promise rejection\" console logs.\r\n                        // The vast majority of applications would not be affected by this\r\n                        // change so omitting a migration seems reasonable. Instead,\r\n                        // applications that rely on rejection can specifically opt-in to the\r\n                        // old behavior.\r\n                        if (this.options.resolveNavigationPromiseOnError) {\r\n                            overallTransitionState.resolve(false);\r\n                        }\r\n                        else {\r\n                            overallTransitionState.reject(ee);\r\n                        }\r\n                    }\r\n                }\r\n                return EMPTY;\r\n            }));\r\n            // casting because `pipe` returns observable({}) when called with 8+ arguments\r\n        }));\r\n    }\r\n    cancelNavigationTransition(t, reason, code) {\r\n        const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\r\n        this.events.next(navCancel);\r\n        t.resolve(false);\r\n    }\r\n    /**\r\n     * @returns Whether we're navigating to somewhere that is not what the Router is\r\n     * currently set to.\r\n     */\r\n    isUpdatingInternalState() {\r\n        // TODO(atscott): The serializer should likely be used instead of\r\n        // `UrlTree.toString()`. Custom serializers are often written to handle\r\n        // things better than the default one (objects, for example will be\r\n        // [Object object] with the custom serializer and be \"the same\" when they\r\n        // aren't).\r\n        // (Same for isUpdatedBrowserUrl)\r\n        return (this.currentTransition?.extractedUrl.toString() !==\r\n            this.currentTransition?.currentUrlTree.toString());\r\n    }\r\n    /**\r\n     * @returns Whether we're updating the browser URL to something new (navigation is going\r\n     * to somewhere not displayed in the URL bar and we will update the URL\r\n     * bar if navigation succeeds).\r\n     */\r\n    isUpdatedBrowserUrl() {\r\n        // The extracted URL is the part of the URL that this application cares about. `extract` may\r\n        // return only part of the browser URL and that part may have not changed even if some other\r\n        // portion of the URL did.\r\n        const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\r\n        const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\r\n        return (currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\r\n            !this.currentNavigation?.extras.skipLocationChange);\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: NavigationTransitions, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: NavigationTransitions, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: NavigationTransitions, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [] });\r\nfunction isBrowserTriggeredNavigation(source) {\r\n    return source !== IMPERATIVE_NAVIGATION;\r\n}\r\n\r\n/**\r\n * @description\r\n *\r\n * Provides a way to customize when activated routes get reused.\r\n *\r\n * @publicApi\r\n */\r\nclass RouteReuseStrategy {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouteReuseStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouteReuseStrategy, providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: RouteReuseStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) }]\r\n        }] });\r\n/**\r\n * @description\r\n *\r\n * This base route reuse strategy only reuses routes when the matched router configs are\r\n * identical. This prevents components from being destroyed and recreated\r\n * when just the route parameters, query parameters or fragment change\r\n * (that is, the existing component is _reused_).\r\n *\r\n * This strategy does not store any routes for later reuse.\r\n *\r\n * Angular uses this strategy by default.\r\n *\r\n *\r\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\r\n * class that extends the `BaseRouteReuseStrategy` one.\r\n * @publicApi\r\n */\r\nclass BaseRouteReuseStrategy {\r\n    /**\r\n     * Whether the given route should detach for later reuse.\r\n     * Always returns false for `BaseRouteReuseStrategy`.\r\n     * */\r\n    shouldDetach(route) {\r\n        return false;\r\n    }\r\n    /**\r\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\r\n     */\r\n    store(route, detachedTree) { }\r\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\r\n    shouldAttach(route) {\r\n        return false;\r\n    }\r\n    /** Returns `null` because this strategy does not store routes for later re-use. */\r\n    retrieve(route) {\r\n        return null;\r\n    }\r\n    /**\r\n     * Determines if a route should be reused.\r\n     * This strategy returns `true` when the future route config and current route config are\r\n     * identical.\r\n     */\r\n    shouldReuseRoute(future, curr) {\r\n        return future.routeConfig === curr.routeConfig;\r\n    }\r\n}\r\nclass DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultRouteReuseStrategy, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultRouteReuseStrategy, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: DefaultRouteReuseStrategy, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\r\n\r\nclass StateManager {\r\n    urlSerializer = inject(UrlSerializer);\r\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\r\n    canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\r\n    location = inject(Location);\r\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\r\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\r\n    currentUrlTree = new UrlTree();\r\n    /**\r\n     * Returns the currently activated `UrlTree`.\r\n     *\r\n     * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\r\n     * `UrlHandlingStrategy`).\r\n     *\r\n     * The value is set after finding the route config tree to activate but before activating the\r\n     * route.\r\n     */\r\n    getCurrentUrlTree() {\r\n        return this.currentUrlTree;\r\n    }\r\n    rawUrlTree = this.currentUrlTree;\r\n    /**\r\n     * Returns a `UrlTree` that is represents what the browser is actually showing.\r\n     *\r\n     * In the life of a navigation transition:\r\n     * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\r\n     * navigated to.\r\n     * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\r\n     * to `UrlHandlingStrategy`).\r\n     * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\r\n     * original raw URL.\r\n     *\r\n     * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\r\n     * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\r\n     * deviated from the raw `UrlTree`.\r\n     *\r\n     * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\r\n     * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\r\n     * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\r\n     * occurs, it needs to know the _whole_ browser URL, not just the part handled by\r\n     * `UrlHandlingStrategy`.\r\n     * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\r\n     * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\r\n     * location change listener due to a URL update by the AngularJS router. In this case, the router\r\n     * still need to know what the browser's URL is for future navigations.\r\n     */\r\n    getRawUrlTree() {\r\n        return this.rawUrlTree;\r\n    }\r\n    createBrowserPath({ finalUrl, initialUrl, targetBrowserUrl }) {\r\n        const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\r\n        const url = targetBrowserUrl ?? rawUrl;\r\n        const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\r\n        return path;\r\n    }\r\n    commitTransition({ targetRouterState, finalUrl, initialUrl }) {\r\n        // If we are committing the transition after having a final URL and target state, we're updating\r\n        // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\r\n        // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\r\n        if (finalUrl && targetRouterState) {\r\n            this.currentUrlTree = finalUrl;\r\n            this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\r\n            this.routerState = targetRouterState;\r\n        }\r\n        else {\r\n            this.rawUrlTree = initialUrl;\r\n        }\r\n    }\r\n    routerState = createEmptyState(null);\r\n    /** Returns the current RouterState. */\r\n    getRouterState() {\r\n        return this.routerState;\r\n    }\r\n    stateMemento = this.createStateMemento();\r\n    updateStateMemento() {\r\n        this.stateMemento = this.createStateMemento();\r\n    }\r\n    createStateMemento() {\r\n        return {\r\n            rawUrlTree: this.rawUrlTree,\r\n            currentUrlTree: this.currentUrlTree,\r\n            routerState: this.routerState,\r\n        };\r\n    }\r\n    resetInternalState({ finalUrl }) {\r\n        this.routerState = this.stateMemento.routerState;\r\n        this.currentUrlTree = this.stateMemento.currentUrlTree;\r\n        // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\r\n        // configured to handle only part of the navigation URL. This means we would only want to reset\r\n        // the part of the navigation handled by the Angular router rather than the whole URL. In\r\n        // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\r\n        // when merging, such as the query params so they are not lost on a refresh.\r\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: StateManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: StateManager, providedIn: 'root', useFactory: () => inject(HistoryStateManager) });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: StateManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root', useFactory: () => inject(HistoryStateManager) }]\r\n        }] });\r\nclass HistoryStateManager extends StateManager {\r\n    /**\r\n     * The id of the currently active page in the router.\r\n     * Updated to the transition's target id on a successful navigation.\r\n     *\r\n     * This is used to track what page the router last activated. When an attempted navigation fails,\r\n     * the router can then use this to compute how to restore the state back to the previously active\r\n     * page.\r\n     */\r\n    currentPageId = 0;\r\n    lastSuccessfulId = -1;\r\n    restoredState() {\r\n        return this.location.getState();\r\n    }\r\n    /**\r\n     * The ɵrouterPageId of whatever page is currently active in the browser history. This is\r\n     * important for computing the target page id for new navigations because we need to ensure each\r\n     * page id in the browser history is 1 more than the previous entry.\r\n     */\r\n    get browserPageId() {\r\n        if (this.canceledNavigationResolution !== 'computed') {\r\n            return this.currentPageId;\r\n        }\r\n        return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\r\n    }\r\n    registerNonRouterCurrentEntryChangeListener(listener) {\r\n        return this.location.subscribe((event) => {\r\n            if (event['type'] === 'popstate') {\r\n                // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\r\n                // hybrid apps.\r\n                setTimeout(() => {\r\n                    listener(event['url'], event.state, 'popstate');\r\n                });\r\n            }\r\n        });\r\n    }\r\n    handleRouterEvent(e, currentTransition) {\r\n        if (e instanceof NavigationStart) {\r\n            this.updateStateMemento();\r\n        }\r\n        else if (e instanceof NavigationSkipped) {\r\n            this.commitTransition(currentTransition);\r\n        }\r\n        else if (e instanceof RoutesRecognized) {\r\n            if (this.urlUpdateStrategy === 'eager') {\r\n                if (!currentTransition.extras.skipLocationChange) {\r\n                    this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\r\n                }\r\n            }\r\n        }\r\n        else if (e instanceof BeforeActivateRoutes) {\r\n            this.commitTransition(currentTransition);\r\n            if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\r\n                this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\r\n            }\r\n        }\r\n        else if (e instanceof NavigationCancel &&\r\n            (e.code === NavigationCancellationCode.GuardRejected ||\r\n                e.code === NavigationCancellationCode.NoDataFromResolver)) {\r\n            this.restoreHistory(currentTransition);\r\n        }\r\n        else if (e instanceof NavigationError) {\r\n            this.restoreHistory(currentTransition, true);\r\n        }\r\n        else if (e instanceof NavigationEnd) {\r\n            this.lastSuccessfulId = e.id;\r\n            this.currentPageId = this.browserPageId;\r\n        }\r\n    }\r\n    setBrowserUrl(path, { extras, id }) {\r\n        const { replaceUrl, state } = extras;\r\n        if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\r\n            // replacements do not update the target page\r\n            const currentBrowserPageId = this.browserPageId;\r\n            const newState = {\r\n                ...state,\r\n                ...this.generateNgRouterState(id, currentBrowserPageId),\r\n            };\r\n            this.location.replaceState(path, '', newState);\r\n        }\r\n        else {\r\n            const newState = {\r\n                ...state,\r\n                ...this.generateNgRouterState(id, this.browserPageId + 1),\r\n            };\r\n            this.location.go(path, '', newState);\r\n        }\r\n    }\r\n    /**\r\n     * Performs the necessary rollback action to restore the browser URL to the\r\n     * state before the transition.\r\n     */\r\n    restoreHistory(navigation, restoringFromCaughtError = false) {\r\n        if (this.canceledNavigationResolution === 'computed') {\r\n            const currentBrowserPageId = this.browserPageId;\r\n            const targetPagePosition = this.currentPageId - currentBrowserPageId;\r\n            if (targetPagePosition !== 0) {\r\n                this.location.historyGo(targetPagePosition);\r\n            }\r\n            else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\r\n                // We got to the activation stage (where currentUrlTree is set to the navigation's\r\n                // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\r\n                // We still need to reset the router state back to what it was when the navigation started.\r\n                this.resetInternalState(navigation);\r\n                this.resetUrlToCurrentUrlTree();\r\n            }\r\n            else ;\r\n        }\r\n        else if (this.canceledNavigationResolution === 'replace') {\r\n            // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\r\n            // for `deferred` navigations that haven't change the internal state yet because guards\r\n            // reject. For 'eager' navigations, it seems like we also really should reset the state\r\n            // because the navigation was cancelled. Investigate if this can be done by running TGP.\r\n            if (restoringFromCaughtError) {\r\n                this.resetInternalState(navigation);\r\n            }\r\n            this.resetUrlToCurrentUrlTree();\r\n        }\r\n    }\r\n    resetUrlToCurrentUrlTree() {\r\n        this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\r\n    }\r\n    generateNgRouterState(navigationId, routerPageId) {\r\n        if (this.canceledNavigationResolution === 'computed') {\r\n            return { navigationId, ɵrouterPageId: routerPageId };\r\n        }\r\n        return { navigationId };\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: HistoryStateManager, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: HistoryStateManager, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: HistoryStateManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\r\n\r\n/**\r\n * Performs the given action once the router finishes its next/current navigation.\r\n *\r\n * The navigation is considered complete under the following conditions:\r\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\r\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\r\n * redirecting/superseding navigation must finish.\r\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\r\n */\r\nfunction afterNextNavigation(router, action) {\r\n    router.events\r\n        .pipe(filter((e) => e instanceof NavigationEnd ||\r\n        e instanceof NavigationCancel ||\r\n        e instanceof NavigationError ||\r\n        e instanceof NavigationSkipped), map((e) => {\r\n        if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\r\n            return 0 /* NavigationResult.COMPLETE */;\r\n        }\r\n        const redirecting = e instanceof NavigationCancel\r\n            ? e.code === NavigationCancellationCode.Redirect ||\r\n                e.code === NavigationCancellationCode.SupersededByNewNavigation\r\n            : false;\r\n        return redirecting ? 2 /* NavigationResult.REDIRECTING */ : 1 /* NavigationResult.FAILED */;\r\n    }), filter((result) => result !== 2 /* NavigationResult.REDIRECTING */), take(1))\r\n        .subscribe(() => {\r\n        action();\r\n    });\r\n}\r\n\r\n/**\r\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\r\n * (exact = true).\r\n */\r\nconst exactMatchOptions = {\r\n    paths: 'exact',\r\n    fragment: 'ignored',\r\n    matrixParams: 'ignored',\r\n    queryParams: 'exact',\r\n};\r\n/**\r\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\r\n * (exact = false).\r\n */\r\nconst subsetMatchOptions = {\r\n    paths: 'subset',\r\n    fragment: 'ignored',\r\n    matrixParams: 'ignored',\r\n    queryParams: 'subset',\r\n};\r\n/**\r\n * @description\r\n *\r\n * A service that facilitates navigation among views and URL manipulation capabilities.\r\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\r\n *\r\n * @see {@link Route}\r\n * @see {@link provideRouter}\r\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\r\n *\r\n * @ngModule RouterModule\r\n *\r\n * @publicApi\r\n */\r\nclass Router {\r\n    get currentUrlTree() {\r\n        return this.stateManager.getCurrentUrlTree();\r\n    }\r\n    get rawUrlTree() {\r\n        return this.stateManager.getRawUrlTree();\r\n    }\r\n    disposed = false;\r\n    nonRouterCurrentEntryChangeSubscription;\r\n    console = inject(_Console);\r\n    stateManager = inject(StateManager);\r\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\r\n    pendingTasks = inject(_PendingTasksInternal);\r\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\r\n    navigationTransitions = inject(NavigationTransitions);\r\n    urlSerializer = inject(UrlSerializer);\r\n    location = inject(Location);\r\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\r\n    /**\r\n     * The private `Subject` type for the public events exposed in the getter. This is used internally\r\n     * to push events to. The separate field allows us to expose separate types in the public API\r\n     * (i.e., an Observable rather than the Subject).\r\n     */\r\n    _events = new Subject();\r\n    /**\r\n     * An event stream for routing events.\r\n     */\r\n    get events() {\r\n        // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\r\n        // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\r\n        // allowed/supported but we still have to fix these or file bugs against the teams before making\r\n        // the change.\r\n        return this._events;\r\n    }\r\n    /**\r\n     * The current state of routing in this NgModule.\r\n     */\r\n    get routerState() {\r\n        return this.stateManager.getRouterState();\r\n    }\r\n    /**\r\n     * True if at least one navigation event has occurred,\r\n     * false otherwise.\r\n     */\r\n    navigated = false;\r\n    /**\r\n     * A strategy for re-using routes.\r\n     *\r\n     * @deprecated Configure using `providers` instead:\r\n     *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\r\n     */\r\n    routeReuseStrategy = inject(RouteReuseStrategy);\r\n    /**\r\n     * How to handle a navigation request to the current URL.\r\n     *\r\n     *\r\n     * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\r\n     * @see {@link withRouterConfig}\r\n     * @see {@link provideRouter}\r\n     * @see {@link RouterModule}\r\n     */\r\n    onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\r\n    config = inject(ROUTES, { optional: true })?.flat() ?? [];\r\n    /**\r\n     * Indicates whether the application has opted in to binding Router data to component inputs.\r\n     *\r\n     * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\r\n     * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\r\n     */\r\n    componentInputBindingEnabled = !!inject(INPUT_BINDER, { optional: true });\r\n    constructor() {\r\n        this.resetConfig(this.config);\r\n        this.navigationTransitions.setupNavigations(this).subscribe({\r\n            error: (e) => {\r\n                this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\r\n            },\r\n        });\r\n        this.subscribeToNavigationEvents();\r\n    }\r\n    eventsSubscription = new Subscription();\r\n    subscribeToNavigationEvents() {\r\n        const subscription = this.navigationTransitions.events.subscribe((e) => {\r\n            try {\r\n                const currentTransition = this.navigationTransitions.currentTransition;\r\n                const currentNavigation = this.navigationTransitions.currentNavigation;\r\n                if (currentTransition !== null && currentNavigation !== null) {\r\n                    this.stateManager.handleRouterEvent(e, currentNavigation);\r\n                    if (e instanceof NavigationCancel &&\r\n                        e.code !== NavigationCancellationCode.Redirect &&\r\n                        e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\r\n                        // It seems weird that `navigated` is set to `true` when the navigation is rejected,\r\n                        // however it's how things were written initially. Investigation would need to be done\r\n                        // to determine if this can be removed.\r\n                        this.navigated = true;\r\n                    }\r\n                    else if (e instanceof NavigationEnd) {\r\n                        this.navigated = true;\r\n                    }\r\n                    else if (e instanceof RedirectRequest) {\r\n                        const opts = e.navigationBehaviorOptions;\r\n                        const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\r\n                        const extras = {\r\n                            browserUrl: currentTransition.extras.browserUrl,\r\n                            info: currentTransition.extras.info,\r\n                            skipLocationChange: currentTransition.extras.skipLocationChange,\r\n                            // The URL is already updated at this point if we have 'eager' URL\r\n                            // updates or if the navigation was triggered by the browser (back\r\n                            // button, URL bar, etc). We want to replace that item in history\r\n                            // if the navigation is rejected.\r\n                            replaceUrl: currentTransition.extras.replaceUrl ||\r\n                                this.urlUpdateStrategy === 'eager' ||\r\n                                isBrowserTriggeredNavigation(currentTransition.source),\r\n                            // allow developer to override default options with RedirectCommand\r\n                            ...opts,\r\n                        };\r\n                        this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\r\n                            resolve: currentTransition.resolve,\r\n                            reject: currentTransition.reject,\r\n                            promise: currentTransition.promise,\r\n                        });\r\n                    }\r\n                }\r\n                // Note that it's important to have the Router process the events _before_ the event is\r\n                // pushed through the public observable. This ensures the correct router state is in place\r\n                // before applications observe the events.\r\n                if (isPublicRouterEvent(e)) {\r\n                    this._events.next(e);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this.navigationTransitions.transitionAbortSubject.next(e);\r\n            }\r\n        });\r\n        this.eventsSubscription.add(subscription);\r\n    }\r\n    /** @internal */\r\n    resetRootComponentType(rootComponentType) {\r\n        // TODO: vsavkin router 4.0 should make the root component set to null\r\n        // this will simplify the lifecycle of the router.\r\n        this.routerState.root.component = rootComponentType;\r\n        this.navigationTransitions.rootComponentType = rootComponentType;\r\n    }\r\n    /**\r\n     * Sets up the location change listener and performs the initial navigation.\r\n     */\r\n    initialNavigation() {\r\n        this.setUpLocationChangeListener();\r\n        if (!this.navigationTransitions.hasRequestedNavigation) {\r\n            this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\r\n        }\r\n    }\r\n    /**\r\n     * Sets up the location change listener. This listener detects navigations triggered from outside\r\n     * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\r\n     * navigation so that the correct events, guards, etc. are triggered.\r\n     */\r\n    setUpLocationChangeListener() {\r\n        // Don't need to use Zone.wrap any more, because zone.js\r\n        // already patch onPopState, so location change callback will\r\n        // run into ngZone\r\n        this.nonRouterCurrentEntryChangeSubscription ??=\r\n            this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\r\n                this.navigateToSyncWithBrowser(url, source, state);\r\n            });\r\n    }\r\n    /**\r\n     * Schedules a router navigation to synchronize Router state with the browser state.\r\n     *\r\n     * This is done as a response to a popstate event and the initial navigation. These\r\n     * two scenarios represent times when the browser URL/state has been updated and\r\n     * the Router needs to respond to ensure its internal state matches.\r\n     */\r\n    navigateToSyncWithBrowser(url, source, state) {\r\n        const extras = { replaceUrl: true };\r\n        // TODO: restoredState should always include the entire state, regardless\r\n        // of navigationId. This requires a breaking change to update the type on\r\n        // NavigationStart’s restoredState, which currently requires navigationId\r\n        // to always be present. The Router used to only restore history state if\r\n        // a navigationId was present.\r\n        // The stored navigationId is used by the RouterScroller to retrieve the scroll\r\n        // position for the page.\r\n        const restoredState = state?.navigationId ? state : null;\r\n        // Separate to NavigationStart.restoredState, we must also restore the state to\r\n        // history.state and generate a new navigationId, since it will be overwritten\r\n        if (state) {\r\n            const stateCopy = { ...state };\r\n            delete stateCopy.navigationId;\r\n            delete stateCopy.ɵrouterPageId;\r\n            if (Object.keys(stateCopy).length !== 0) {\r\n                extras.state = stateCopy;\r\n            }\r\n        }\r\n        const urlTree = this.parseUrl(url);\r\n        this.scheduleNavigation(urlTree, source, restoredState, extras);\r\n    }\r\n    /** The current URL. */\r\n    get url() {\r\n        return this.serializeUrl(this.currentUrlTree);\r\n    }\r\n    /**\r\n     * Returns the current `Navigation` object when the router is navigating,\r\n     * and `null` when idle.\r\n     */\r\n    getCurrentNavigation() {\r\n        return this.navigationTransitions.currentNavigation;\r\n    }\r\n    /**\r\n     * The `Navigation` object of the most recent navigation to succeed and `null` if there\r\n     *     has not been a successful navigation yet.\r\n     */\r\n    get lastSuccessfulNavigation() {\r\n        return this.navigationTransitions.lastSuccessfulNavigation;\r\n    }\r\n    /**\r\n     * Resets the route configuration used for navigation and generating links.\r\n     *\r\n     * @param config The route array for the new configuration.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ```ts\r\n     * router.resetConfig([\r\n     *  { path: 'team/:id', component: TeamCmp, children: [\r\n     *    { path: 'simple', component: SimpleCmp },\r\n     *    { path: 'user/:name', component: UserCmp }\r\n     *  ]}\r\n     * ]);\r\n     * ```\r\n     */\r\n    resetConfig(config) {\r\n        (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\r\n        this.config = config.map(standardizeConfig);\r\n        this.navigated = false;\r\n    }\r\n    /** @docs-private */\r\n    ngOnDestroy() {\r\n        this.dispose();\r\n    }\r\n    /** Disposes of the router. */\r\n    dispose() {\r\n        // We call `unsubscribe()` to release observers, as users may forget to\r\n        // unsubscribe manually when subscribing to `router.events`. We do not call\r\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\r\n        // operator and the observable completes before emitting a value,\r\n        // RxJS will throw an error.\r\n        this._events.unsubscribe();\r\n        this.navigationTransitions.complete();\r\n        if (this.nonRouterCurrentEntryChangeSubscription) {\r\n            this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\r\n            this.nonRouterCurrentEntryChangeSubscription = undefined;\r\n        }\r\n        this.disposed = true;\r\n        this.eventsSubscription.unsubscribe();\r\n    }\r\n    /**\r\n     * Appends URL segments to the current URL tree to create a new URL tree.\r\n     *\r\n     * @param commands An array of URL fragments with which to construct the new URL tree.\r\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n     * segments, followed by the parameters for each segment.\r\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\r\n     * property of the options object, if supplied.\r\n     * @param navigationExtras Options that control the navigation strategy.\r\n     * @returns The new URL tree.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * ```\r\n     * // create /team/33/user/11\r\n     * router.createUrlTree(['/team', 33, 'user', 11]);\r\n     *\r\n     * // create /team/33;expand=true/user/11\r\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\r\n     *\r\n     * // you can collapse static segments like this (this works only with the first passed-in value):\r\n     * router.createUrlTree(['/team/33/user', userId]);\r\n     *\r\n     * // If the first segment can contain slashes, and you do not want the router to split it,\r\n     * // you can do the following:\r\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\r\n     *\r\n     * // create /team/33/(user/11//right:chat)\r\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\r\n     *\r\n     * // remove the right secondary node\r\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\r\n     *\r\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\r\n     *\r\n     * // navigate to /team/33/user/11/details\r\n     * router.createUrlTree(['details'], {relativeTo: route});\r\n     *\r\n     * // navigate to /team/33/user/22\r\n     * router.createUrlTree(['../22'], {relativeTo: route});\r\n     *\r\n     * // navigate to /team/44/user/22\r\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\r\n     *\r\n     * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\r\n     * tree should be created relative to the root.\r\n     * ```\r\n     */\r\n    createUrlTree(commands, navigationExtras = {}) {\r\n        const { relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment } = navigationExtras;\r\n        const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\r\n        let q = null;\r\n        switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\r\n            case 'merge':\r\n                q = { ...this.currentUrlTree.queryParams, ...queryParams };\r\n                break;\r\n            case 'preserve':\r\n                q = this.currentUrlTree.queryParams;\r\n                break;\r\n            default:\r\n                q = queryParams || null;\r\n        }\r\n        if (q !== null) {\r\n            q = this.removeEmptyProps(q);\r\n        }\r\n        let relativeToUrlSegmentGroup;\r\n        try {\r\n            const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\r\n            relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\r\n        }\r\n        catch (e) {\r\n            // This is strictly for backwards compatibility with tests that create\r\n            // invalid `ActivatedRoute` mocks.\r\n            // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\r\n            // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\r\n            // the moment.\r\n            if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\r\n                // Navigations that were absolute in the old way of creating UrlTrees\r\n                // would still work because they wouldn't attempt to match the\r\n                // segments in the `ActivatedRoute` to the `currentUrlTree` but\r\n                // instead just replace the root segment with the navigation result.\r\n                // Non-absolute navigations would fail to apply the commands because\r\n                // the logic could not find the segment to replace (so they'd act like there were no\r\n                // commands).\r\n                commands = [];\r\n            }\r\n            relativeToUrlSegmentGroup = this.currentUrlTree.root;\r\n        }\r\n        return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\r\n    }\r\n    /**\r\n     * Navigates to a view using an absolute route path.\r\n     *\r\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\r\n     *     current URL.\r\n     * @param extras An object containing properties that modify the navigation strategy.\r\n     *\r\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\r\n     * to 'false' when navigation fails, or is rejected on error.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following calls request navigation to an absolute path.\r\n     *\r\n     * ```ts\r\n     * router.navigateByUrl(\"/team/33/user/11\");\r\n     *\r\n     * // Navigate without updating the URL\r\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\r\n     * ```\r\n     *\r\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\r\n     *\r\n     */\r\n    navigateByUrl(url, extras = {\r\n        skipLocationChange: false,\r\n    }) {\r\n        const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\r\n        const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\r\n        return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\r\n    }\r\n    /**\r\n     * Navigate based on the provided array of commands and a starting point.\r\n     * If no starting route is provided, the navigation is absolute.\r\n     *\r\n     * @param commands An array of URL fragments with which to construct the target URL.\r\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\r\n     * segments, followed by the parameters for each segment.\r\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\r\n     * of the options object, if supplied.\r\n     * @param extras An options object that determines how the URL should be constructed or\r\n     *     interpreted.\r\n     *\r\n     * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\r\n     *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\r\n     * not `true`.\r\n     *\r\n     * @usageNotes\r\n     *\r\n     * The following calls request navigation to a dynamic route path relative to the current URL.\r\n     *\r\n     * ```ts\r\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\r\n     *\r\n     * // Navigate without updating the URL, overriding the default behavior\r\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\r\n     * ```\r\n     *\r\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\r\n     *\r\n     */\r\n    navigate(commands, extras = { skipLocationChange: false }) {\r\n        validateCommands(commands);\r\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\r\n    }\r\n    /** Serializes a `UrlTree` into a string */\r\n    serializeUrl(url) {\r\n        return this.urlSerializer.serialize(url);\r\n    }\r\n    /** Parses a string into a `UrlTree` */\r\n    parseUrl(url) {\r\n        try {\r\n            return this.urlSerializer.parse(url);\r\n        }\r\n        catch {\r\n            return this.urlSerializer.parse('/');\r\n        }\r\n    }\r\n    isActive(url, matchOptions) {\r\n        let options;\r\n        if (matchOptions === true) {\r\n            options = { ...exactMatchOptions };\r\n        }\r\n        else if (matchOptions === false) {\r\n            options = { ...subsetMatchOptions };\r\n        }\r\n        else {\r\n            options = matchOptions;\r\n        }\r\n        if (isUrlTree(url)) {\r\n            return containsTree(this.currentUrlTree, url, options);\r\n        }\r\n        const urlTree = this.parseUrl(url);\r\n        return containsTree(this.currentUrlTree, urlTree, options);\r\n    }\r\n    removeEmptyProps(params) {\r\n        return Object.entries(params).reduce((result, [key, value]) => {\r\n            if (value !== null && value !== undefined) {\r\n                result[key] = value;\r\n            }\r\n            return result;\r\n        }, {});\r\n    }\r\n    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\r\n        if (this.disposed) {\r\n            return Promise.resolve(false);\r\n        }\r\n        let resolve;\r\n        let reject;\r\n        let promise;\r\n        if (priorPromise) {\r\n            resolve = priorPromise.resolve;\r\n            reject = priorPromise.reject;\r\n            promise = priorPromise.promise;\r\n        }\r\n        else {\r\n            promise = new Promise((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        }\r\n        // Indicate that the navigation is happening.\r\n        const taskId = this.pendingTasks.add();\r\n        afterNextNavigation(this, () => {\r\n            // Remove pending task in a microtask to allow for cancelled\r\n            // initial navigations and redirects within the same task.\r\n            queueMicrotask(() => this.pendingTasks.remove(taskId));\r\n        });\r\n        this.navigationTransitions.handleNavigationRequest({\r\n            source,\r\n            restoredState,\r\n            currentUrlTree: this.currentUrlTree,\r\n            currentRawUrl: this.currentUrlTree,\r\n            rawUrl,\r\n            extras,\r\n            resolve: resolve,\r\n            reject: reject,\r\n            promise,\r\n            currentSnapshot: this.routerState.snapshot,\r\n            currentRouterState: this.routerState,\r\n        });\r\n        // Make sure that the error is propagated even though `processNavigations` catch\r\n        // handler does not rethrow\r\n        return promise.catch((e) => {\r\n            return Promise.reject(e);\r\n        });\r\n    }\r\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: Router, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: Router, providedIn: 'root' });\r\n}\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.15\", ngImport: i0, type: Router, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: () => [] });\r\nfunction validateCommands(commands) {\r\n    for (let i = 0; i < commands.length; i++) {\r\n        const cmd = commands[i];\r\n        if (cmd == null) {\r\n            throw new _RuntimeError(4008 /* RuntimeErrorCode.NULLISH_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                `The requested path contains ${cmd} segment at index ${i}`);\r\n        }\r\n    }\r\n}\r\nfunction isPublicRouterEvent(e) {\r\n    return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\r\n}\r\n\r\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, isUrlTree, loadChildren, stringifyEvent, ɵEmptyOutletComponent };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}